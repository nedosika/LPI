# 110.2 Урок 1

| **Сертификат:** | LPIC-1                                      |
|:----------------|:--------------------------------------------|
| **Версия:**     | 5.0                                         |
| **Тема:**       | 110 Безопасность                            |                           
| **Цель:**       | 110.3 Настройка безопасности хоста    |
| **Урок:**       | 1 из 1                                      |


## Введение

В этой главе объясняются четыре основных способа повышения безопасности хоста: 
1. Некоторые основные команды и параметры конфигурации для повышения безопасности аутентификации с использованием теневых паролей. 
2. Как использовать супердемоны для прослушивания входящих сетевых подключений. 
3. Проверка сетевых сервисов на наличие лишних демонов. 
4. Обертки TCP как своего рода простой брандмауэр.


## Повышение безопасности аутентификации с помощью теневых паролей

Основные компоненты данных учетной записи пользователя хранятся в файле `/etc/passwd`. Этот файл содержит семь полей: имя пользователя, идентификатор пользователя, идентификатор группы, пароль, комментарий (также известный как GECOS), расположение домашнего каталога и, наконец, оболочка по умолчанию. Простой способ запомнить порядок этих полей - подумать о процессе входа пользователя в систему: сначала вы вводите имя для входа, во-вторых, система сопоставляет его с идентификатором пользователя (uid) и, в-третьих, с идентификатором группы (gid). Четвертый шаг запрашивает пароль, пятый ищет комментарий, шестой входит в домашний каталог пользователя, а седьмой шаг устанавливает оболочку по умолчанию. 

Хотя в современных системах пароль больше не хранится в файле `/etc/passwd`. Вместо этого поле пароля содержит только символ `x` в нижнем регистре. Файл `/etc/passwd` должен быть доступен для чтения всем пользователям. Поэтому хранить там пароли - не лучшая идея. Символ `x` указывает, что зашифрованный (хешированный) пароль фактически хранится в файле `/etc/shadow`. Этот файл не должен быть доступен для чтения всем пользователям. 

Параметры пароля настраиваются с помощью команд `passwd` и `chage`. Обе команды изменят запись для пользователя `emma` в файле `/etc/shadow`. Как суперпользователь вы можете установить пароль для пользователя `emma` с помощью следующей команды:

```console
$ sudo passwd emma
New password:
Retype new password:
passwd: password updated successfully
```

Затем вам будет дважды предложено подтвердить новый пароль. 

Чтобы перечислить время истечения срока действия пароля и другие параметры истечения срока действия пароля для пользователя `emma`:

```console
$ sudo chage -l emma
Last password change					: Apr 27, 2020
Password expires					: never
Password inactive					: never
Account expires						: never
Minimum number of days between password change		: 0
Maximum number of days between password change		: 99999
Number of days of warning before password expires	: 7
```

Чтобы предотвратить вход пользователя `emma` в систему, суперпользователь может установить дату истечения срока действия пароля, предшествующую текущей дате. Например, если сегодняшняя дата - 27 марта 2020 г., вы можете истечь срок действия пароля пользователя, указав более старую дату:

```console
$ sudo chage -E 2020-03-28 emma
```

В качестве альтернативы суперпользователь может использовать:

```console
$ sudo passwd -l emma
```

для временной блокировки учетной записи с помощью параметра `-l` для `passwd`. Чтобы проверить влияние этих изменений, попробуйте войти в систему под учетной записью `emma`:

```console
$ sudo login emma
Password:
Your account has expired; please contact your system administrator

Authentication failure
```

Чтобы запретить всем пользователям, кроме пользователя `root`, временно войти в систему, суперпользователь может создать файл с именем `/etc/nologin`. Этот файл может содержать сообщение для пользователей, уведомляющее их о том, почему они не могут войти в систему (например, уведомления о техническом обслуживании системы). Подробнее см. `man 5 nologin`. Обратите внимание, что есть также команда `nologin`, которую можно использовать для предотвращения входа в систему, если она установлена в качестве оболочки по умолчанию для пользователя. Например:

```console
$ sudo usermod -s /sbin/nologin emma
```

Подробнее см. `man 8 nologin`.


## Как использовать Superdaemon для прослушивания входящих сетевых подключений

Сетевые службы, такие как веб-серверы, почтовые серверы и серверы печати, обычно работают как автономная служба, прослушивающая выделенный сетевой порт. Все эти автономные службы работают параллельно. В классической системе на основе Sys-V-init каждой из этих служб можно управлять с помощью команд `service`. В текущих системах на основе systemd вы должны использовать `systemctl` для управления службой. 

В прежние времена наличие компьютерных ресурсов было намного меньше. Запускать многие службы в автономном режиме в тандеме было не лучшим вариантом. Вместо этого использовался так называемый супердемон, который прослушивал входящие сетевые соединения и запускал соответствующую службу по запросу. Этот метод построения сетевого подключения занял немного больше времени. Хорошо известными супердемонами являются `inetd` и `xinetd`. В современных системах, основанных на `systemd`, аналогичным образом можно использовать модуль `systemd.socket`. В этом разделе мы будем использовать `xinetd` для перехвата подключений к демону `sshd` и запускать этот демон по запросу, чтобы продемонстрировать, как использовался супердемон. 

Перед настройкой службы `xinetd` необходима некоторая подготовка. Неважно, используете ли вы систему на основе Debian или Red Hat. Хотя эти объяснения были протестированы с Debian/GNU Linux 9.9, они должны работать в любой текущей системе Linux с `systemd` без каких-либо существенных изменений. Сначала убедитесь, что установлены пакеты `openssh-server` и `xinetd`. Теперь убедитесь, что служба SSH работает с:

```console
$ systemctl status sshd
● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled; vendor preset: enabled)
   Active: active (running) since Mon 2020-04-27 09:33:48 EDT; 3h 11min ago
     Docs: man:sshd(8)
           man:sshd_config(5)
  Process: 430 ExecStartPre=/usr/sbin/sshd -t (code=exited, status=0/SUCCESS)
 Main PID: 460 (sshd)
    Tasks: 1 (limit: 1119)
   Memory: 5.3M
   CGroup: /system.slice/ssh.service
           └─460 /usr/sbin/sshd -D
```

Также убедитесь, что служба SSH прослушивает свой стандартный сетевой порт 22:

```console
# lsof -i :22
COMMAND  PID USER   FD   TYPE   DEVICE SIZE/OFF NODE NAME
sshd    1194 root    3u  IPv4 16053268      0t0  TCP *:ssh (LISTEN)
sshd    1194 root    4u  IPv6 16053270      0t0  TCP *:ssh (LISTEN)
```

Наконец остановите службу SSH с помощью:

```console
$ sudo systemctl stop sshd.service
```

В случае, если вы хотите сделать это изменение постоянным и сохраненным после перезагрузки, используйте `systemctl disable sshd.service`. 

Теперь вы можете создать файл конфигурации xinetd `/etc/xinetd.d/ssh` с некоторыми базовыми настройками:

```console
service ssh
{
	disable		= no
	socket_type	= stream
	protocol	= tcp
	wait		= no
	user		= root
	server		= /usr/sbin/sshd
	server_args 	= -i
	flags		= IPv4
	interface	= 192.168.178.1
}
```

Перезапустите службу `xinetd` с помощью:

```console
$ sudo systemctl restart xinetd.service
```

Проверьте, какая служба сейчас прослушивает входящие соединения SSH.

```console
$ sudo lsof -i :22
COMMAND   PID USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME
xinetd  24098 root    5u  IPv4 7345141      0t0  TCP 192.168.178.1:ssh (LISTEN)
```

Мы видим, что служба xinetd взяла на себя управление доступом к порту 22. 

Вот еще несколько подробностей о конфигурации `xinetd`. Основной файл конфигурации - `/etc/xinetd.conf`:

```console
# Simple configuration file for xinetd
#
# Some defaults, and include /etc/xinetd.d/

defaults
{

# Please note that you need a log_type line to be able to use log_on_success
# and log_on_failure. The default is the following :
# log_type = SYSLOG daemon info

}

includedir /etc/xinetd.d
```

Помимо настроек по умолчанию, есть только одна директива для установки каталога включения. В этом каталоге вы можете настроить отдельный файл конфигурации для каждой службы, которую вы хотите обрабатывать с помощью `xinetd`. Мы сделали это выше для службы SSH и назвали файл `/etc/xinetd.d/ssh`. Имена файлов конфигурации могут быть выбраны произвольно, за исключением имен файлов, содержащих точку (`.`) Или оканчивающихся тильдой (`~`). Но широко распространена практика называть файл в честь службы, которую вы хотите настроить. 

Некоторые файлы конфигурации в каталоге `/etc/xinet.d/` уже предоставлены дистрибутивом:

```console
$ ls -l /etc/xinetd.d
total 52
-rw-r--r-- 1 root root 640 Feb  5  2018 chargen
-rw-r--r-- 1 root root 313 Feb  5  2018 chargen-udp
-rw-r--r-- 1 root root 502 Apr 11 10:18 daytime
-rw-r--r-- 1 root root 313 Feb  5  2018 daytime-udp
-rw-r--r-- 1 root root 391 Feb  5  2018 discard
-rw-r--r-- 1 root root 312 Feb  5  2018 discard-udp
-rw-r--r-- 1 root root 422 Feb  5  2018 echo
-rw-r--r-- 1 root root 304 Feb  5  2018 echo-udp
-rw-r--r-- 1 root root 312 Feb  5  2018 servers
-rw-r--r-- 1 root root 314 Feb  5  2018 services
-rw-r--r-- 1 root root 569 Feb  5  2018 time
-rw-r--r-- 1 root root 313 Feb  5  2018 time-udp
```

Эти файлы можно использовать в качестве шаблонов в тех редких случаях, когда вам нужно использовать некоторые устаревшие службы, такие как дневное время, очень ранняя реализация сервера времени. Все эти файлы шаблона содержат директиву `disable = yes`. 

Вот еще несколько подробностей о директивах, используемых в файле примера `/etc/xinetd.d/ssh` для ssh выше.

```console
service ssh
{
	disable		= no
	socket_type	= stream
	protocol	= tcp
	wait		= no
	user		= root
	server		= /usr/sbin/sshd
	server_args 	= -i
	flags		= IPv4
	interface	= 192.168.178.1
}
```

`service`  
Выводит список служб, которыми должен управлять xinetd. Вы можете использовать либо номер порта, например 22, либо имя, сопоставленное с номером порта в `/etc/services`, например `ssh.` 

`{`  
Детальная настройка начинается с открывающей фигурной скобки. 

`disable`  
Чтобы активировать эти настройки, установите для этого параметра значение `no`. Если вы хотите временно отключить эту настройку, вы можете установить для нее значение `yes`. 

`socket_type`  
Вы можете выбрать `stream` для сокетов TCP или `dgram` для сокетов UDP и многое другое. 

`protocol`  
Выберите TCP или UDP. 

`wait`  
Для TCP-соединений обычно установлено значение `no`. 

`user`  
Сервис, запущенный в этой строке, будет принадлежать этому пользователю. 

`server`  
Полный путь к службе, которую должен запустить `xinetd`. 

`server_args`  
Здесь вы можете добавить параметры сервиса. Если запускается суперсервером, для многих сервисов требуется специальная опция. Для SSH это будет опция `-i`. 

`flags`  
Вы можете выбрать IPv4, IPv6 и другие. 

`interface`  
Сетевой интерфейс, которым должен управлять `xinetd`. Примечание: вы также можете выбрать директиву `bind`, которая является синонимом `interface`. 

`}`  
Закончите закрывающей фигурной скобкой. 

Преемниками служб, запускаемых суперсервером `xinetd`, являются модули сокетов systemd. Настроить модуль сокета systemd очень просто и легко, потому что уже есть предопределенный модуль сокета systemd для SSH. Убедитесь, что службы `xinetd` и SSH не запущены. 

Теперь вам просто нужно запустить модуль сокета SSH:

```console
$ sudo systemctl start ssh.socket
```

Чтобы проверить, какая служба сейчас прослушивает порт 22, мы снова используем `lsof`. Обратите внимание, что здесь параметр `-P` использовался для отображения номера порта вместо имени службы в выходных данных:

```console
$ sudo lsof -i :22 -P
COMMAND PID USER   FD   TYPE   DEVICE SIZE/OFF NODE NAME
systemd   1 root   57u  IPv6 14730112      0t0  TCP *:22 (LISTEN)
```

Чтобы завершить этот сеанс, вы должны попытаться войти на свой сервер с помощью клиента SSH по вашему выбору.

>Если `systemctl start ssh.socket` не работает с вашим дистрибутивом, попробуйте `systemctl start sshd.socket`.


## Проверка служб на наличие ненужных демонов

По соображениям безопасности, а также для контроля системных ресурсов важно иметь представление о том, какие службы работают. Ненужные и неиспользуемые сервисы следует отключить. Например, если вам не нужно распространять веб-страницы, нет необходимости запускать веб-сервер, такой как Apache или nginx. 

В системах на основе SyS-V-init вы можете проверить статус всех служб с помощью следующего:

```console
$ sudo service --status-all
```

Убедитесь, что каждая из служб, перечисленных в выводе команды, необходима, и отключите все ненужные службы с помощью (для систем на основе Debian):

```console
$ sudo update-rc.d SERVICE-NAME remove
```

Или в системах на базе Red Hat вы могли бы использовать:

```console
$ sudo chkconfig SERVICE-NAME off
```

В современных системах на основе systemd мы можем использовать следующее, чтобы перечислить все запущенные службы:

```console
$ systemctl list-units --state active --type service
```

Затем вы отключите каждую ненужную служебную единицу с помощью:

```console
$ sudo systemctl disable UNIT --now
```

Эта команда остановит службу и удалит ее из списка служб, чтобы предотвратить ее запуск при следующей загрузке системы. 

Кроме того, чтобы получить обзор прослушивающих сетевых служб, вы можете использовать `netstat` в более старых системах (при условии, что у вас установлен пакет `net-tools`):

```console
$ netstat -ltu
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State
tcp        0      0 0.0.0.0:ssh             0.0.0.0:*               LISTEN
tcp        0      0 localhost:mysql         0.0.0.0:*               LISTEN
tcp6       0      0 [::]:http               [::]:*                  LISTEN
tcp6       0      0 [::]:ssh                [::]:*                  LISTEN
udp        0      0 0.0.0.0:bootpc          0.0.0.0:*
```

Или в современных системах вы можете использовать эквивалентную команду `ss` (для «служб сокетов»):

```console
$ ss -ltu
Netid      State         Recv-Q        Send-Q      Local Address:Port           Peer Address:Port
udp        UNCONN        0             0                 0.0.0.0:bootpc              0.0.0.0:*
tcp        LISTEN        0             128               0.0.0.0:ssh                 0.0.0.0:*
tcp        LISTEN        0             80              127.0.0.1:mysql               0.0.0.0:*
tcp        LISTEN        0             128                     *:http                      *:*
tcp        LISTEN        0             128                  [::]:ssh                    [::]:*
```


## TCP-оболочки как своего рода простой брандмауэр

Во времена, когда для Linux не было доступных брандмауэров, для защиты сетевых подключений к хосту использовались TCP-оболочки. В настоящее время многие программы больше не подчиняются оболочкам TCP. В последних дистрибутивах, основанных на Red Hat (например, Fedora 29), поддержка оберток TCP была полностью удалена. Для поддержки устаревших систем Linux, которые все еще используют оболочки TCP, полезно иметь некоторые базовые знания об этой конкретной технологии. 

Мы еще раз будем использовать службу SSH в качестве базового примера. Служба на нашем примере хоста должна быть доступна только из локальной сети. Сначала мы проверяем, использует ли демон SSH библиотеку `libwrap`, которая предлагает поддержку TCP-оболочек:

```console
$ ldd /usr/sbin/sshd | grep "libwrap"
        libwrap.so.0 => /lib/x86_64-linux-gnu/libwrap.so.0 (0x00007f91dbec0000)
```

Теперь добавляем в файл `/etc/hosts.deny` следующую строку:

```console
sshd: ALL
```

Наконец, мы настраиваем исключение в файле `/etc/hosts.allow` для SSH-соединений из локальной сети:

```console
sshd: LOCAL
```

Изменения вступают в силу немедленно, перезапускать какую-либо службу не требуется. Вы можете проверить это с помощью клиента `ssh`.


## Упражнения для закрепления

1. Как можно разблокировать ранее заблокированную учетную запись `emma`? 
2. Ранее для учетной записи `emma` была установлена дата истечения срока действия. Как можно установить срок годности никогда? 
3. Представьте, что служба печати CUPS, обрабатывающая задания на печать, не нужна на вашем сервере. Как можно отключить услугу навсегда? Как вы можете проверить, что соответствующий порт больше не активен? 
4. Вы установили веб-сервер nginx. Как вы можете проверить, поддерживает ли nginx TCP-оболочки?


## Упражнения на размышление

1. Проверить, предотвращает ли существование файла `/etc/nologin` вход пользователя root? 
2. Предотвращает ли существование файла `/etc/nologin` вход без пароля с ключами SSH? 
3. Что происходит при входе в систему, когда файл `/etc/nologin` содержит эту строку текста, в настоящее время только вход в систему невозможен? 
4. Может ли обычный пользователь `emma` получить информацию о корневом каталоге пользователя, содержащемся в файле `/etc/passwd`, например: командой `grep root /etc/passwd`? 
5. Может ли обычный пользователь `emma` получить информацию о своем собственном хешированном пароле, содержащемся в файле `/etc/shadow`, например командой `grep emma /etc/shadow`? 
6. Какие шаги необходимо предпринять, чтобы включить и проверить древнюю дневную службу, которую должен обрабатывать `xinetd`? Обратите внимание, что это всего лишь экспериментальное упражнение, не делайте этого в производственной среде.


## Резюме

Из этого урока вы узнали: 
1. В каком файле хранятся пароли, а также некоторые настройки безопасности паролей, например время окончания срока действия. 
2. Назначение superdaemon `xinetd` и способы его запуска и запуска службы `sshd` по запросу. 
3. Чтобы проверить, какие сетевые службы работают и как отключить ненужные службы. 
4. Используйте TCP-оболочки как своего рода простой брандмауэр. 

Команды, используемые в лаборатории и упражнениях:  

`chage`  
Измените возраст пароля пользователя. 

`chkconfig`  
Классическая команда, изначально использовавшаяся в системах на базе Red Hat, чтобы установить, будет ли служба запускаться во время загрузки или нет. 

`netstat`  
Классическая утилита (теперь в пакете `net-tools`), которая отображает демонов, обращающихся к сетевым портам в системе, и их использование. 

`nologin`  
Команда, которую можно использовать вместо оболочки пользователя, чтобы предотвратить вход в систему. 

`password`  
Используется для создания или изменения пароля пользователя. 

`service`  
Старый метод управления статусом демона, например остановка или запуск службы. 

`SS`  
Современный эквивалент `netstat`, но также отображает дополнительную информацию о различных сокетах, используемых в системе. 

`systemctl`  
Команда управления системой, используемая для управления различными аспектами служб и сокетов на компьютере с помощью `systemd`. 

`update-rc.d`  
Классическая команда, похожая на `chkconfig`, которая включает или отключает запуск системы во время загрузки в дистрибутивах на основе Debian. 

`xinetd`  
Супердемон, который может контролировать доступ к сетевой службе по запросу, оставляя службу неактивной до тех пор, пока она не будет вызвана для выполнения некоторой задачи.


## Ответы на упражнения для закрепления

**1. Как можно разблокировать ранее заблокированную учетную запись `emma`?**  
Суперпользователь может запустить команду `passwd -u emma`, чтобы разблокировать учетную запись.

**2. Ранее для учетной записи `emma` была установлена дата истечения срока действия. Как можно установить срок годности `never`?**  
Суперпользователь может использовать `chage -E -1 emma`, чтобы установить срок годности никогда. Этот параметр можно проверить с помощью `chage -l emma`.

**3. Представьте, что служба печати CUPS, обрабатывающая задания на печать, не нужна на вашем сервере. Как можно отключить услугу навсегда? Как вы можете проверить, что соответствующий порт больше не активен?**  
```console
systemctl disable cups.service --now
```
Теперь вы можете проверить
```console
netstat -l | grep ":ipp "` or `ss -l | grep ":ipp "
```

**4. Вы установили веб-сервер nginx. Как вы можете проверить, поддерживает ли nginx TCP-оболочки?**  
```console
ldd /usr/sbin/nginx | grep "libwrap"
```
покажет запись, если nginx поддерживает TCP-оболочки.


## Ответы на упражнения для размышления

**1. Проверить, предотвращает ли существование файла `/etc/nologin` вход пользователя root?**  
Пользователь `root` по-прежнему может войти в систему.

**2. Предотвращает ли существование файла `/etc/nologin` вход без пароля с ключами SSH?**  
Да, также запрещены входы в систему без пароля.

**3. Что происходит при входе в систему, когда файл `/etc/nologin` содержит эту строку текста, `login currently is not possible only`?**  
Будет показано сообщение, в настоящее время вход в систему невозможен, и вход в систему запрещен.

**4. Может ли обычный пользователь `emma` получить информацию о корневом каталоге пользователя, содержащемся в файле `/etc/passwd`, например: командой `grep root /etc/passwd`?**  
Да, потому что все пользователи имеют разрешение на чтение этого файла.

**5. Может ли обычный пользователь `emma` получить информацию о своем собственном хешированном пароле, содержащемся в файле `/etc/shadow`, например командой `grep emma /etc/shadow`?**  
Нет, потому что у обычных пользователей нет прав на чтение этого файла.


**6. Какие шаги необходимо предпринять, чтобы включить и проверить древнюю дневную службу, которую должен обрабатывать `xinetd`? Обратите внимание, что это всего лишь экспериментальное упражнение, не делайте этого в производственной среде.**  
Сначала измените файл `/etc/xinetd.d/daytime` и установите директиву `disable = no`. Во-вторых, перезапустите службу `xinetd systemctl restart xinetd.service` (или `service xinetd restart` в системах с SyS-V-Init). Теперь вы можете проверить, работает ли `nc localhost daytime`. Вместо `nc` вы также можете использовать `ncat`.
