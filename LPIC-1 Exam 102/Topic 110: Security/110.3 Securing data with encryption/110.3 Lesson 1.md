# 110.3 Урок 1

| **Сертификат:** | LPIC-1                                      |
|:----------------|:--------------------------------------------|
| **Версия:**     | 5.0                                         |
| **Тема:**       | 110 Безопасность                            |                           
| **Цель:**       | 110.3 Защита данных с помощью шифрования    |
| **Урок:**       | 1 из 2                                      |


## Введение

Защита данных с помощью шифрования имеет первостепенное значение во многих аспектах современного системного администрирования, особенно когда речь идет об удаленном доступе к системам. В отличие от небезопасных решений, таких как *telnet*, *rlogin* или *FTP*, протокол *SSH(Secure Shell)* был разработан с учетом требований безопасности. Используя криптографию с открытым ключом, он аутентифицирует как хосты, так и пользователей и шифрует весь последующий обмен информацией. Кроме того, SSH может использоваться для создания туннелей портов, что, помимо прочего, позволяет незашифрованному протоколу передавать данные через зашифрованное соединение SSH. Текущая рекомендуемая версия протокола SSH - 2.0. *OpenSSH* - это бесплатная реализация протокола SSH с открытым исходным кодом. 

Этот урок будет охватывать базовую конфигурацию клиента *OpenSSH*, а также роль ключей хоста сервера *OpenSSH*. Также будет обсуждаться концепция туннелей портов SSH. Мы будем использовать две машины со следующей настройкой:

| Роль машины | ОС         | IP-адрес        | Имя хоста      | Пользователь       |
|:------------|:-----------|:----------------|:---------------|:-------------------|
| Клиент      | Debian GNU/Linux 10 (buster) | `192.168.1.55` | `debian` | `carol` |
| Сервер      | openSUSE Leap 15.1           | `192.168.1.77` | `halof`  |   `ina` |                          


## Базовая настройка и использование клиента OpenSSH

Хотя сервер и клиент OpenSSH входят в отдельные пакеты, обычно вы можете установить метапакет, который предоставит оба сразу. Чтобы установить удаленный сеанс с SSH-сервером, вы используете команду `ssh`, указав пользователя, к которому вы хотите подключиться, как на удаленном компьютере, и IP-адрес или имя хоста удаленного компьютера. При первом подключении к удаленному хосту вы получите такое сообщение:

```console
carol@debian:~$ ssh ina@192.168.1.77
The authenticity of host '192.168.1.77 (192.168.1.77)' can't be established.
ECDSA key fingerprint is SHA256:5JF7anupYipByCQm2BPvDHRVFJJixeslmppi2NwATYI.
Are you sure you want to continue connecting (yes/no)?
```

После ввода `yes` и нажатия клавиши «Ввод» вам будет предложено ввести пароль удаленного пользователя. В случае успешного ввода вам будет показано предупреждающее сообщение, а затем вы войдете на удаленный хост:

```console
Warning: Permanently added '192.168.1.77' (ECDSA) to the list of known hosts.
Password:
Last login: Sat Jun 20 10:52:45 2020 from 192.168.1.4
Have a lot of fun...
ina@halof:~>
```

Сообщения говорят сами за себя: поскольку это был первый раз, когда вы установили соединение с удаленным сервером `192.168.1.77`, его подлинность не могла быть проверена по какой-либо базе данных. Таким образом, удаленный сервер предоставил `ECDSA key fingerprint` (используя хэш-функцию `SHA256`). После того, как вы приняли соединение, открытый ключ удаленного сервера был добавлен в базу данных *известных хостов*, что позволило аутентифицировать сервер для будущих подключений. Этот список открытых ключей *известных хостов* хранится в файле `known_hosts`, который находится в `~/.ssh`:

```console
ina@halof:~> exit
logout
Connection to 192.168.1.77 closed.
carol@debian:~$ ls .ssh/
known_hosts
```

И `.ssh`, и `known_hosts` были созданы после установки первого удаленного подключения. `~/.ssh` - это каталог по умолчанию для пользовательской конфигурации и информации аутентификации.

>Вы также можете использовать `ssh`, чтобы просто выполнить одну команду на удаленном хосте, а затем вернуться на свой локальный терминал (например, запустить `ssh ina@halof ls`).

Если вы используете одного и того же пользователя на локальном и удаленном хостах, нет необходимости указывать имя пользователя при установке SSH-соединения. Например, если вы вошли в систему как пользователь `carol` в `debian` и хотите подключиться к `halof` также как пользователь `carol`, вы должны просто ввести `ssh 192.168.1.77` или `ssh halof` (если имя может быть разименовано):

```console
carol@debian:~$ ssh halof
Password:
Last login: Wed Jul  1 23:45:02 2020 from 192.168.1.55
Have a lot of fun...
carol@halof:~>
```

Теперь предположим, что вы устанавливаете новое удаленное соединение с хостом, который имеет тот же IP-адрес, что и `halof` (обычное дело, если вы используете DHCP в своей локальной сети). Вы будете предупреждены о возможности атаки *злоумышленник посередине*:

```console
carol@debian:~$ ssh john@192.168.1.77
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the ECDSA key sent by the remote host is
SHA256:KH4q3vP6C7e0SEjyG8Wlz9fVlf+jmWJ5139RBxBh3TY.
Please contact your system administrator.
Add correct host key in /home/carol/.ssh/known_hosts to get rid of this message.
Offending ECDSA key in /home/carol/.ssh/known_hosts:1
  remove with:
  ssh-keygen -f "/home/carol/.ssh/known_hosts" -R "192.168.1.77"
ECDSA host key for 192.168.1.77 has changed and you have requested strict checking.
Host key verification failed.
```

Поскольку вы не имеете дело с атакой *злоумышленник в середине*, вы можете безопасно добавить отпечаток открытого ключа нового хоста в `.ssh/known_hosts`. Как указано в сообщении, вы можете сначала использовать команду `ssh-keygen -f "/home/carol/.ssh/known_hosts" -R "192.168.1.77"`, чтобы удалить *неправильный* ключ (в качестве альтернативы вы можете использовать s`sh-keygen - R 192.168.1.77`, чтобы удалить все ключи, принадлежащие `192.168.1.77` из `~/.ssh/known_hosts`). После этого вы сможете установить соединение с новым хостом.


## Логины на основе ключей

Вы можете настроить свой SSH-клиент так, чтобы при входе в систему не предоставлялись пароли, а вместо этого использовались открытые ключи. Это предпочтительный метод подключения к удаленному серверу через SSH, поскольку он намного безопаснее. Первое, что вам нужно сделать, это создать пару ключей на клиентской машине. Для этого вы будете использовать `ssh-keygen` с параметром `-t`, указывающим тип шифрования, который вы хотите (в нашем случае - *алгоритм цифровой подписи с эллиптической кривой*). Затем вас попросят указать путь для сохранения пары ключей (`~/.ssh/` удобно, а также местоположение по умолчанию) и кодовую фразу. Хотя кодовая фраза не является обязательной, настоятельно рекомендуется ее всегда использовать.

```console
carol@debian:~/.ssh$ ssh-keygen -t ecdsa
Generating public/private ecdsa key pair.
Enter file in which to save the key (/home/carol/.ssh/id_ecdsa):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/carol/.ssh/id_ecdsa.
Your public key has been saved in /home/carol/.ssh/id_ecdsa.pub.
The key fingerprint is:
SHA256:tlamD0SaTquPZYdNepwj8XN4xvqmHCbe8g5FKKUfMo8 carol@debian
The key's randomart image is:
+---[ECDSA 256]---+
|      .          |
|     o .         |
|    = o o        |
|     B *         |
|    E B S o      |
|     o & O       |
|      @ ^ =      |
|     *.@ @.      |
|    o.o+B+o      |
+----[SHA256]-----+
```

>При создании пары ключей вы можете передать `ssh-keygen` параметр `-b`, чтобы указать размер ключа в битах (например: `ssh-keygen -t ecdsa -b 521`).

Предыдущая команда создала еще два файла в вашем каталоге `~/.ssh`:

```console
carol@debian:~/.ssh$ ls
id_ecdsa  id_ecdsa.pub  known_hosts
```

`id_ecdsa`  
Это ваш закрытый ключ. 

`id_ecdsa.pub`  
Это ваш открытый ключ.

>В асимметричной криптографии (также известной как криптография с открытым ключом) открытый и закрытый ключи математически связаны друг с другом таким образом, что все, что зашифровано одним, может быть дешифровано только другим.

Следующее, что вам нужно сделать, это добавить свой открытый ключ в файл `~/.ssh/authorized_keys` пользователя, которому вы хотите войти как на удаленном хосте (если каталог `~/.ssh` еще не существует, у вас будет чтобы создать его первым). Вы можете скопировать свой открытый ключ на удаленный сервер несколькими способами: с помощью USB-накопителя, с помощью команды `scp`, которая передаст файл через SSH, или путем *выделения содержимого* вашего открытого ключа и передачи его в `ssh` вот так:

```console
carol@debian:~/.ssh$ cat id_ecdsa.pub |ssh ina@192.168.1.77 'cat >> .ssh/authorized_keys'
Password:
```

После того, как ваш открытый ключ был добавлен в файл `authorized_keys` на удаленном хосте, вы можете столкнуться с двумя сценариями при попытке установить новое соединение:

* Если вы не указали кодовую фразу при создании пары ключей, вы войдете в систему автоматически. Хотя этот метод удобен, он может быть небезопасным в зависимости от ситуации:
```console
carol@debian:~$ ssh ina@192.168.1.77
Last login: Thu Jun 25 20:31:03 2020 from 192.168.1.55
Have a lot of fun...
ina@halof:~>
```

* Если вы указали парольную фразу при создании пары ключей, вам придется вводить ее при каждом подключении почти так же, как если бы это был пароль. Помимо открытого ключа, этот метод добавляет дополнительный уровень безопасности в виде парольной фразы и поэтому может считаться более безопасным. Однако, что касается удобства, это то же самое, что вводить пароль каждый раз, когда вы устанавливаете соединение. Если вы не используете парольную фразу и кому-то удастся получить ваш закрытый файл ключа SSH, у них будет доступ ко всем серверам, на которых установлен ваш открытый ключ.
```console
carol@debian:~/.ssh$ ssh ina@192.168.1.77
Enter passphrase for key '/home/carol/.ssh/id_ecdsa':
Last login: Thu Jun 25 20:39:30 2020 from 192.168.1.55
Have a lot of fun...
ina@halof:~>
```

Однако есть способ, сочетающий безопасность и удобство: использование *агента аутентификации SSH* (`ssh-agent`). Агент аутентификации должен создать свою собственную оболочку и будет хранить ваши личные ключи - для аутентификации с открытым ключом - в памяти до конца сеанса. Давайте посмотрим, как это работает, более подробно: 1. Используйте `ssh-agent`, чтобы запустить новую оболочку Bash:
```console
carol@debian:~/.ssh$ ssh-agent /bin/bash
carol@debian:~/.ssh$
```
2. Используйте команду `ssh-add`, чтобы добавить свой закрытый ключ в безопасную область памяти. Если вы указали парольную фразу при генерации пары ключей - что рекомендуется для дополнительной безопасности - вам будет предложено ввести ее:
```console
carol@debian:~/.ssh$ ssh-add
Enter passphrase for /home/carol/.ssh/id_ecdsa:
Identity added: /home/carol/.ssh/id_ecdsa (carol@debian)
```  
После того, как ваша личность была добавлена, вы можете войти на любой удаленный сервер, на котором присутствует ваш открытый ключ, без повторного ввода ключевой фразы. На современных настольных компьютерах распространена практика выполнения этой команды при загрузке компьютера, так как она остается в памяти до выключения компьютера (или до тех пор, пока ключ не будет выгружен вручную).

Давайте завершим этот раздел перечислением четырех типов алгоритмов открытого ключа, которые можно указать с помощью `ssh-keygen`: 
`RSA`  
Названный в честь создателей Рона Ривеста, Ади Шамира и Леонарда Адлемана, он был опубликован в 1977 году. Он считается безопасным и широко используется до сих пор. Его минимальный размер ключа составляет 1024 бита (по умолчанию 2048). 

`DSA`  
*Алгоритм цифровой подписи* оказался небезопасным, и в OpenSSH 7.0 он устарел. Ключи DSA должны иметь длину не более 1024 битов. 

`ecdsa`  
*Алгоритм цифровой подписи с эллиптической кривой* является усовершенствованием DSA и, следовательно, считается более безопасным. Он использует криптографию на основе эллиптических кривых. Длина ключа ECDSA определяется одним из трех возможных размеров эллиптической кривой в битах: 256, 384 или 521. 

`ed25519`  
Это реализация `EdDSA` - *алгоритма цифровой подписи на основе кривой Эдвардса* - который использует более сильную кривую 25519. Считается самым безопасным из всех. Все ключи Ed25519 имеют фиксированную длину 256 бит.

>Если вызывается без указания `-t`, `ssh-keygen` по умолчанию сгенерирует пару ключей `RSA`


## Роль ключей хоста сервера OpenSSH

Каталог глобальной конфигурации для OpenSSH находится в каталоге `/etc`:

```console
halof:~ # tree /etc/ssh
/etc/ssh
├── moduli
├── ssh_config
├── ssh_host_dsa_key
├── ssh_host_dsa_key.pub
├── ssh_host_ecdsa_key
├── ssh_host_ecdsa_key.pub
├── ssh_host_ed25519_key
├── ssh_host_ed25519_key.pub
├── ssh_host_rsa_key
├── ssh_host_rsa_key.pub
└── sshd_config

0 directories, 11 files
```

Помимо модулей и файлов конфигурации для клиента (`ssh_config`) и сервера (`sshd_config`), вы найдете четыре пары ключей - пару ключей для каждого поддерживаемого алгоритма, - которые создаются при установке сервера OpenSSH. Как уже отмечалось, сервер использует эти ключи хоста, чтобы при необходимости идентифицировать себя для клиентов. Их название выглядит следующим образом:

Приватные ключи  
префикс `ssh_host_` + *алгоритм* + `key ` суффикс (например: `ssh_host_rsa_key`) 

Открытые ключи (или отпечатки открытых ключей)  
префикс `ssh_host_` + *алгоритм* + `key.pub` суффикс (например: `ssh_host_rsa_key.pub`)

>Отпечаток пальца создается путем применения криптографической хеш-функции к открытому ключу. Поскольку отпечатки пальцев короче ключей, к которым они относятся, они пригодятся для упрощения определенных задач управления ключами.

Права на файлы, содержащие закрытые ключи: `0600` или `-rw-------`: только для чтения и записи владельцем (`root`). С другой стороны, все файлы открытых ключей также доступны для чтения членам группы владельцев и всем остальным (`0644` или `-rw-r--r--`):

```console
halof:~ # ls -l /etc/ssh/ssh_host_*
-rw------- 1 root root 1381 Dec 21 20:35 /etc/ssh/ssh_host_dsa_key
-rw-r--r-- 1 root root  605 Dec 21 20:35 /etc/ssh/ssh_host_dsa_key.pub
-rw------- 1 root root  505 Dec 21 20:35 /etc/ssh/ssh_host_ecdsa_key
-rw-r--r-- 1 root root  177 Dec 21 20:35 /etc/ssh/ssh_host_ecdsa_key.pub
-rw------- 1 root root  411 Dec 21 20:35 /etc/ssh/ssh_host_ed25519_key
-rw-r--r-- 1 root root   97 Dec 21 20:35 /etc/ssh/ssh_host_ed25519_key.pub
-rw------- 1 root root 1823 Dec 21 20:35 /etc/ssh/ssh_host_rsa_key
-rw-r--r-- 1 root root  397 Dec 21 20:35 /etc/ssh/ssh_host_rsa_key.pub
```

Вы можете просмотреть отпечатки ключей, передав `ssh-keygen` ключ `-l`. Вы также должны указать `-f`, чтобы указать путь к ключевому файлу:

```console
halof:~ # ssh-keygen -l -f /etc/ssh/ssh_host_ed25519_key
256 SHA256:8cnPrinC49ZHc+/9Ai5pV+1JfZ4WBRZhd3rDOsc2zlA root@halof (ED25519)
halof:~ # ssh-keygen -l -f /etc/ssh/ssh_host_ed25519_key.pub
256 SHA256:8cnPrinC49ZHc+/9Ai5pV+1JfZ4WBRZhd3rDOsc2zlA root@halof (ED25519)
```

Чтобы просмотреть отпечаток ключа, а также его случайное изображение, просто добавьте переключатель `-v` следующим образом:

```console
halof:~ # ssh-keygen -lv -f /etc/ssh/ssh_host_ed25519_key.pub
256 SHA256:8cnPrinC49ZHc+/9Ai5pV+1JfZ4WBRZhd3rDOsc2zlA root@halof (ED25519)
+--[ED25519 256]--+
|              +oo|
|             .+o.|
|        .    ..E.|
|         + .  +.o|
|        S +  + *o|
|          ooo Oo=|
|     . . . =o+.==|
|      = o =oo o=o|
|     o.o +o+..o.+|
+----[SHA256]-----+
```


## Туннели портов SSH

OpenSSH имеет очень мощное средство пересылки, с помощью которого трафик на исходном порте туннелируется и шифруется через процесс SSH, который затем перенаправляет его на порт на целевом хосте. Этот механизм известен как туннелирование портов или перенаправление портов и имеет следующие важные преимущества: 
* Он позволяет обходить брандмауэры для доступа к портам на удаленных хостах. 
* Это позволяет получить доступ извне к хосту в вашей частной сети. 
* Он обеспечивает шифрование для всего обмена данными. 

Грубо говоря, мы можем различать локальное и удаленное туннелирование портов.


## Туннель местного порта

Вы определяете порт локально для перенаправления трафика на целевой хост через процесс SSH, который находится между ними. Процесс SSH может выполняться на локальном хосте или на удаленном сервере. Например, если по какой-то причине вы хотите туннелировать соединение с `www.gnu.org` через SSH, используя порт `8585` на вашем локальном компьютере, вы должны сделать что-то вроде этого:

```console
carol@debian:~$ ssh -L 8585:www.gnu.org:80 debian
carol@debian's password:
Linux debian 4.19.0-9-amd64 #1 SMP Debian 4.19.118-2 (2020-04-29) x86_64

The programs included with the Debian GNU/Linux system are free software;
(...)
Last login: Sun Jun 28 13:47:27 2020 from 127.0.0.1
```

Объяснение таково: с помощью параметра `-L` мы указываем локальный порт `8585` для подключения к *http*-порту `80` на `www.gnu.org` с помощью процесса SSH, запущенного на `debian` - нашем *локальном хосте*. Мы могли бы написать `ssh -L 8585: www.gnu.org: 80 localhost` с тем же эффектом. Если вы теперь используете веб-браузер для перехода на `http://localhost:8585`, вы будете перенаправлены на `www.gnu.org`. В демонстрационных целях мы будем использовать `lynx` (классический текстовый браузер):

```console
carol@debian:~$ lynx http://localhost:8585
(...)
  * Back to Savannah Homepage
     * Not Logged in
     * Login
     * New User
     * This Page
     * Language
     * Clean Reload
     * Printer Version
     * Search
     * _
(...)
```

Если бы вы хотели сделать то же самое, но подключиться через процесс SSH, запущенный на `halof`, вы бы поступили так:

```console
carol@debian:~$ ssh -L 8585:www.gnu.org:80 -Nf ina@192.168.1.77
Enter passphrase for key '/home/carol/.ssh/id_ecdsa':
carol@debian:~$
carol@debian:~$ lynx http://localhost:8585
(...)
  * Back to Savannah Homepage
     * Not Logged in
     * Login
     * New User
     * This Page
     * Language
     * Clean Reload
     * Printer Version
     * Search
     * _
(...)
```

Важно отметить в команде три детали: 
* Благодаря опции `-N` мы не входили в `halof`, а вместо этого выполняли переадресацию портов. 
* Параметр `-f` указывает SSH работать в фоновом режиме. 
* Мы указали пользователя `ina` для пересылки: `ina@192.168.1.77`


## Туннель удаленного порта

При туннелировании удаленных портов (или обратном перенаправлении портов) трафик, поступающий на порт на удаленном сервере, перенаправляется процессу SSH, запущенному на вашем локальном хосте, а оттуда - на указанный порт на целевом сервере (который также может быть вашей локальной машиной). Например, предположим, что вы хотите разрешить кому-либо извне вашей сети доступ к веб-серверу Apache, работающему на вашем локальном хосте, через порт `8585` сервера SSH, работающего на `halof` (`192.168.1.77`). Вы должны выполнить следующую команду:

```console
carol@debian:~$ ssh -R 8585:localhost:80 -Nf ina@192.168.1.77
Enter passphrase for key '/home/carol/.ssh/id_ecdsa':
carol@debian:~$
```

Теперь любой, кто устанавливает соединение с `halof` через порт `8585`, увидит домашнюю страницу Debian Apache2 по умолчанию:

```console
carol@debian:~$ lynx 192.168.1.77:8585
(...)
                                                                 Apache2 Debian Default Page: It works (p1 of 3)
   Debian Logo Apache2 Debian Default Page
   It works!

   This is the default welcome page used to test the correct operation of the Apache2 server after
   installation on Debian systems. If you can read this page, it means that the Apache HTTP server
   installed at this site is working properly. You should replace this file (located at
   /var/www/html/index.html) before continuing to operate your HTTP server.
(...)
```

>Существует третий, более сложный тип перенаправления портов, который выходит за рамки этого урока: динамическое перенаправление портов. Вместо взаимодействия с одним портом этот тип пересылки использует различные TCP-соединения через диапазон портов.


## Туннели X11

Теперь, когда вы разбираетесь в туннелях портов, давайте завершим этот урок обсуждением туннелирования X11 (также известного как *X11forwarding*). Через туннель X11 *система X Window* на удаленном хосте перенаправляется на ваш локальный компьютер. Для этого вам просто нужно передать `ssh` параметр `-X`:

```console
carol@debian:~$ ssh -X ina@halof
...
```

Теперь вы можете запустить графическое приложение, такое как веб-браузер `firefox`, со следующим результатом: приложение будет запущено на удаленном сервере, но его отображение будет перенаправлено на ваш локальный хост. 

Если вместо этого вы начнете новый сеанс SSH с параметром `-x`, `X11forwarding` будет отключено. Попробуйте запустить `firefox` сейчас, и вы получите следующее сообщение об ошибке:

```console
carol@debian:~$ ssh -x ina@halof
carol@192.168.0.106's password:
(...)
ina@halof:~$ firefox

(firefox-esr:1779): Gtk-WARNING **: 18:45:45.603: Locale not supported by C library.
	Using the fallback 'C' locale.
Error: no DISPLAY environment variable specified
```

>Три директивы конфигурации, относящиеся к перенаправлению локального порта, перенаправлению удаленного порта и перенаправлению X11, - это `AllowTcpForwarding`, `GatewayPorts` и `X11Forwarding` соответственно. Для получения дополнительной информации введите `man ssh_config` и/или `man sshd_config`.


## Упражнения для закрепления

1. Войдите в систему как пользователь `sonya` на своем клиентском компьютере и выполните следующие задачи SSH на удаленном сервере `halof`: 
* Выполните команду для вывода списка содержимого `~/.ssh` от имени пользователя `serena` на удаленном хосте; затем вернитесь к своему местному терминалу. 
* Войдите в систему как пользователь `serena` на удаленном хосте. 
* Войдите в систему как пользователь `sonya` на удаленном хосте. 
* Удалите все ключи, принадлежащие `halof`, из вашего локального файла `~/.ssh/known_hosts`. 
* На вашем клиентском компьютере создайте пару ключей `ecdsa` из 256 бит. 
* На клиентском компьютере создайте пару ключей `ed25519` из 256 бит. 
 
2. Выполните следующие шаги в правильном порядке, чтобы установить SSH-соединение с помощью агента аутентификации SSH: 
* На клиенте запустите новую оболочку Bash для агента аутентификации с помощью `ssh-agent /bin/bash`. 
* На клиенте создайте пару ключей с помощью `ssh-keygen`. 
* На клиенте добавьте свой закрытый ключ в безопасную область памяти с помощью `ssh-add`. 
* Добавьте открытый ключ своего клиента в файл `~/.ssh/authorized_keys` пользователя, под которым вы хотите войти, на удаленном хосте. 
* Если он еще не существует, создайте `~/.ssh` для пользователя, которому вы хотите войти в систему как на сервере. 
* Подключитесь к удаленному серверу.  
Правильный порядок:  
| Шаг 1: |  | 
|:-------|:-|
| Шаг 2: |  | 
| Шаг 3: |  |
| Шаг 4: |  |
| Шаг 5: |  | 
| Шаг 6: |  |

3. Что касается *переадресации портов*, какая опция и директива используются для следующих типов туннелей:  
| Тип туннеля | Параметр | Директива |
|:------------|:---------|:----------|
| Местный     |          |           | 
| Удаленный или обратный ||          | 
| X           |          |           | 

4. Предположим, вы набираете команду `ssh -L 8888: localhost: 80 -Nf ina@halof` в терминал вашего клиентского компьютера. По-прежнему на клиентской машине вы указываете браузеру `http://localhost:8888`. Что вы получите?


## Упражнения на размышление

1. Относительно директив безопасности SSH: 
* Какая директива используется в `/etc/ssh/sshd_config` для включения входа в систему `root`: 
* Какую директиву вы бы использовали в `/etc/ssh/sshd_config`, чтобы указать только локальную учетную запись для приема SSH-соединений: 

2. При использовании одного и того же пользователя как на клиенте, так и на сервере, какую команду `ssh` вы можете использовать для передачи открытого ключа клиента на сервер, чтобы вы могли войти в систему с помощью аутентификации с открытым ключом? 

3. Создайте два туннеля локальных портов с помощью одной команды, перенаправляя локальные непривилегированные порты `8080` и `8585` через `halof` удаленного сервера на веб-сайты `www.gnu.org` и `www.melpa.org` соответственно. Используйте пользователя `ina` на удаленном сервере и не забудьте использовать ключи `-Nf`:


## Резюме




## Ответы на упражнения для закрепления


## Ответы на упражнения для размышления
