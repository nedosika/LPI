# 110.3 Урок 1

| **Сертификат:** | LPIC-1                                      |
|:----------------|:--------------------------------------------|
| **Версия:**     | 5.0                                         |
| **Тема:**       | 110 Безопасность                            |                           
| **Цель:**       | 110.3 Защита данных с помощью шифрования    |
| **Урок:**       | 1 из 2                                      |


## Введение

Защита данных с помощью шифрования имеет первостепенное значение во многих аспектах современного системного администрирования, особенно когда речь идет об удаленном доступе к системам. В отличие от небезопасных решений, таких как *telnet*, *rlogin* или *FTP*, протокол *SSH(Secure Shell)* был разработан с учетом требований безопасности. Используя криптографию с открытым ключом, он аутентифицирует как хосты, так и пользователей и шифрует весь последующий обмен информацией. Кроме того, SSH может использоваться для создания туннелей портов, что, помимо прочего, позволяет незашифрованному протоколу передавать данные через зашифрованное соединение SSH. Текущая рекомендуемая версия протокола SSH - 2.0. *OpenSSH* - это бесплатная реализация протокола SSH с открытым исходным кодом. 

Этот урок будет охватывать базовую конфигурацию клиента *OpenSSH*, а также роль ключей хоста сервера *OpenSSH*. Также будет обсуждаться концепция туннелей портов SSH. Мы будем использовать две машины со следующей настройкой:

| Роль машины | ОС         | IP-адрес        | Имя хоста      | Пользователь       |
|:------------|:-----------|:----------------|:---------------|:-------------------|
| Клиент      | Debian GNU/Linux 10 (buster) | `192.168.1.55` | `debian` | `carol` |
| Сервер      | openSUSE Leap 15.1           | `192.168.1.77` | `halof`  |   `ina` |                          


## Базовая настройка и использование клиента OpenSSH

Хотя сервер и клиент OpenSSH входят в отдельные пакеты, обычно вы можете установить метапакет, который предоставит оба сразу. Чтобы установить удаленный сеанс с SSH-сервером, вы используете команду `ssh`, указав пользователя, к которому вы хотите подключиться, как на удаленном компьютере, и IP-адрес или имя хоста удаленного компьютера. При первом подключении к удаленному хосту вы получите такое сообщение:

```console
carol@debian:~$ ssh ina@192.168.1.77
The authenticity of host '192.168.1.77 (192.168.1.77)' can't be established.
ECDSA key fingerprint is SHA256:5JF7anupYipByCQm2BPvDHRVFJJixeslmppi2NwATYI.
Are you sure you want to continue connecting (yes/no)?
```

После ввода `yes` и нажатия клавиши «Ввод» вам будет предложено ввести пароль удаленного пользователя. В случае успешного ввода вам будет показано предупреждающее сообщение, а затем вы войдете на удаленный хост:

```console
Warning: Permanently added '192.168.1.77' (ECDSA) to the list of known hosts.
Password:
Last login: Sat Jun 20 10:52:45 2020 from 192.168.1.4
Have a lot of fun...
ina@halof:~>
```

Сообщения говорят сами за себя: поскольку это был первый раз, когда вы установили соединение с удаленным сервером `192.168.1.77`, его подлинность не могла быть проверена по какой-либо базе данных. Таким образом, удаленный сервер предоставил `ECDSA key fingerprint` (используя хэш-функцию `SHA256`). После того, как вы приняли соединение, открытый ключ удаленного сервера был добавлен в базу данных *известных хостов*, что позволило аутентифицировать сервер для будущих подключений. Этот список открытых ключей *известных хостов* хранится в файле `known_hosts`, который находится в `~/.ssh`:

```console
ina@halof:~> exit
logout
Connection to 192.168.1.77 closed.
carol@debian:~$ ls .ssh/
known_hosts
```

И `.ssh`, и `known_hosts` были созданы после установки первого удаленного подключения. `~/.ssh` - это каталог по умолчанию для пользовательской конфигурации и информации аутентификации.

>Вы также можете использовать `ssh`, чтобы просто выполнить одну команду на удаленном хосте, а затем вернуться на свой локальный терминал (например, запустить `ssh ina@halof ls`).

Если вы используете одного и того же пользователя на локальном и удаленном хостах, нет необходимости указывать имя пользователя при установке SSH-соединения. Например, если вы вошли в систему как пользователь `carol` в `debian` и хотите подключиться к `halof` также как пользователь `carol`, вы должны просто ввести `ssh 192.168.1.77` или `ssh halof` (если имя может быть разименовано):

```console
carol@debian:~$ ssh halof
Password:
Last login: Wed Jul  1 23:45:02 2020 from 192.168.1.55
Have a lot of fun...
carol@halof:~>
```

Теперь предположим, что вы устанавливаете новое удаленное соединение с хостом, который имеет тот же IP-адрес, что и `halof` (обычное дело, если вы используете DHCP в своей локальной сети). Вы будете предупреждены о возможности атаки *злоумышленник посередине*:

```console
carol@debian:~$ ssh john@192.168.1.77
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the ECDSA key sent by the remote host is
SHA256:KH4q3vP6C7e0SEjyG8Wlz9fVlf+jmWJ5139RBxBh3TY.
Please contact your system administrator.
Add correct host key in /home/carol/.ssh/known_hosts to get rid of this message.
Offending ECDSA key in /home/carol/.ssh/known_hosts:1
  remove with:
  ssh-keygen -f "/home/carol/.ssh/known_hosts" -R "192.168.1.77"
ECDSA host key for 192.168.1.77 has changed and you have requested strict checking.
Host key verification failed.
```

Поскольку вы не имеете дело с атакой *злоумышленник в середине*, вы можете безопасно добавить отпечаток открытого ключа нового хоста в `.ssh/known_hosts`. Как указано в сообщении, вы можете сначала использовать команду `ssh-keygen -f "/home/carol/.ssh/known_hosts" -R "192.168.1.77"`, чтобы удалить *неправильный* ключ (в качестве альтернативы вы можете использовать s`sh-keygen - R 192.168.1.77`, чтобы удалить все ключи, принадлежащие `192.168.1.77` из `~/.ssh/known_hosts`). После этого вы сможете установить соединение с новым хостом.


## Логины на основе ключей

Вы можете настроить свой SSH-клиент так, чтобы при входе в систему не предоставлялись пароли, а вместо этого использовались открытые ключи. Это предпочтительный метод подключения к удаленному серверу через SSH, поскольку он намного безопаснее. Первое, что вам нужно сделать, это создать пару ключей на клиентской машине. Для этого вы будете использовать `ssh-keygen` с параметром `-t`, указывающим тип шифрования, который вы хотите (в нашем случае - *алгоритм цифровой подписи с эллиптической кривой*). Затем вас попросят указать путь для сохранения пары ключей (`~/.ssh/` удобно, а также местоположение по умолчанию) и кодовую фразу. Хотя кодовая фраза не является обязательной, настоятельно рекомендуется ее всегда использовать.

```console
carol@debian:~/.ssh$ ssh-keygen -t ecdsa
Generating public/private ecdsa key pair.
Enter file in which to save the key (/home/carol/.ssh/id_ecdsa):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/carol/.ssh/id_ecdsa.
Your public key has been saved in /home/carol/.ssh/id_ecdsa.pub.
The key fingerprint is:
SHA256:tlamD0SaTquPZYdNepwj8XN4xvqmHCbe8g5FKKUfMo8 carol@debian
The key's randomart image is:
+---[ECDSA 256]---+
|      .          |
|     o .         |
|    = o o        |
|     B *         |
|    E B S o      |
|     o & O       |
|      @ ^ =      |
|     *.@ @.      |
|    o.o+B+o      |
+----[SHA256]-----+
```

>При создании пары ключей вы можете передать `ssh-keygen` параметр `-b`, чтобы указать размер ключа в битах (например: `ssh-keygen -t ecdsa -b 521`).

Предыдущая команда создала еще два файла в вашем каталоге `~/.ssh`:

```console
carol@debian:~/.ssh$ ls
id_ecdsa  id_ecdsa.pub  known_hosts
```

`id_ecdsa`  
Это ваш закрытый ключ. 

`id_ecdsa.pub`  
Это ваш открытый ключ.

>В асимметричной криптографии (также известной как криптография с открытым ключом) открытый и закрытый ключи математически связаны друг с другом таким образом, что все, что зашифровано одним, может быть дешифровано только другим.

Следующее, что вам нужно сделать, это добавить свой открытый ключ в файл `~/.ssh/authorized_keys` пользователя, которому вы хотите войти как на удаленном хосте (если каталог `~/.ssh` еще не существует, у вас будет чтобы создать его первым). Вы можете скопировать свой открытый ключ на удаленный сервер несколькими способами: с помощью USB-накопителя, с помощью команды `scp`, которая передаст файл через SSH, или путем *выделения содержимого* вашего открытого ключа и передачи его в `ssh` вот так:

```console
carol@debian:~/.ssh$ cat id_ecdsa.pub |ssh ina@192.168.1.77 'cat >> .ssh/authorized_keys'
Password:
```

После того, как ваш открытый ключ был добавлен в файл `authorized_keys` на удаленном хосте, вы можете столкнуться с двумя сценариями при попытке установить новое соединение:

* Если вы не указали кодовую фразу при создании пары ключей, вы войдете в систему автоматически. Хотя этот метод удобен, он может быть небезопасным в зависимости от ситуации:
```console
carol@debian:~$ ssh ina@192.168.1.77
Last login: Thu Jun 25 20:31:03 2020 from 192.168.1.55
Have a lot of fun...
ina@halof:~>
```

* Если вы указали парольную фразу при создании пары ключей, вам придется вводить ее при каждом подключении почти так же, как если бы это был пароль. Помимо открытого ключа, этот метод добавляет дополнительный уровень безопасности в виде парольной фразы и поэтому может считаться более безопасным. Однако, что касается удобства, это то же самое, что вводить пароль каждый раз, когда вы устанавливаете соединение. Если вы не используете парольную фразу и кому-то удастся получить ваш закрытый файл ключа SSH, у них будет доступ ко всем серверам, на которых установлен ваш открытый ключ.
```console
carol@debian:~/.ssh$ ssh ina@192.168.1.77
Enter passphrase for key '/home/carol/.ssh/id_ecdsa':
Last login: Thu Jun 25 20:39:30 2020 from 192.168.1.55
Have a lot of fun...
ina@halof:~>
```

Однако есть способ, сочетающий безопасность и удобство: использование *агента аутентификации SSH* (`ssh-agent`). Агент аутентификации должен создать свою собственную оболочку и будет хранить ваши личные ключи - для аутентификации с открытым ключом - в памяти до конца сеанса. Давайте посмотрим, как это работает, более подробно: 1. Используйте `ssh-agent`, чтобы запустить новую оболочку Bash:
```console
carol@debian:~/.ssh$ ssh-agent /bin/bash
carol@debian:~/.ssh$
```
2. Используйте команду `ssh-add`, чтобы добавить свой закрытый ключ в безопасную область памяти. Если вы указали парольную фразу при генерации пары ключей - что рекомендуется для дополнительной безопасности - вам будет предложено ввести ее:
```console
carol@debian:~/.ssh$ ssh-add
Enter passphrase for /home/carol/.ssh/id_ecdsa:
Identity added: /home/carol/.ssh/id_ecdsa (carol@debian)
```  
После того, как ваша личность была добавлена, вы можете войти на любой удаленный сервер, на котором присутствует ваш открытый ключ, без повторного ввода ключевой фразы. На современных настольных компьютерах распространена практика выполнения этой команды при загрузке компьютера, так как она остается в памяти до выключения компьютера (или до тех пор, пока ключ не будет выгружен вручную).

Давайте завершим этот раздел перечислением четырех типов алгоритмов открытого ключа, которые можно указать с помощью `ssh-keygen`: 
`RSA`  
Названный в честь создателей Рона Ривеста, Ади Шамира и Леонарда Адлемана, он был опубликован в 1977 году. Он считается безопасным и широко используется до сих пор. Его минимальный размер ключа составляет 1024 бита (по умолчанию 2048). 

`DSA`  
*Алгоритм цифровой подписи* оказался небезопасным, и в OpenSSH 7.0 он устарел. Ключи DSA должны иметь длину не более 1024 битов. 

`ecdsa`  
*Алгоритм цифровой подписи с эллиптической кривой* является усовершенствованием DSA и, следовательно, считается более безопасным. Он использует криптографию на основе эллиптических кривых. Длина ключа ECDSA определяется одним из трех возможных размеров эллиптической кривой в битах: 256, 384 или 521. 

`ed25519`  
Это реализация `EdDSA` - *алгоритма цифровой подписи на основе кривой Эдвардса* - который использует более сильную кривую 25519. Считается самым безопасным из всех. Все ключи Ed25519 имеют фиксированную длину 256 бит.

>Если вызывается без указания `-t`, `ssh-keygen` по умолчанию сгенерирует пару ключей `RSA`


## Роль ключей хоста сервера OpenSSH

Каталог глобальной конфигурации для OpenSSH находится в каталоге `/etc`:

```console
halof:~ # tree /etc/ssh
/etc/ssh
├── moduli
├── ssh_config
├── ssh_host_dsa_key
├── ssh_host_dsa_key.pub
├── ssh_host_ecdsa_key
├── ssh_host_ecdsa_key.pub
├── ssh_host_ed25519_key
├── ssh_host_ed25519_key.pub
├── ssh_host_rsa_key
├── ssh_host_rsa_key.pub
└── sshd_config

0 directories, 11 files
```

Помимо модулей и файлов конфигурации для клиента (`ssh_config`) и сервера (`sshd_config`), вы найдете четыре пары ключей - пару ключей для каждого поддерживаемого алгоритма, - которые создаются при установке сервера OpenSSH. Как уже отмечалось, сервер использует эти ключи хоста, чтобы при необходимости идентифицировать себя для клиентов. Их название выглядит следующим образом:

Приватные ключи  
префикс `ssh_host_` + *алгоритм* + `key ` суффикс (например: `ssh_host_rsa_key`) 

Открытые ключи (или отпечатки открытых ключей)  
префикс `ssh_host_` + *алгоритм* + `key.pub` суффикс (например: `ssh_host_rsa_key.pub`)

>Отпечаток пальца создается путем применения криптографической хеш-функции к открытому ключу. Поскольку отпечатки пальцев короче ключей, к которым они относятся, они пригодятся для упрощения определенных задач управления ключами.
