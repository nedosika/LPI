# 110.1 Урок 1

| **Сертификат:** | LPIC-1                                      |
|:----------------|:--------------------------------------------|
| **Версия:**     | 5.0                                         |
| **Тема:**       | 110 Безопасность                            |                           
| **Цель:**       | 110.1 Выполнять задачи администрирования безопасности |
| **Урок:**       | 1 из 1                                      |


## Введение

Безопасность является обязательным условием системного администрирования. Как хороший системный администратор Linux, вы должны следить за рядом вещей, таких как особые права доступа к файлам, устаревание пароля пользователя, открытые порты и сокеты, ограничение использования системных ресурсов, работа с вошедшими в систему пользователями и повышение привилегий с помощью `su` и `sudo`. В этом уроке мы рассмотрим каждую из этих тем.


## Проверка файлов с установленными SUID и SGID

Помимо традиционного набора прав на *чтение*, *запись* и *выполнение*, файлы в системе Linux также могут иметь некоторые специальные права, такие как биты SUID или SGID. 

Бит SUID позволяет запускать файл с привилегиями владельца файла. Он численно представлен `4000` и символически представлен либо `s`, либо `S` в бите права на *выполнение* владельцем. Классическим примером исполняемого файла с набором разрешений SUID является `passwd`:

```console
carol@debian:~$ ls -l /usr/bin/passwd
-rwsr-xr-x 1 root root 63736 jul 27  2018 /usr/bin/passwd
```

Строчная буква `s` в `rws` указывает на наличие SUID в файле вместе с разрешением на выполнение. Вместо этого заглавная буква `S` (`rwS`) будет означать, что базовое право на *выполнение* не установлено.

>Вы узнаете о `passwd` в следующем разделе. Утилита в основном используется `root` для установки/изменения паролей пользователей (например: `passwd carol`). Однако обычные пользователи могут использовать его и для изменения собственных паролей. Поэтому он поставляется с набором SUID.

С другой стороны, бит SGID может быть установлен как для файлов, так и для каталогов. С файлами его поведение эквивалентно поведению SUID, но привилегии принадлежат владельцу группы. Однако, если он установлен в каталоге, он позволит всем файлам, созданным в нем, унаследовать право собственности на группу каталога. Как и SUID, SGID символически представлен либо `s`, либо `S` в бите права на выполнение группы. Численно он представлен как `2000`. Вы можете установить SGID для каталога с помощью `chmod`. Вы должны добавить `2` (SGID) к традиционным правам (в нашем случае `755`):

```console
carol@debian:~$ ls -ld shared_directory
drwxr-xr-x 2 carol carol 4096 may 30 23:55 shared_directory
carol@debian:~$ sudo chmod 2755 shared_directory/
carol@debian:~$ ls -ld shared_directory
drwxr-sr-x 2 carol carol 4096 may 30 23:55 shared_directory
```

Чтобы найти файлы с одним или обоими установленными SUID и SGID, вы можете использовать команду `find` и использовать параметр `-perm`. Вы можете использовать как числовые, так и символьные значения. Значения, в свою очередь, могут передаваться сами по себе или им предшествовать дефис (`-`) или косая черта (`/`). Смысл в следующем: 

`-perm numeric-vaue` или `-perm symbolic-value`  
находить файлы исключительно со специальным разрешением 

`-perm -numeric-value` или `-perm -symbolic-value`  
найти файлы со специальными правами доступа и другими правами 

`-perm / numeric-value` или `-perm / symbolic-value`  
найти файлы, имеющие какое-либо из специальных прав доступа (и других прав доступа) 

Например, чтобы найти файлы, в текущем рабочем каталоге которых установлен только SUID, вы воспользуетесь следующей командой:

```console
carol@debian:~$ find . -perm 4000
carol@debian:~$ touch file
carol@debian:~$ chmod 4000 file
carol@debian:~$ find . -perm 4000
./file.
```

Обратите внимание, как - поскольку не было никаких файлов, имеющих исключительно SUID, - мы создали его, чтобы показать некоторые результаты. Вы можете запустить ту же команду в символической записи:

```console
carol@debian:~$ find . -perm u+s
./file
```

Чтобы найти файлы, соответствующие SUID (независимо от других разрешений) в каталоге `/usr/bin/`, вы можете использовать любую из следующих команд:

```console
carol@debian:~$ sudo find /usr/bin -perm -4000
/usr/bin/umount
/usr/bin/newgrp
/usr/bin/gpasswd
/usr/bin/chfn
/usr/bin/mount
/usr/bin/passwd
/usr/bin/chsh
/usr/bin/sudo
/usr/bin/su
carol@debian:~$ sudo find /usr/bin -perm -u+s
/usr/bin/umount
/usr/bin/newgrp
/usr/bin/gpasswd
/usr/bin/chfn
/usr/bin/mount
/usr/bin/passwd
/usr/bin/chsh
/usr/bin/sudo
/usr/bin/su
```

Если вы ищете файлы в том же каталоге с установленным битом SGID, вы можете выполнить `find /usr/bin/ -perm -2000` или `find /usr/bin/ -perm -g +s`. 

Наконец, чтобы найти файлы с одним из двух специальных разрешений, добавьте `4` и `2` и используйте `/`:

```console
carol@debian:~$ sudo find /usr/bin -perm /6000
/usr/bin/dotlock.mailutils
/usr/bin/umount
/usr/bin/newgrp
/usr/bin/wall
/usr/bin/ssh-agent
/usr/bin/chage
/usr/bin/dotlockfile
/usr/bin/gpasswd
/usr/bin/chfn
/usr/bin/mount
/usr/bin/passwd
/usr/bin/chsh
/usr/bin/expiry
/usr/bin/sudo
/usr/bin/bsd-write
/usr/bin/crontab
/usr/bin/su
```


## Управление паролями и устаревание

Как отмечалось выше, вы можете использовать утилиту `passwd`, чтобы изменить свой пароль как обычный пользователь. Кроме того, вы можете передать ключ `-S` или `--status`, чтобы получить информацию о статусе вашей учетной записи:

```console
carol@debian:~$ passwd -S
carol P 12/07/2019 0 99999 7 -1
```

Вот разбивка семи полей, которые вы получаете в выводе: 

`carol`  
Логин пользователя. 

`p`  
Это указывает на то, что у пользователя есть действующий пароль (`P`); другие возможные значения: `L` для заблокированного пароля и `NP` для отсутствия пароля. 

`07.12.2019`  
Дата последней смены пароля. 

`0`  
Минимальный возраст в днях (минимальное количество дней между сменой пароля). Значение `0` означает, что пароль можно изменить в любое время. 

`99999`  
Максимальный возраст в днях (максимальное количество дней, в течение которых действует пароль). Значение `99999` отключит истечение срока действия пароля. 

`7`  
Период предупреждения в днях (количество дней до истечения срока действия пароля, о котором пользователь будет предупрежден). 

`-1`  
Период неактивности пароля в днях (количество дней бездействия после истечения срока действия пароля до блокировки учетной записи). Значение `-1` удалит неактивность аккаунта. 

Помимо отчетов о состоянии учетной записи, вы будете использовать команду `passwd` как root для выполнения некоторых основных операций по обслуживанию учетной записи. Вы можете заблокировать и разблокировать учетные записи, заставить пользователя изменить свой пароль при следующем входе в систему и удалить пароль пользователя с помощью параметров `-l`, `-u`, `-e` и `-d` соответственно. 

Чтобы проверить эти параметры, здесь удобно ввести команду `su`. С помощью `su` вы можете менять пользователей во время сеанса входа в систему. Так, например, давайте использовать `passwd` как root, чтобы заблокировать пароль `carol`. Затем мы переключимся на `carol` и проверим статус нашей учетной записи, чтобы убедиться, что пароль фактически заблокирован (`L`) и не может быть изменен. Наконец, вернувшись к пользователю root, мы разблокируем пароль `carol`:

```console
root@debian:~# passwd -l carol
passwd: password expiry information changed.
root@debian:~# su - carol
carol@debian:~$ passwd -S
carol L 05/31/2020 0 99999 7 -1
carol@debian:~$ passwd
Changing password for carol.
Current password:
passwd: Authentication token manipulation error
passwd: password unchanged
carol@debian:~$ exit
logout
root@debian:~# passwd -u carol
passwd: password expiry information changed.
```

Кроме того, вы также можете заблокировать и разблокировать пароль пользователя с помощью команды `usermod`: 

Заблокировать пароль пользователя `carol`  
`usermod -L carol` или `usermod --lock carol`. 

Разблокировать пароль пользователя `carol`  
`usermod -U carol` или `usermod --unlock carol`.

>С переключателями `-f` или `--inactive` можно также использовать `usermod` для установки количества дней до отключения учетной записи с просроченным паролем (например: `usermod -f 3 carol`).

Помимо `passwd` и `usermod`, самая прямая команда для работы с паролем и устареванием учетной записи - `chage` («изменить возраст»). Как root, вы можете передать `chage` ключ `-l` (или `--list`), за которым следует имя пользователя, чтобы на экране был напечатан текущий пароль этого пользователя и информация об истечении срока действия учетной записи; как обычный пользователь, вы можете просматривать свою информацию:

```console
carol@debian:~$ chage -l carol
Last password change					: Aug 06, 2019
Password expires					: never
Password inactive					: never
Account expires						: never
Minimum number of days between password change		: 0
Maximum number of days between password change		: 99999
Number of days of warning before password expires	: 7
```

Запустить без параметров и только после имени пользователя, `chage` будет вести себя в интерактивном режиме:

```console
root@debian:~# chage carol
Changing the aging information for carol
Enter the new value, or press ENTER for the default

	Minimum Password Age [0]:
	Maximum Password Age [99999]:
	Last Password Change (YYYY-MM-DD) [2020-06-01]:
	Password Expiration Warning [7]:
	Password Inactive [-1]:
	Account Expiration Date (YYYY-MM-DD) [-1]:
```

Возможны следующие варианты изменения различных настроек `chage`: 

`-m days username` или `--mindays days username`  
Укажите минимальное количество дней между сменой пароля (например: `chage -m 5 carol`). Значение `0` позволит пользователю изменить свой пароль в любое время. 

`-M days username` или `--maxdays username`  
Укажите максимальное количество дней, в течение которых пароль будет действителен (например: `chage -M 30 carol`). Чтобы отключить истечение срока действия пароля, обычно задают этой опции значение `99999`. 

`-d days username` или `--lastday days username`  
Укажите количество дней с момента последней смены пароля (например: `chage -d 10 carol`). Значение `0` заставит пользователя сменить пароль при следующем входе в систему. 

`-W days username` или `--warndays days username`  
Укажите количество дней, в течение которых пользователю будут напоминать об истечении срока действия пароля. 

`-I days username` или `--inactive days username`  
Укажите количество дней бездействия после истечения срока действия пароля (например: `chage -I 10 carol`) - так же, как `usermod -f` или `usermod --inactive`. По прошествии указанного количества дней учетная запись будет заблокирована. Однако при значении `0` учетная запись не будет заблокирована. 

`-E date username` или `--expiredate date username`  
Укажите дату (или количество дней с эпохи - 1 января 1970 г.), в которую учетная запись будет заблокирована. Обычно он выражается в формате `YYYY-MM-DD`(например: `chage -E 2050-12-13 carol`).

>Вы можете узнать больше о `passwd`, `usermod` и `chage` - и их опциях - на соответствующих страницах руководства. 


## Обнаружение открытых портов

Когда дело доходит до отслеживания открытых портов, в большинстве систем Linux присутствуют четыре мощные утилиты: `lsof`, `fuser`, `netstat` и `nmap`. Мы рассмотрим их в этом разделе. 

`lsof` означает «список открытых файлов», что немаловажно, учитывая, что для Linux все является файлом. Фактически, если вы введете `lsof` в терминал, вы получите большой список обычных файлов, файлов устройств, сокетов и т. д. Однако в рамках этого урока мы в основном сосредоточимся на портах. Чтобы распечатать список всех сетевых файлов «Интернет», запустите `lsof` с параметром `-i`:

```console
root@debian:~# lsof -i
COMMAND  PID     USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
dhclient 357     root    7u  IPv4  13493      0t0  UDP *:bootpc
sshd     389     root    3u  IPv4  13689      0t0  TCP *:ssh (LISTEN)
sshd     389     root    4u  IPv6  13700      0t0  TCP *:ssh (LISTEN)
apache2  399     root    3u  IPv6  13826      0t0  TCP *:http (LISTEN)
apache2  401 www-data    3u  IPv6  13826      0t0  TCP *:http (LISTEN)
apache2  402 www-data    3u  IPv6  13826      0t0  TCP *:http (LISTEN)
sshd     557     root    3u  IPv4  14701      0t0  TCP 192.168.1.7:ssh->192.168.1.4:60510 (ESTABLISHED)
sshd     569    carol    3u  IPv4  14701      0t0  TCP 192.168.1.7:ssh->192.168.1.4:60510 (ESTABLISHED)
```

Помимо службы `bootpc`, которая используется DHCP, на выходе показаны две службы, прослушивающие соединения - `ssh` и веб-сервер Apache (`http`), а также два установленных SSH-соединения. Вы можете указать конкретный хост с обозначением `@ip-address`, чтобы проверить его соединения:

```console
root@debian:~# lsof -i@192.168.1.7
COMMAND PID  USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
sshd    557  root    3u  IPv4  14701      0t0  TCP 192.168.1.7:ssh->192.168.1.4:60510 (ESTABLISHED)
sshd    569 carol    3u  IPv4  14701      0t0  TCP 192.168.1.7:ssh->192.168.1.4:60510 (ESTABLISHED)
```

>Чтобы вывести только сетевые файлы IPv4 и IPv6, используйте параметры `-i4` и `-i6` соответственно.

Точно так же вы можете фильтровать по портам, передав параметр `-i` (или `-i @*ip-address*`) в аргумент `:port`:

```console
root@debian:~# lsof -i :22
COMMAND PID  USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
sshd    389  root    3u  IPv4  13689      0t0  TCP *:ssh (LISTEN)
sshd    389  root    4u  IPv6  13700      0t0  TCP *:ssh (LISTEN)
sshd    557  root    3u  IPv4  14701      0t0  TCP 192.168.1.7:ssh->192.168.1.4:60510 (ESTABLISHED)
sshd    569 carol    3u  IPv4  14701      0t0  TCP 192.168.1.7:ssh->192.168.1.4:60510 (ESTABLISHED)
```

Несколько портов разделяются запятыми (а диапазоны указываются через тире):

```console
root@debian:~# lsof -i@192.168.1.7:22,80
COMMAND PID  USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
sshd    705  root    3u  IPv4  13960      0t0  TCP 192.168.1.7:ssh->192.168.1.4:44766 (ESTABLISHED)
sshd    718 carol    3u  IPv4  13960      0t0  TCP 192.168.1.7:ssh->192.168.1.4:44766 (ESTABLISHED)
```

Количество опций, доступных для `lsof`, впечатляет. Чтобы узнать больше, обратитесь к его странице руководства.

Следующим в списке сетевых команд идет `fuser`. Его основная цель - найти «пользователя файла», что включает в себя знание того, какие процессы к каким файлам обращаются; он также дает вам некоторую другую информацию, такую как тип доступа. Например, чтобы проверить текущий рабочий каталог, достаточно запустить `fuser`. Однако, чтобы получить немного больше информации, удобно использовать подробный параметр (`-v` или `--verbose`):

```console
root@debian:~# fuser .
/root:                 580c
root@debian:~# fuser -v .
                     USER        PID ACCESS COMMAND
/root:               root        580 ..c.. bash
```

Разберем вывод: 

`File`  
Файл, о котором мы получаем информацию (`/root`). 

`USER` столбец  
Владелец файла (`root`). 

Столбец `PID`  
Идентификатор процесса (`580`).  

Столбец `ACCESS`  
Тип доступа (`..c ..`). Один из:  
`c`  
Текущий каталог. 

`е`  
Исполняемый файл запущен. 

`f`  
Открыть файл (опускается в режиме отображения по умолчанию). 

`F`  
Открыть файл для записи (опускается в режиме отображения по умолчанию). 

`r`  
корневая директория. 

`m`  
размеченный файл или общая библиотека. 

`.`  
Заполнитель (опускается в режиме отображения по умолчанию). 

Столбец `COMMAND`  
Команда, связанная с файлом (`bash`). 

С параметром `-n` (или `--namespace`) вы можете найти информацию о сетевых портах/сокетах. Вы также должны указать сетевой протокол и номер порта. Таким образом, чтобы получить информацию о веб-сервере Apache, вы выполните следующую команду:

```console
root@debian:~# fuser -vn tcp 80
                     USER        PID ACCESS COMMAND
80/tcp:              root        402 F.... apache2
                     www-data    404 F.... apache2
                     www-data    405 F.... apache2
```

>`fuser` также можно использовать для уничтожения процессов, обращающихся к файлу, с помощью переключателей `-k` или `--kill` (например: `fuser -k 80/tcp`). Обратитесь к странице руководства для получения более подробной информации.

Теперь обратимся к `netstat`. `netstat` - очень универсальный сетевой инструмент, который в основном используется для вывода на экран «сетевой статистики». 

При запуске без параметров `netstat` отобразит как активные подключения к Интернету, так и сокеты Unix. Из-за размера листинга вы можете захотеть передать его вывод через `less`:

```console
carol@debian:~$ netstat |less
Active Internet connections (w/o servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State
tcp        0      0 192.168.1.7:ssh         192.168.1.4:55444       ESTABLISHED
Active UNIX domain sockets (w/o servers)
Proto RefCnt Flags       Type       State         I-Node   Path
unix  2      [ ]         DGRAM                    10509    /run/systemd/journal/syslog
unix  3      [ ]         DGRAM                    10123    /run/systemd/notify
(...)
```

Чтобы перечислить только «прослушивающие» порты и сокеты, воспользуетесь параметрами `-l` или `--listening`. Параметры `-t`/`-tcp` и `-u`/`-udp` могут быть добавлены для фильтрации по протоколу TCP и UDP соответственно (их также можно объединить в одной команде). Точно так же `-e`/`-extend` отобразит дополнительную информацию:

```console
carol@debian:~$ netstat -lu
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State
udp        0      0 0.0.0.0:bootpc          0.0.0.0:*
carol@debian:~$ netstat -lt
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State
tcp        0      0 0.0.0.0:ssh             0.0.0.0:*               LISTEN
tcp        0      0 localhost:smtp          0.0.0.0:*               LISTEN
tcp6       0      0 [::]:http               [::]:*                  LISTEN
tcp6       0      0 [::]:ssh                [::]:*                  LISTEN
tcp6       0      0 localhost:smtp          [::]:*                  LISTEN
carol@debian:~$ netstat -lute
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       User       Inode
tcp        0      0 0.0.0.0:ssh             0.0.0.0:*               LISTEN      root       13729
tcp        0      0 localhost:smtp          0.0.0.0:*               LISTEN      root       14372
tcp6       0      0 [::]:http               [::]:*                  LISTEN      root       14159
tcp6       0      0 [::]:ssh                [::]:*                  LISTEN      root       13740
tcp6       0      0 localhost:smtp          [::]:*                  LISTEN      root       14374
udp        0      0 0.0.0.0:bootpc          0.0.0.0:*                           root       13604
```

Если вы опустите опцию `-l`, будут показаны только установленные соединения:

```console
carol@debian:~$ netstat -ute
Active Internet connections (w/o servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       User       Inode
tcp        0      0 192.168.1.7:ssh         192.168.1.4:39144       ESTABLISHED root       15103
```

Если вас интересует только числовая информация о портах и хостах, вы можете использовать опцию `-n` или `--numeric` для печати только номеров портов и IP-адресов. Обратите внимание, как `ssh` превращается в `22` при добавлении `-n` к приведенной выше команде:

```console
carol@debian:~$ netstat -uten
Active Internet connections (w/o servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       User       Inode
tcp        0      0 192.168.1.7:22          192.168.1.4:39144       ESTABLISHED 0          15103
```

Как видите, вы можете создавать очень полезные и продуктивные команды `netstat`, комбинируя некоторые из его параметров. Просмотрите страницы руководства, чтобы узнать больше и найти комбинации, которые лучше всего соответствуют вашим потребностям. 

Наконец, мы представим `nmap` - «сетевой картограф». Еще одна очень мощная утилита, этот сканер портов, запускается путем указания IP-адреса или имени хоста:

```console
root@debian:~# nmap localhost
Starting Nmap 7.70 ( https://nmap.org ) at 2020-06-04 19:29 CEST
Nmap scan report for localhost (127.0.0.1)
Host is up (0.0000040s latency).
Other addresses for localhost (not scanned): ::1
Not shown: 998 closed ports
PORT   STATE SERVICE
22/tcp open  ssh
80/tcp open  http

Nmap done: 1 IP address (1 host up) scanned in 1.58 seconds
```

Помимо одного хоста, `nmap` позволяет сканировать: 

несколько хостов  
разделив их пробелами (например: `nmap localhost 192.168.1.7`). 

диапазоны хостов  
с помощью тире (например, `nmap 192.168.1.3-20`). 

подсети  
с использованием подстановочного знака или нотации CIDR (например, `nmap 192.168.1.*` или `nmap 192.168.1.0/24`). 

Вы можете исключить определенные хосты (например: `nmap 192.168.1.0/24 --exclude 192.168.1.7`). Чтобы просканировать конкретный порт, используйте параметр `-p`, за которым следует номер порта или имя службы (`nmap -p 22` и `nmap -p ssh` дадут вам тот же результат):

```console
root@debian:~# nmap -p 22 localhost
Starting Nmap 7.70 ( https://nmap.org ) at 2020-06-04 19:54 CEST
Nmap scan report for localhost (127.0.0.1)
Host is up (0.000024s latency).
Other addresses for localhost (not scanned): ::1

PORT   STATE SERVICE
22/tcp open  ssh

Nmap done: 1 IP address (1 host up) scanned in 0.22 seconds
```

Вы также можете сканировать несколько портов или диапазонов портов, используя запятые и тире соответственно:

```console
root@debian:~# nmap -p ssh,80 localhost
Starting Nmap 7.70 ( https://nmap.org ) at 2020-06-04 19:58 CEST
Nmap scan report for localhost (127.0.0.1)
Host is up (0.000051s latency).
Other addresses for localhost (not scanned): ::1

PORT   STATE SERVICE
22/tcp open  ssh
80/tcp open  http

Nmap done: 1 IP address (1 host up) scanned in 0.22 seconds
```
```console
root@debian:~# nmap -p 22-80 localhost
Starting Nmap 7.70 ( https://nmap.org ) at 2020-06-04 19:58 CEST
Nmap scan report for localhost (127.0.0.1)
Host is up (0.000011s latency).
Other addresses for localhost (not scanned): ::1
Not shown: 57 closed ports
PORT   STATE SERVICE
22/tcp open  ssh
80/tcp open  http

Nmap done: 1 IP address (1 host up) scanned in 1.47 seconds
```

Два других важных и удобных параметра `nmap`: 

`-F`  
Выполнит быстрое сканирование 100 наиболее распространенных портов. 

`-v`  
Подробный вывод (`-vv` выведет еще более подробный вывод).

>`nmap` может запускать довольно сложные команды, используя типы сканирования. Однако эта тема выходит за рамки этого урока.


## Ограничения на вход в систему, процессы и использование памяти

Ресурсы в системе Linux не безграничны, поэтому - как системный администратор - вы должны обеспечить хороший баланс между *пользовательскими ограничениями* на ресурсы и правильным функционированием операционной системы. `ulimit` может помочь вам в этом отношении. 

`ulimit` имеет дело с *мягкими* и *жесткими* ограничениями, задаваемыми параметрами `-S` и `-H` соответственно. При запуске без параметров или аргументов `ulimit` отобразит программные блоки файлов текущего пользователя:

```console
carol@debian:~$ ulimit
unlimited
```

С параметром `-a ulimit` покажет все текущие мягкие ограничения (так же, как `-Sa`); чтобы отобразить все текущие жесткие ограничения, используйте `-Ha`:

```console
carol@debian:~$ ulimit -a
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
(...)
carol@debian:~$ ulimit -Ha
core file size          (blocks, -c) unlimited
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
(...)
```

Доступные ресурсы оболочки указываются такими параметрами, как: 

`-b`  
максимальный размер буфера сокета 

`-f`  
максимальный размер файлов, записываемых оболочкой и ее дочерними элементами 

`-l`  
максимальный размер, который может быть заблокирован в памяти 

`-m`  
максимальный размер резидентного набора (RSS) - текущая часть памяти, удерживаемая процессом в основной памяти (RAM) 

`-v`  
максимальный объем виртуальной памяти 

`-u`  
максимальное количество процессов, доступных одному пользователю 

Таким образом, для отображения ограничений вы будете использовать `ulimit`, за которым следует `-S` (мягкий) или `-H` (жесткий) и параметр ресурса; если не указаны ни `-S`, ни `-H`, будут показаны мягкие ограничения:

```console
carol@debian:~$ ulimit -u
10000
carol@debian:~$ ulimit -Su
10000
carol@debian:~$ ulimit -Hu
15672
```

Аналогичным образом, чтобы установить новые ограничения для конкретного ресурса, вы должны указать либо `-S`, либо `-H`, за которым следует соответствующая опция ресурса и новое значение. Это значение может быть числом или специальными словами `soft` (текущий мягкий предел), `hard` (текущий жесткий предел) или `unlimited` (без ограничения). Если не указано ни `-S`, ни `-H`, будут установлены оба предела. Например, давайте сначала прочитаем текущее значение максимального размера для файлов, записанных оболочкой и ее дочерними элементами:

```console
root@debian:~# ulimit -Sf
unlimited
root@debian:~# ulimit -Hf
unlimited
```

Теперь давайте изменим значение с `unlimited` на `500` блоков без указания `-S` или `-H`. Обратите внимание, как меняются как мягкие, так и жесткие ограничения:

```console
root@debian:~# ulimit -f 500
root@debian:~# ulimit -Sf
500
root@debian:~# ulimit -Hf
500
```

Наконец, мы уменьшим только мягкий лимит до `200` блоков:

Жесткие ограничения могут быть увеличены только пользователем root. С другой стороны, обычные пользователи могут уменьшить жесткие ограничения и увеличить мягкие ограничения до значения жестких ограничений. Чтобы новые предельные значения сохранялись при перезагрузках, вы должны записать их в файл `/etc/security/limits.conf`. Это также файл, используемый администратором для наложения ограничений на определенных пользователей.

>Имейте в виду, что man-страницы `ulimit` как таковой не существует. Это встроенная функция bash, поэтому вам нужно обратиться к странице руководства bash, чтобы узнать о ней.


## Работа с вошедшими в систему пользователями

Другая ваша работа в качестве системного администратора - это отслеживание пользователей, вошедших в систему. Есть три утилиты, которые могут помочь вам с этими задачами: `last`, `who` и `w`. 

`last` выводит на экран список последних вошедших в систему пользователей с самой последней информацией вверху:

```console
root@debian:~# last
carol    pts/0        192.168.1.4      Sat Jun  6 14:25   still logged in
reboot   system boot  4.19.0-9-amd64   Sat Jun  6 14:24   still running
mimi     pts/0        192.168.1.4      Sat Jun  6 12:07 - 14:24  (02:16)
reboot   system boot  4.19.0-9-amd64   Sat Jun  6 12:07 - 14:24  (02:17)
(...)
wtmp begins Sun May 31 14:14:58 2020
```

Рассматривая усеченный листинг, мы получаем информацию о двух последних пользователях в системе. Первые две строки рассказывают нам о пользователе `carol`; следующие две строчки о пользователе `mimi`. Информация следующая: 
1. Пользователь `carol` на терминале `pts/0` с хоста `192.168.1.4` начал сеанс в `Sat Jun 6` в `14:25` и все еще `logged in`. Система - с использованием ядра `4.19.0-9-amd64` - была запущена (`reboot system boot`) в `Sat Jun 6` в `14:24`, `still running`. 
2. Пользователь `mimi` на терминале `pts/0` с хоста `192.168.1.4` начал сеанс в `Sat Jun 6` в `12:07` и вышел из системы в `14:24` (сеанс длился в общей сложности (`02:16`) часов). Система - с использованием ядра `4.19.0-9-amd64` - была запущена (`reboot system boot`) в `Sat Jun 6` в `12:07` и выключена в `14:24` (она работала в течение (`02:17`) часов) .

>Строка `wtmpwtmp begins Sun May 31 14:14:58 2020`, относится к `/var/log/wtmp`, который является специальным файлом журнала, из которого последний раз получает информацию.

Вы можете передать `last` имя пользователя, чтобы отображались только записи для этого пользователя:

```console
root@debian:~# last carol
carol    pts/0        192.168.1.4      Sat Jun  6 14:25   still logged in
carol    pts/0        192.168.1.4      Sat Jun  6 12:07 - 14:24  (02:16)
carol    pts/0        192.168.1.4      Fri Jun  5 00:48 - 01:28  (00:39)
(...)
```

Что касается второго столбца (терминала), `pts` обозначает псевдотерминальное ведомое устройство - в отличие от правильного *TeleTYpewriter* или `tty`-терминала; `0` относится к первому (счет начинается с нуля).

>Чтобы проверить неудачные попытки входа в систему, запустите `lastb` вместо `last`

Утилиты `who` и `w` ориентированы на пользователей, вошедших в систему в данный момент, и очень похожи. Первая показывает, кто вошел в систему, а вторая также показывает информацию о том, что они делают. 

При выполнении без параметров, `who` будет отображать четыре столбца, соответствующие зарегистрированному пользователю, терминалу, дате и времени и имени хоста:

```console
root@debian:~# who
carol    pts/0        2020-06-06 17:16 (192.168.1.4)
mimi     pts/1        2020-06-06 17:28 (192.168.1.4)
```

`who` принимает ряд вариантов, среди которых можно выделить следующие: 

`-b`, `--boot`  
Отображение времени последней загрузки системы. 

`-r`, `--runlevel`  
Показать текущий уровень выполнения. 

`-H`, `-heading`  
Печатать заголовки столбцов. 

По сравнению с `who`, `w` дает более подробный вывод:

```console
root@debian:~# w
 17:56:12 up 40 min,  2 users,  load average: 0.04, 0.12, 0.09
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
carol    pts/0    192.168.1.4    17:16    1.00s  0.15s  0.05s sshd: carol [priv]
mimi     pts/1    192.168.1.4    17:28   15:08   0.05s  0.05s -bash
```

В верхней строке представлена информация о текущем времени (`17:56:12`), о том, как долго система была запущена и работала (`up 40 min`), о количестве пользователей, вошедших в систему в данный момент (`2 users`) и средних  нагрузках (`load average: 0.04, 0.12, 0.09`). Эти значения относятся к числу заданий в очереди выполнения, усредненному за последние 1, 5 и 15 минут соответственно. 

Затем вы находите восемь столбцов; давайте разберем их: 

`USER`  
Логин пользователя. 

`TTY`  
Имя терминала, на котором находится пользователь. 

`FROM`  
Удаленный хост, с которого пользователь вошел в систему. 

`LOGIN@`  
Время входа. 

`IDLE`  
Время простоя. 

`JCPU`  
Время, используемое всеми процессами, подключенными к tty (включая текущие фоновые задания). 

`PCPU`  
Время, используемое текущим процессом (то, что отображается под `WHAT`). 

`WHAT`  
Командная строка текущего процесса. 

Как и в случае с `who`, вы можете передать `w` имена пользователей:

```console
root@debian:~# w mimi
 18:23:15 up  1:07,  2 users,  load average: 0.00, 0.02, 0.05
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
mimi     pts/1    192.168.1.4      17:28    9:23   0.06s  0.06s -bash
```


## Базовая конфигурация и использование `sudo`

Как уже отмечалось в этом уроке, `su` позволяет вам переключиться на любого другого пользователя в системе, если вы укажете пароль целевого пользователя. В случае пользователя root, распространение его пароля или его известность (многим) пользователям подвергает систему риску и является очень плохой практикой безопасности. Основное использование `su` - `su - target-username`. Однако при переходе на root целевое имя пользователя указывать необязательно:

```console
carol@debian:~$ su - root
Password:
root@debian:~# exit
logout
carol@debian:~$ su -
Password:
root@debian:~#
```

Использование тире (`-`) гарантирует, что среда целевого пользователя загружена. Без него старая пользовательская среда будет сохранена:

```console
carol@debian:~$ su
Password:
root@debian:/home/carol#
```

С другой стороны, есть команда `sudo`. С его помощью вы можете выполнять команду от имени пользователя root или любого другого пользователя, если на то пошло. С точки зрения безопасности `sudo` - гораздо лучший вариант, чем `su`, так как имеет два основных преимущества: 

1. для запуска команды от имени пользователя root вам не нужен пароль пользователя root, а только пароль вызывающего пользователя в соответствии с политикой безопасности. Политика безопасности по умолчанию - `sudoers`, как указано в `/etc/sudoers` и `/etc/sudoers.d/*`. 
2. `sudo` позволяет запускать отдельные команды с повышенными привилегиями вместо запуска совершенно новой подоболочки для root, как это делает `su`. 

Основное использование `sudo` - команда `sudo -u target-username`. Однако для запуска команды от имени пользователя root параметр `-u target-username` не нужен:

```console
carol@debian:~$ sudo -u mimi whoami
mimi
carol@debian:~$ sudo whoami
root
```

>`sudoers` будет использовать временную метку для каждого пользователя (и для каждого терминала) для кэширования учетных данных, так что вы можете использовать `sudo` без пароля в течение пятнадцати минут по умолчанию. Это значение по умолчанию можно изменить, добавив параметр `timestamp_timeout` в качестве параметра по умолчанию в `/etc/sudoers` (например: `Defaults timestamp_timeout=1` установит тайм-аут кэширования учетных данных на одну минуту).


## Файл `/etc/sudoers`

Главный файл конфигурации `sudo` - `/etc/sudoers` (есть также каталог `/etc/sudoers.d`). Это место, где определяются права пользователя `sudo`. Другими словами, здесь вы укажете, кто и какие команды может выполнять, какие пользователи на каких машинах, а также другие параметры. Используемый синтаксис следующий:

```console
carol@debian:~$ sudo less /etc/sudoers
(...)
# User privilege specification
root    ALL=(ALL:ALL) ALL

# Allow members of group sudo to execute any command
%sudo   ALL=(ALL:ALL) ALL
(...)
```

Спецификация привилегий для пользователя root: `ALL=(ALL:ALL) ALL`. Это переводится как: пользователь root (`root`) может входить в систему со всех хостов (`ALL`), как все пользователи и все группы ((`ALL:ALL`)), и запускать все команды (`ALL`). То же самое верно и для членов группы `sudo` - обратите внимание, как имена групп идентифицируются предшествующим знаком процента (`%`).

Таким образом, чтобы пользователь `carol` мог проверять статус `apache2` с любого хоста в качестве любого пользователя или группы, вы добавите следующую строку в файл `sudoers`:

```console
carol   ALL=(ALL:ALL) /usr/bin/systemctl status apache2
```

Возможно, вы захотите избавить `carol` от неудобств, связанных с необходимостью указывать ее пароль для запуска команды `systemctl status apache2`. Для этого вы измените строку, чтобы она выглядела так:

```console
carol   ALL=(ALL:ALL) NOPASSWD: /usr/bin/systemctl status apache2
```

Скажем, теперь вы хотите ограничить свои хосты `192.168.1.7` и разрешить `carol` запускать `systemctl status apache2` от имени пользователя `mimi`. Вы бы изменили строку следующим образом:

```console
carol   192.168.1.7=(mimi) /usr/bin/systemctl status apache2
```

Теперь вы можете проверить статус веб-сервера Apache как пользователь `mimi`:

```console
carol@debian:~$ sudo -u mimi systemctl status apache2
● apache2.service - The Apache HTTP Server
   Loaded: loaded (/lib/systemd/system/apache2.service; enabled; vendor preset: enabled)
   Active: active (running) since Tue 2020-06-09 13:12:19 CEST; 29min ago
(...)
```

Если бы `carol` нужно было повысить до системного администратора, и вы хотели бы предоставить ей все привилегии, самым простым подходом было бы включение ее в специальную группу `sudo` с помощью `usermod` и опции `-G` (вы также можете использовать параметр `-a`, что гарантирует, что пользователь не будет удален из каких-либо других групп, к которым он может принадлежать):

```console
root@debian:~# sudo useradd -aG sudo carol
```

>В семействе дистрибутивов Red Hat группа `wheel` является аналогом специальной административной группы `sudo` систем Debian.

Вместо того, чтобы напрямую редактировать `/etc/sudoers`, вы должны просто использовать команду `visudo` от имени пользователя root (например: `visudo`), которая откроет `/etc/sudoers` с помощью вашего предопределенного текстового редактора. Чтобы изменить текстовый редактор по умолчанию, вы можете добавить параметр редактора в качестве параметра по умолчанию в `/etc/sudoers`. Например, чтобы изменить редактор на `nano`, вы добавите следующую строку:

```console
Defaults	editor=/usr/bin/nano
```

>В качестве альтернативы вы можете указать текстовый редактор через переменную среды `EDITOR` при использовании `visudo` (например: `EDITOR=/usr/bin/nano visudo`)

Помимо пользователей и групп, вы также можете использовать псевдонимы в `/etc/sudoers`. Вы можете определить три основных категории псевдонимов: *псевдонимы хоста* (`Host_Alias`), *псевдонимы пользователей* (`User_Alias`) и *псевдонимы команд* (`Cmnd_Alias`). Вот пример:

```console
# Host alias specification

Host_Alias SERVERS = 192.168.1.7, server1, server2

# User alias specification

User_Alias REGULAR_USERS = john, mary, alex

User_Alias PRIVILEGED_USERS = mimi, alex

User_Alias ADMINS = carol, %sudo, PRIVILEGED_USERS, !REGULAR_USERS

# Cmnd alias specification

Cmnd_Alias SERVICES = /usr/bin/systemctl *

# User privilege specification
root    ALL=(ALL:ALL) ALL
ADMINS  SERVERS=SERVICES

# Allow members of group sudo to execute any command
%sudo   ALL=(ALL:ALL) ALL
```

Рассматривая этот пример файла `sudoers`, давайте более подробно объясним три типа псевдонимов: 

Псевдонимы хоста  
Они включают разделенный запятыми список имен хостов, IP-адресов, а также сетей и сетевых групп (с предшествующим знаком `+`). Также можно указать сетевые маски. Псевдоним хоста `SERVERS` включает IP-адрес и два имени хоста:
```console
Host_Alias SERVERS = 192.168.1.7, server1, server2
```

Псевдонимы пользователей  
Они включают в себя список пользователей, разделенных запятыми, которые указаны как имена пользователей, группы (перед ними `%`) и сетевые группы (перед ними стоит знак `+`). Вы можете исключить определенных пользователей с помощью `!`. Псевдоним пользователя `ADMINS`, например, включает пользователя `carol`, членов группы `sudo` и тех членов псевдонима пользователя `PRIVILEGE_USERS`, которые не принадлежат псевдониму пользователя `REGULAR_USERS`:

```console
User_Alias ADMINS = carol, %sudo, PRIVILEGED_USERS, !REGULAR_USERS
```

Псевдонимы команд  
Они включают в себя список команд и каталогов, разделенных запятыми. Если каталог указан, любой файл в этом каталоге будет включен, однако подкаталоги будут проигнорированы. Псевдоним команды `SERVICES` включает одну команду со всеми ее подкомандами, как указано звездочкой (`*`):

```console
Cmnd_Alias SERVICES = /usr/bin/systemctl *
```

В результате спецификации псевдонима строка `ADMINS SERVERS=SERVICES` в разделе `User privilege specification` переводится как: все пользователи, принадлежащие к `ADMINS`, могут использовать `sudo` для выполнения любой команды в `SERVICES` на любом сервере в `SERVERS`.

>Существует четвертый тип псевдонима, который вы можете включить в `/etc/sudoers`:  *runas aliases* (`Runas_Alias`). Они очень похожи на псевдонимы пользователей, но позволяют указывать пользователей по их идентификатору пользователя (UID). Эта функция может быть удобна в некоторых сценариях.


## Упражнения для закрепления

1. Заполните следующую таблицу, касающуюся особых разрешений:  

| **Специальное разрешение** | **Числовое представление** | **Символическое представление** | **Найти файлы *только* с этим набором разрешений** |
|:---------------------------|:---------------------------|:--------------------------------|:---------------------------------------------------|
| `SUID`                     |                            |                                 |                                                    |  
| `SGID`                     |                            |                                 |                                                    |   

2. Отображение файлов только с установленным битом `SUID` или `SGID` обычно не очень практично. Выполните следующие задачи, чтобы доказать, что ваш поиск может быть более продуктивным: 
* Найдите все файлы с `SUID` (и другими разрешениями), установленными в `/usr/bin`: 
* Найдите все файлы с `SGID` (и другими разрешениями), установленными в `/usr/bin`: 
* Найдите все файлы с `SUID` или `SGID`, установленными в `/usr/bin`:
 
3. `chage` позволяет вам изменить информацию об истечении срока действия пароля пользователя. От имени пользователя root заполните следующую таблицу, указав правильные команды для пользователя `mary`:  

| **Значение** | **Команды `chage`** |
|:-------------|:--------------------|
| Сделанный пароль будет действителен 365 дней. |  |
| Заставить пользователя сменить пароль при следующем входе в систему. |  |
| Установите минимальное количество дней между сменой пароля равным 1. |  |
| Отключить истечение срока действия пароля. |  |
| Разрешить пользователю изменять свой пароль в любое время. |  |
| Установите период предупреждения на 7 дней, а срок действия учетной записи - 20 августа 2050 года. |  |
| Вывести информацию об истечении срока действия текущего пароля пользователя |  |

4. Заполните следующую таблицу с помощью соответствующей сетевой утилиты:  
| **Действие** | **Команда(ы)** |
|:-------------|:---------------|
| Показать сетевые файлы для хоста `192.168.1.55` на порту `22` с помощью `lsof`. |  |
| Показать процессы, получающие доступ к порту по умолчанию веб-сервера Apache на вашем компьютере с помощью `fuser`. |  |
| Выведите список всех прослушивающих сокетов *udp* на вашем компьютере с помощью `netstat`. |  |
| Сканируйте порты с `80` по `443` на хосте `192.168.1.55` с помощью `nmap`. |  |

5. Выполните следующие задачи, касающиеся размера *резидентного набора* (RSS) и `ulimit` как обычный пользователь: 
* Отобразить *мягкие* ограничения по *максимальному RSS*: 
* Отобразите *жесткие* ограничения на *максимальный RSS*: 
* Установите *мягкие* ограничения на *максимальный RSS* до 5000 килобайт: 
* Установите *жесткие* ограничения на *максимальный RSS* до 10 000 килобайт: 
* Наконец, попробуйте увеличить *жесткое* ограничение на *максимальный RSS* до 15 000 килобайт. Ты можешь сделать это? Почему?

6. Рассмотрите следующую `last` строку вывода команды и ответьте на вопросы:
```console
carol    pts/0        192.168.1.4      Sun May 31 14:16 - 14:22  (00:06)
```
* `carol` была подключена с удаленного хоста? Почему?
*  Как долго длилась сессия `carol`? 
*  Была ли `carol` подключена через настоящий классический текстовый терминал? Почему?

7. Рассмотрите следующий отрывок из `/etc/sudoers` и ответьте на вопрос ниже.
```console
# Host alias specification

Host_Alias SERVERS = 192.168.1.7, server1, server2

# User alias specification

User_Alias REGULAR_USERS = john, mary, alex

User_Alias PRIVILEGED_USERS = mimi, alex

User_Alias ADMINS = carol, %sudo, PRIVILEGED_USERS, !REGULAR_USERS

# Cmnd alias specification

Cmnd_Alias WEB_SERVER_STATUS = /usr/bin/systemctl status apache2

# User privilege specification
root    ALL=(ALL:ALL) ALL
ADMINS  SERVERS=WEB_SERVER_STATUS

# Allow members of group sudo to execute any command
%sudo   ALL=(ALL:ALL) ALL
```
Может ли `alex` проверить статус веб-сервера Apache на любом хосте? Почему?


## Упражнения на размышление

1. Помимо SUID и SGID, есть третье специальное разрешение: *sticky bit*. В настоящее время он в основном используется в таких каталогах, как `/tmp`, чтобы обычные пользователи не могли удалять или перемещать файлы, кроме их собственных. Выполните следующие задачи: 
* Установите *липкий бит* на `~/temporal`: 
* Найдите каталоги с *липким битом* (и любыми другими разрешениями), установленным в вашем домашнем каталоге: 
* Отключите *липкий бит* на `~/temporal`: 

2. Когда пароль пользователя заблокирован с помощью `passwd -l username` или `usermod -L username`, как вы можете определить это, заглянув в `/etc/shadow`? 

3. Что является эквивалентом команды `usermod` для имени пользователя `chage -E date username` или `chage --expiredate date username`? 

4. Предоставьте две разные команды `nmap` для сканирования всех портов 65535 на локальном хосте:


## Резюме

В этом уроке вы узнали, как выполнять ряд задач по администрированию безопасности. Были рассмотрены следующие темы: 
* Поиск файлов со специальными установленными правами доступа SUID и SGID. 
* Установка и изменение паролей пользователей и работа с информацией об устаревании паролей. 
* Использование ряда сетевых утилит для обнаружения открытых портов на хостах/сетях. 
* Установка лимитов на системные ресурсы. 
* Проверка пользователей, которые входили в систему или в настоящее время вошли в систему. 
* Базовое использование и настройка `sudo` (через файл `/etc/sudoers`). 

Команды и файлы, обсуждаемые в этом уроке: 

`find`  
Поиск файлов в иерархии каталогов. 

`passwd`  
Сменить пароль пользователя. 

`chmod`  
Изменение битов прав доступа файла. 

`chage`  
Изменение информации об истечении срока действия пароля пользователя. 

`lsof`  
Список открытых файлов. 

`fuser`  
Идентифицирует процессы с помощью файлов или сокетов. 

`netstat`  
Распечатает сетевые подключения. 

`nmap`  
Инструмент исследования сети и сканер портов. 

`ulimit`  
Получение и установка ограничений для пользователей. 

`/etc/security/limits.conf`  
Файл конфигурации для применения ограничений для пользователей. 

`last`  
Выводит на экран список последних авторизованных пользователей. 

`lastb`  
Выводит на экран список неудачных попыток входа в систему. 

`/var/log/wtmp`  
База данных входов пользователей в систему. 

`who`  
Показывает, кто вошел в систему. 

`w`  
Показывает, кто вошел в систему и что они делают. 

`su`  
Изменение пользователя или войти как суперпользователь. 

`sudo`  
Выполнить команду от имени другого пользователя (включая суперпользователя). 

`/etc/sudoers`  
Файл конфигурации по умолчанию для политики безопасности `sudo`.


## Ответы на упражнения для закрепления

**1. Заполните следующую таблицу, касающуюся особых разрешений:**
| **Специальное разрешение** | **Числовое представление** | **Символическое представление** | **Найти файлы *только* с этим набором разрешений** |
|:---------------------------|:---------------------------|:--------------------------------|:---------------------------------------------------|
| SUID                       |          `4000`            |             `s`, `S`            |         `find -perm 4000, find -perm u+s`          |  
| SGID                       |          `2000`            |             `s`, `S`            |         `find -perm 2000, find -perm g+s`          |   

**2. Отображение файлов *только* с установленным битом `SUID` или `SGID` обычно не очень практично. Выполните следующие задачи, чтобы доказать, что ваш поиск может быть более продуктивным:**  
* Найдите все файлы с `SUID` (и другими разрешениями), установленными в `/usr/bin`:  
`find /usr/bin -perm -4000` или `find /usr/bin -perm -u+s`
* Найдите все файлы с `SGID` (и другими разрешениями), установленными в `/usr/bin`: 
`find /usr/bin -perm -2000` или `find /usr/bin -perm -g+s`
* Найдите все файлы с `SUID` или `SGID`, установленными в `/usr/bin`:
`find /usr/bin -perm /6000` 
 
**3. `chage` позволяет вам изменить информацию об истечении срока действия пароля пользователя. От имени пользователя root заполните следующую таблицу, указав правильные команды для пользователя `mary`:**

| **Значение** | **Команды `chage`** |
|:-------------|:--------------------|
| Сделанный пароль будет действителен 365 дней. |  | 
| Заставить пользователя сменить пароль при следующем входе в систему. |  |
| Установите минимальное количество дней между сменой пароля равным 1. |  |
| Отключить истечение срока действия пароля. |  |
| Разрешить пользователю изменять свой пароль в любое время. |  |
| Установите период предупреждения на 7 дней, а срок действия учетной записи - 20 августа 2050 года. |  |
|Распечатать информацию об истечении срока действия текущего пароля пользователя |  |

**4. Заполните следующую таблицу с помощью соответствующей сетевой утилиты:**  
| **Действие** | **Команда(ы)** |
|:-------------|:---------------|
| Показать сетевые файлы для хоста `192.168.1.55` на порту `22` с помощью `lsof`. |  |
| Показать процессы, получающие доступ к порту по умолчанию веб-сервера Apache на вашем компьютере с помощью `fuser`. |  |
| Выведите список всех прослушивающих сокетов *udp* на вашем компьютере с помощью `netstat`. |  |
| Сканируйте порты с `80` по `443` на хосте `192.168.1.55` с помощью `nmap`. |  |

**5. Выполните следующие задачи, касающиеся размера *резидентного набора (RSS)* и `ulimit` как обычный пользователь:**  
* Отобразить *мягкие* ограничения по *максимальному RSS*: 
* Отобразите *жесткие* ограничения на *максимальный RSS*: 
* Установите *мягкие* ограничения на *максимальный RSS* до 5000 килобайт: 
* Установите *жесткие* ограничения на *максимальный RSS* до 10 000 килобайт: 
* Наконец, попробуйте увеличить *жесткое* ограничение на *максимальный RSS* до 15 000 килобайт. Ты можешь сделать это? Почему?

**6. Рассмотрите следующую `last` строку вывода команды и ответьте на вопросы:**  
```console
carol    pts/0        192.168.1.4      Sun May 31 14:16 - 14:22  (00:06)
```
* `carol` была подключена с удаленного хоста? Почему?
*  Как долго длилась сессия `carol`? 
*  Была ли `carol` подключена через настоящий классический текстовый терминал? Почему?

**7. Рассмотрите следующий отрывок из `/etc/sudoers` и ответьте на вопрос ниже.**
```console
# Host alias specification

Host_Alias SERVERS = 192.168.1.7, server1, server2

# User alias specification

User_Alias REGULAR_USERS = john, mary, alex

User_Alias PRIVILEGED_USERS = mimi, alex

User_Alias ADMINS = carol, %sudo, PRIVILEGED_USERS, !REGULAR_USERS

# Cmnd alias specification

Cmnd_Alias WEB_SERVER_STATUS = /usr/bin/systemctl status apache2

# User privilege specification
root    ALL=(ALL:ALL) ALL
ADMINS  SERVERS=WEB_SERVER_STATUS

# Allow members of group sudo to execute any command
%sudo   ALL=(ALL:ALL) ALL
```
Может ли `alex` проверить статус веб-сервера Apache на любом хосте? Почему?


## Ответы на упражнения для размышления
