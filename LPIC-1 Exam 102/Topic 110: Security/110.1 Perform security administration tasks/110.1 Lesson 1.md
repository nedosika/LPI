# 110.1 Урок 1

| **Сертификат:** | LPIC-1                                      |
|:----------------|:--------------------------------------------|
| **Версия:**     | 5.0                                         |
| **Тема:**       | 110 Безопасность                            |                           
| **Цель:**       | 110.1 Выполнять задачи администрирования безопасности |
| **Урок:**       | 1 из 1                                      |


## Введение

Безопасность является обязательным условием системного администрирования. Как хороший системный администратор Linux, вы должны следить за рядом вещей, таких как особые права доступа к файлам, устаревание пароля пользователя, открытые порты и сокеты, ограничение использования системных ресурсов, работа с вошедшими в систему пользователями и повышение привилегий с помощью `su` и `sudo`. В этом уроке мы рассмотрим каждую из этих тем.


## Проверка файлов с установленными SUID и SGID

Помимо традиционного набора прав на *чтение*, *запись* и *выполнение*, файлы в системе Linux также могут иметь некоторые специальные права, такие как биты SUID или SGID. 

Бит SUID позволяет запускать файл с привилегиями владельца файла. Он численно представлен `4000` и символически представлен либо `s`, либо `S` в бите права на *выполнение* владельцем. Классическим примером исполняемого файла с набором разрешений SUID является `passwd`:

```console
carol@debian:~$ ls -l /usr/bin/passwd
-rwsr-xr-x 1 root root 63736 jul 27  2018 /usr/bin/passwd
```

Строчная буква `s` в `rws` указывает на наличие SUID в файле вместе с разрешением на выполнение. Вместо этого заглавная буква `S` (`rwS`) будет означать, что базовое право на *выполнение* не установлено.

>Вы узнаете о `passwd` в следующем разделе. Утилита в основном используется `root` для установки/изменения паролей пользователей (например: `passwd carol`). Однако обычные пользователи могут использовать его и для изменения собственных паролей. Поэтому он поставляется с набором SUID.

С другой стороны, бит SGID может быть установлен как для файлов, так и для каталогов. С файлами его поведение эквивалентно поведению SUID, но привилегии принадлежат владельцу группы. Однако, если он установлен в каталоге, он позволит всем файлам, созданным в нем, унаследовать право собственности на группу каталога. Как и SUID, SGID символически представлен либо `s`, либо `S` в бите права на выполнение группы. Численно он представлен как `2000`. Вы можете установить SGID для каталога с помощью `chmod`. Вы должны добавить `2` (SGID) к традиционным правам (в нашем случае `755`):

```console
carol@debian:~$ ls -ld shared_directory
drwxr-xr-x 2 carol carol 4096 may 30 23:55 shared_directory
carol@debian:~$ sudo chmod 2755 shared_directory/
carol@debian:~$ ls -ld shared_directory
drwxr-sr-x 2 carol carol 4096 may 30 23:55 shared_directory
```

Чтобы найти файлы с одним или обоими установленными SUID и SGID, вы можете использовать команду `find` и использовать параметр `-perm`. Вы можете использовать как числовые, так и символьные значения. Значения, в свою очередь, могут передаваться сами по себе или им предшествовать дефис (`-`) или косая черта (`/`). Смысл в следующем: 

`-perm numeric-vaue` или `-perm symbolic-value`  
находить файлы исключительно со специальным разрешением 

`-perm -numeric-value` или `-perm -symbolic-value`  
найти файлы со специальными правами доступа и другими правами 

`-perm / numeric-value` или `-perm / symbolic-value`  
найти файлы, имеющие какое-либо из специальных прав доступа (и других прав доступа) 

Например, чтобы найти файлы, в текущем рабочем каталоге которых установлен только SUID, вы воспользуетесь следующей командой:

```console
carol@debian:~$ find . -perm 4000
carol@debian:~$ touch file
carol@debian:~$ chmod 4000 file
carol@debian:~$ find . -perm 4000
./file.
```

Обратите внимание, как - поскольку не было никаких файлов, имеющих исключительно SUID, - мы создали его, чтобы показать некоторые результаты. Вы можете запустить ту же команду в символической записи:

```console
carol@debian:~$ find . -perm u+s
./file
```

Чтобы найти файлы, соответствующие SUID (независимо от других разрешений) в каталоге `/usr/bin/`, вы можете использовать любую из следующих команд:

```console
carol@debian:~$ sudo find /usr/bin -perm -4000
/usr/bin/umount
/usr/bin/newgrp
/usr/bin/gpasswd
/usr/bin/chfn
/usr/bin/mount
/usr/bin/passwd
/usr/bin/chsh
/usr/bin/sudo
/usr/bin/su
carol@debian:~$ sudo find /usr/bin -perm -u+s
/usr/bin/umount
/usr/bin/newgrp
/usr/bin/gpasswd
/usr/bin/chfn
/usr/bin/mount
/usr/bin/passwd
/usr/bin/chsh
/usr/bin/sudo
/usr/bin/su
```

Если вы ищете файлы в том же каталоге с установленным битом SGID, вы можете выполнить `find /usr/bin/ -perm -2000` или `find /usr/bin/ -perm -g +s`. 

Наконец, чтобы найти файлы с одним из двух специальных разрешений, добавьте `4` и `2` и используйте `/`:

```console
carol@debian:~$ sudo find /usr/bin -perm /6000
/usr/bin/dotlock.mailutils
/usr/bin/umount
/usr/bin/newgrp
/usr/bin/wall
/usr/bin/ssh-agent
/usr/bin/chage
/usr/bin/dotlockfile
/usr/bin/gpasswd
/usr/bin/chfn
/usr/bin/mount
/usr/bin/passwd
/usr/bin/chsh
/usr/bin/expiry
/usr/bin/sudo
/usr/bin/bsd-write
/usr/bin/crontab
/usr/bin/su
```


## Управление паролями и устаревание

Как отмечалось выше, вы можете использовать утилиту `passwd`, чтобы изменить свой пароль как обычный пользователь. Кроме того, вы можете передать ключ `-S` или `--status`, чтобы получить информацию о статусе вашей учетной записи:

```console
carol@debian:~$ passwd -S
carol P 12/07/2019 0 99999 7 -1
```

Вот разбивка семи полей, которые вы получаете в выводе: 

`carol`  
Логин пользователя. 

`p`  
Это указывает на то, что у пользователя есть действующий пароль (`P`); другие возможные значения: `L` для заблокированного пароля и `NP` для отсутствия пароля. 

`07.12.2019`  
Дата последней смены пароля. 

`0`  
Минимальный возраст в днях (минимальное количество дней между сменой пароля). Значение `0` означает, что пароль можно изменить в любое время. 

`99999`  
Максимальный возраст в днях (максимальное количество дней, в течение которых действует пароль). Значение `99999` отключит истечение срока действия пароля. 

`7`  
Период предупреждения в днях (количество дней до истечения срока действия пароля, о котором пользователь будет предупрежден). 

`-1`  
Период неактивности пароля в днях (количество дней бездействия после истечения срока действия пароля до блокировки учетной записи). Значение `-1` удалит неактивность аккаунта. 

Помимо отчетов о состоянии учетной записи, вы будете использовать команду `passwd` как root для выполнения некоторых основных операций по обслуживанию учетной записи. Вы можете заблокировать и разблокировать учетные записи, заставить пользователя изменить свой пароль при следующем входе в систему и удалить пароль пользователя с помощью параметров `-l`, `-u`, `-e` и `-d` соответственно. 

Чтобы проверить эти параметры, здесь удобно ввести команду `su`. С помощью `su` вы можете менять пользователей во время сеанса входа в систему. Так, например, давайте использовать `passwd` как root, чтобы заблокировать пароль `carol`. Затем мы переключимся на `carol` и проверим статус нашей учетной записи, чтобы убедиться, что пароль фактически заблокирован (`L`) и не может быть изменен. Наконец, вернувшись к пользователю root, мы разблокируем пароль `carol`:

```console
root@debian:~# passwd -l carol
passwd: password expiry information changed.
root@debian:~# su - carol
carol@debian:~$ passwd -S
carol L 05/31/2020 0 99999 7 -1
carol@debian:~$ passwd
Changing password for carol.
Current password:
passwd: Authentication token manipulation error
passwd: password unchanged
carol@debian:~$ exit
logout
root@debian:~# passwd -u carol
passwd: password expiry information changed.
```

Кроме того, вы также можете заблокировать и разблокировать пароль пользователя с помощью команды `usermod`: 

Заблокировать пароль пользователя `carol`  
`usermod -L carol` или `usermod --lock carol`. 

Разблокировать пароль пользователя `carol`  
`usermod -U carol` или `usermod --unlock carol`.

>С переключателями `-f` или `--inactive` можно также использовать `usermod` для установки количества дней до отключения учетной записи с просроченным паролем (например: `usermod -f 3 carol`).

Помимо `passwd` и `usermod`, самая прямая команда для работы с паролем и устареванием учетной записи - `chage` («изменить возраст»). Как root, вы можете передать `chage` ключ `-l` (или `--list`), за которым следует имя пользователя, чтобы на экране был напечатан текущий пароль этого пользователя и информация об истечении срока действия учетной записи; как обычный пользователь, вы можете просматривать свою информацию:

```console
carol@debian:~$ chage -l carol
Last password change					: Aug 06, 2019
Password expires					: never
Password inactive					: never
Account expires						: never
Minimum number of days between password change		: 0
Maximum number of days between password change		: 99999
Number of days of warning before password expires	: 7
```

Запустить без параметров и только после имени пользователя, `chage` будет вести себя в интерактивном режиме:

```console
root@debian:~# chage carol
Changing the aging information for carol
Enter the new value, or press ENTER for the default

	Minimum Password Age [0]:
	Maximum Password Age [99999]:
	Last Password Change (YYYY-MM-DD) [2020-06-01]:
	Password Expiration Warning [7]:
	Password Inactive [-1]:
	Account Expiration Date (YYYY-MM-DD) [-1]:
```

Возможны следующие варианты изменения различных настроек `chage`: 

`-m days username` или `--mindays days username`  
Укажите минимальное количество дней между сменой пароля (например: `chage -m 5 carol`). Значение `0` позволит пользователю изменить свой пароль в любое время. 

`-M days username` или `--maxdays username`  
Укажите максимальное количество дней, в течение которых пароль будет действителен (например: `chage -M 30 carol`). Чтобы отключить истечение срока действия пароля, обычно задают этой опции значение `99999`. 

`-d days username` или `--lastday days username`  
Укажите количество дней с момента последней смены пароля (например: `chage -d 10 carol`). Значение `0` заставит пользователя сменить пароль при следующем входе в систему. 

`-W days username` или `--warndays days username`  
Укажите количество дней, в течение которых пользователю будут напоминать об истечении срока действия пароля. 

`-I days username` или `--inactive days username`  
Укажите количество дней бездействия после истечения срока действия пароля (например: `chage -I 10 carol`) - так же, как `usermod -f` или `usermod --inactive`. По прошествии указанного количества дней учетная запись будет заблокирована. Однако при значении `0` учетная запись не будет заблокирована. 

`-E date username` или `--expiredate date username`  
Укажите дату (или количество дней с эпохи - 1 января 1970 г.), в которую учетная запись будет заблокирована. Обычно он выражается в формате `YYYY-MM-DD`(например: `chage -E 2050-12-13 carol`).

>Вы можете узнать больше о `passwd`, `usermod` и `chage` - и их опциях - на соответствующих страницах руководства. 


## Обнаружение открытых портов

Когда дело доходит до отслеживания открытых портов, в большинстве систем Linux присутствуют четыре мощные утилиты: `lsof`, `fuser`, `netstat` и `nmap`. Мы рассмотрим их в этом разделе. 

`lsof` означает «список открытых файлов», что немаловажно, учитывая, что для Linux все является файлом. Фактически, если вы введете `lsof` в терминал, вы получите большой список обычных файлов, файлов устройств, сокетов и т. д. Однако в рамках этого урока мы в основном сосредоточимся на портах. Чтобы распечатать список всех сетевых файлов «Интернет», запустите `lsof` с параметром `-i`:

```console
root@debian:~# lsof -i
COMMAND  PID     USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
dhclient 357     root    7u  IPv4  13493      0t0  UDP *:bootpc
sshd     389     root    3u  IPv4  13689      0t0  TCP *:ssh (LISTEN)
sshd     389     root    4u  IPv6  13700      0t0  TCP *:ssh (LISTEN)
apache2  399     root    3u  IPv6  13826      0t0  TCP *:http (LISTEN)
apache2  401 www-data    3u  IPv6  13826      0t0  TCP *:http (LISTEN)
apache2  402 www-data    3u  IPv6  13826      0t0  TCP *:http (LISTEN)
sshd     557     root    3u  IPv4  14701      0t0  TCP 192.168.1.7:ssh->192.168.1.4:60510 (ESTABLISHED)
sshd     569    carol    3u  IPv4  14701      0t0  TCP 192.168.1.7:ssh->192.168.1.4:60510 (ESTABLISHED)
```

Помимо службы `bootpc`, которая используется DHCP, на выходе показаны две службы, прослушивающие соединения - `ssh` и веб-сервер Apache (`http`), а также два установленных SSH-соединения. Вы можете указать конкретный хост с обозначением `@ip-address`, чтобы проверить его соединения:

```console
root@debian:~# lsof -i@192.168.1.7
COMMAND PID  USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
sshd    557  root    3u  IPv4  14701      0t0  TCP 192.168.1.7:ssh->192.168.1.4:60510 (ESTABLISHED)
sshd    569 carol    3u  IPv4  14701      0t0  TCP 192.168.1.7:ssh->192.168.1.4:60510 (ESTABLISHED)
```

>Чтобы вывести только сетевые файлы IPv4 и IPv6, используйте параметры `-i4` и `-i6` соответственно.

Точно так же вы можете фильтровать по портам, передав параметр `-i` (или `-i @*ip-address*`) в аргумент `:port`:

```console
root@debian:~# lsof -i :22
COMMAND PID  USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
sshd    389  root    3u  IPv4  13689      0t0  TCP *:ssh (LISTEN)
sshd    389  root    4u  IPv6  13700      0t0  TCP *:ssh (LISTEN)
sshd    557  root    3u  IPv4  14701      0t0  TCP 192.168.1.7:ssh->192.168.1.4:60510 (ESTABLISHED)
sshd    569 carol    3u  IPv4  14701      0t0  TCP 192.168.1.7:ssh->192.168.1.4:60510 (ESTABLISHED)
```

Несколько портов разделяются запятыми (а диапазоны указываются через тире):

```console
root@debian:~# lsof -i@192.168.1.7:22,80
COMMAND PID  USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
sshd    705  root    3u  IPv4  13960      0t0  TCP 192.168.1.7:ssh->192.168.1.4:44766 (ESTABLISHED)
sshd    718 carol    3u  IPv4  13960      0t0  TCP 192.168.1.7:ssh->192.168.1.4:44766 (ESTABLISHED)
```

Количество опций, доступных для `lsof`, впечатляет. Чтобы узнать больше, обратитесь к его странице руководства.

Следующим в списке сетевых команд идет `fuser`. Его основная цель - найти «пользователя файла», что включает в себя знание того, какие процессы к каким файлам обращаются; он также дает вам некоторую другую информацию, такую как тип доступа. Например, чтобы проверить текущий рабочий каталог, достаточно запустить `fuser`. Однако, чтобы получить немного больше информации, удобно использовать подробный параметр (`-v` или `--verbose`):

```console
root@debian:~# fuser .
/root:                 580c
root@debian:~# fuser -v .
                     USER        PID ACCESS COMMAND
/root:               root        580 ..c.. bash
```

Разберем вывод: 

`File`  
Файл, о котором мы получаем информацию (`/root`). 

`USER` столбец  
Владелец файла (`root`). 

Столбец `PID`  
Идентификатор процесса (`580`).  

Столбец `ACCESS`  
Тип доступа (`..c ..`). Один из:  
`c`  
Текущий каталог. 

`е`  
Исполняемый файл запущен. 

`f`  
Открыть файл (опускается в режиме отображения по умолчанию). 

`F`  
Открыть файл для записи (опускается в режиме отображения по умолчанию). 

`r`  
корневая директория. 

`m`  
размеченный файл или общая библиотека. 

`.`  
Заполнитель (опускается в режиме отображения по умолчанию). 

Столбец `COMMAND`  
Команда, связанная с файлом (`bash`). 

С параметром `-n` (или `--namespace`) вы можете найти информацию о сетевых портах/сокетах. Вы также должны указать сетевой протокол и номер порта. Таким образом, чтобы получить информацию о веб-сервере Apache, вы выполните следующую команду:

```console
root@debian:~# fuser -vn tcp 80
                     USER        PID ACCESS COMMAND
80/tcp:              root        402 F.... apache2
                     www-data    404 F.... apache2
                     www-data    405 F.... apache2
```

>`fuser` также можно использовать для уничтожения процессов, обращающихся к файлу, с помощью переключателей `-k` или `--kill` (например: `fuser -k 80/tcp`). Обратитесь к странице руководства для получения более подробной информации.

Теперь обратимся к `netstat`. `netstat` - очень универсальный сетевой инструмент, который в основном используется для вывода на экран «сетевой статистики». 

При запуске без параметров `netstat` отобразит как активные подключения к Интернету, так и сокеты Unix. Из-за размера листинга вы можете захотеть передать его вывод через `less`:

```console
carol@debian:~$ netstat |less
Active Internet connections (w/o servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State
tcp        0      0 192.168.1.7:ssh         192.168.1.4:55444       ESTABLISHED
Active UNIX domain sockets (w/o servers)
Proto RefCnt Flags       Type       State         I-Node   Path
unix  2      [ ]         DGRAM                    10509    /run/systemd/journal/syslog
unix  3      [ ]         DGRAM                    10123    /run/systemd/notify
(...)
```

Чтобы перечислить только «прослушивающие» порты и сокеты, воспользуетесь параметрами `-l` или `--listening`. Параметры `-t`/`-tcp` и `-u`/`-udp` могут быть добавлены для фильтрации по протоколу TCP и UDP соответственно (их также можно объединить в одной команде). Точно так же `-e`/`-extend` отобразит дополнительную информацию:

```console
carol@debian:~$ netstat -lu
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State
udp        0      0 0.0.0.0:bootpc          0.0.0.0:*
carol@debian:~$ netstat -lt
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State
tcp        0      0 0.0.0.0:ssh             0.0.0.0:*               LISTEN
tcp        0      0 localhost:smtp          0.0.0.0:*               LISTEN
tcp6       0      0 [::]:http               [::]:*                  LISTEN
tcp6       0      0 [::]:ssh                [::]:*                  LISTEN
tcp6       0      0 localhost:smtp          [::]:*                  LISTEN
carol@debian:~$ netstat -lute
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       User       Inode
tcp        0      0 0.0.0.0:ssh             0.0.0.0:*               LISTEN      root       13729
tcp        0      0 localhost:smtp          0.0.0.0:*               LISTEN      root       14372
tcp6       0      0 [::]:http               [::]:*                  LISTEN      root       14159
tcp6       0      0 [::]:ssh                [::]:*                  LISTEN      root       13740
tcp6       0      0 localhost:smtp          [::]:*                  LISTEN      root       14374
udp        0      0 0.0.0.0:bootpc          0.0.0.0:*                           root       13604
```

Если вы опустите опцию `-l`, будут показаны только установленные соединения:

```console
carol@debian:~$ netstat -ute
Active Internet connections (w/o servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       User       Inode
tcp        0      0 192.168.1.7:ssh         192.168.1.4:39144       ESTABLISHED root       15103
```

Если вас интересует только числовая информация о портах и хостах, вы можете использовать опцию `-n` или `--numeric` для печати только номеров портов и IP-адресов. Обратите внимание, как `ssh` превращается в `22` при добавлении `-n` к приведенной выше команде:

```console
carol@debian:~$ netstat -uten
Active Internet connections (w/o servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       User       Inode
tcp        0      0 192.168.1.7:22          192.168.1.4:39144       ESTABLISHED 0          15103
```

Как видите, вы можете создавать очень полезные и продуктивные команды `netstat`, комбинируя некоторые из его параметров. Просмотрите страницы руководства, чтобы узнать больше и найти комбинации, которые лучше всего соответствуют вашим потребностям. 

Наконец, мы представим `nmap` - «сетевой картограф». Еще одна очень мощная утилита, этот сканер портов, запускается путем указания IP-адреса или имени хоста:

```console
root@debian:~# nmap localhost
Starting Nmap 7.70 ( https://nmap.org ) at 2020-06-04 19:29 CEST
Nmap scan report for localhost (127.0.0.1)
Host is up (0.0000040s latency).
Other addresses for localhost (not scanned): ::1
Not shown: 998 closed ports
PORT   STATE SERVICE
22/tcp open  ssh
80/tcp open  http

Nmap done: 1 IP address (1 host up) scanned in 1.58 seconds
```

Помимо одного хоста, `nmap` позволяет сканировать: 

несколько хостов  
разделив их пробелами (например: `nmap localhost 192.168.1.7`). 

диапазоны хостов  
с помощью тире (например, `nmap 192.168.1.3-20`). 

подсети  
с использованием подстановочного знака или нотации CIDR (например, `nmap 192.168.1.*` или `nmap 192.168.1.0/24`). 

Вы можете исключить определенные хосты (например: `nmap 192.168.1.0/24 --exclude 192.168.1.7`). Чтобы просканировать конкретный порт, используйте параметр `-p`, за которым следует номер порта или имя службы (`nmap -p 22` и `nmap -p ssh` дадут вам тот же результат):

```console
root@debian:~# nmap -p 22 localhost
Starting Nmap 7.70 ( https://nmap.org ) at 2020-06-04 19:54 CEST
Nmap scan report for localhost (127.0.0.1)
Host is up (0.000024s latency).
Other addresses for localhost (not scanned): ::1

PORT   STATE SERVICE
22/tcp open  ssh

Nmap done: 1 IP address (1 host up) scanned in 0.22 seconds
```

Вы также можете сканировать несколько портов или диапазонов портов, используя запятые и тире соответственно:

```console
root@debian:~# nmap -p ssh,80 localhost
Starting Nmap 7.70 ( https://nmap.org ) at 2020-06-04 19:58 CEST
Nmap scan report for localhost (127.0.0.1)
Host is up (0.000051s latency).
Other addresses for localhost (not scanned): ::1

PORT   STATE SERVICE
22/tcp open  ssh
80/tcp open  http

Nmap done: 1 IP address (1 host up) scanned in 0.22 seconds
```
```console
root@debian:~# nmap -p 22-80 localhost
Starting Nmap 7.70 ( https://nmap.org ) at 2020-06-04 19:58 CEST
Nmap scan report for localhost (127.0.0.1)
Host is up (0.000011s latency).
Other addresses for localhost (not scanned): ::1
Not shown: 57 closed ports
PORT   STATE SERVICE
22/tcp open  ssh
80/tcp open  http

Nmap done: 1 IP address (1 host up) scanned in 1.47 seconds
```

Два других важных и удобных параметра `nmap`: 

`-F`  
Выполнит быстрое сканирование 100 наиболее распространенных портов. 

`-v`  
Подробный вывод (`-vv` выведет еще более подробный вывод).

>`nmap` может запускать довольно сложные команды, используя типы сканирования. Однако эта тема выходит за рамки этого урока.


## Ограничения на вход в систему, процессы и использование памяти

Ресурсы в системе Linux не безграничны, поэтому - как системный администратор - вы должны обеспечить хороший баланс между *пользовательскими ограничениями* на ресурсы и правильным функционированием операционной системы. `ulimit` может помочь вам в этом отношении. 

`ulimit` имеет дело с *мягкими* и *жесткими* ограничениями, задаваемыми параметрами `-S` и `-H` соответственно. При запуске без параметров или аргументов `ulimit` отобразит программные блоки файлов текущего пользователя:

```console
carol@debian:~$ ulimit
unlimited
```

С параметром `-a ulimit` покажет все текущие мягкие ограничения (так же, как `-Sa`); чтобы отобразить все текущие жесткие ограничения, используйте `-Ha`:

```console
carol@debian:~$ ulimit -a
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
(...)
carol@debian:~$ ulimit -Ha
core file size          (blocks, -c) unlimited
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
(...)
```

Доступные ресурсы оболочки указываются такими параметрами, как: 

`-b`  
максимальный размер буфера сокета 

`-f`  
максимальный размер файлов, записываемых оболочкой и ее дочерними элементами 

`-l`  
максимальный размер, который может быть заблокирован в памяти 

`-m`  
максимальный размер резидентного набора (RSS) - текущая часть памяти, удерживаемая процессом в основной памяти (RAM) 

`-v`  
максимальный объем виртуальной памяти 

`-u`  
максимальное количество процессов, доступных одному пользователю 

Таким образом, для отображения ограничений вы будете использовать `ulimit`, за которым следует `-S` (мягкий) или `-H` (жесткий) и параметр ресурса; если не указаны ни `-S`, ни `-H`, будут показаны мягкие ограничения:

```console
carol@debian:~$ ulimit -u
10000
carol@debian:~$ ulimit -Su
10000
carol@debian:~$ ulimit -Hu
15672
```

Аналогичным образом, чтобы установить новые ограничения для конкретного ресурса, вы должны указать либо `-S`, либо `-H`, за которым следует соответствующая опция ресурса и новое значение. Это значение может быть числом или специальными словами `soft` (текущий мягкий предел), `hard` (текущий жесткий предел) или `unlimited` (без ограничения). Если не указано ни `-S`, ни `-H`, будут установлены оба предела. Например, давайте сначала прочитаем текущее значение максимального размера для файлов, записанных оболочкой и ее дочерними элементами:

```console
root@debian:~# ulimit -Sf
unlimited
root@debian:~# ulimit -Hf
unlimited
```

Теперь давайте изменим значение с `unlimited` на `500` блоков без указания `-S` или `-H`. Обратите внимание, как меняются как мягкие, так и жесткие ограничения:

```console
root@debian:~# ulimit -f 500
root@debian:~# ulimit -Sf
500
root@debian:~# ulimit -Hf
500
```

Наконец, мы уменьшим только мягкий лимит до `200` блоков:

Жесткие ограничения могут быть увеличены только пользователем root. С другой стороны, обычные пользователи могут уменьшить жесткие ограничения и увеличить мягкие ограничения до значения жестких ограничений. Чтобы новые предельные значения сохранялись при перезагрузках, вы должны записать их в файл `/etc/security/limits.conf`. Это также файл, используемый администратором для наложения ограничений на определенных пользователей.

>Имейте в виду, что man-страницы `ulimit` как таковой не существует. Это встроенная функция bash, поэтому вам нужно обратиться к странице руководства bash, чтобы узнать о ней.


## Работа с вошедшими в систему пользователями

Другая ваша работа в качестве системного администратора - это отслеживание пользователей, вошедших в систему. Есть три утилиты, которые могут помочь вам с этими задачами: `last`, `who` и `w`. 

`last` выводит на экран список последних вошедших в систему пользователей с самой последней информацией вверху:

```console
root@debian:~# last
carol    pts/0        192.168.1.4      Sat Jun  6 14:25   still logged in
reboot   system boot  4.19.0-9-amd64   Sat Jun  6 14:24   still running
mimi     pts/0        192.168.1.4      Sat Jun  6 12:07 - 14:24  (02:16)
reboot   system boot  4.19.0-9-amd64   Sat Jun  6 12:07 - 14:24  (02:17)
(...)
wtmp begins Sun May 31 14:14:58 2020
```

Рассматривая усеченный листинг, мы получаем информацию о двух последних пользователях в системе. Первые две строки рассказывают нам о пользователе `carol`; следующие две строчки о пользователе `mimi`. Информация следующая: 
1. Пользователь `carol` на терминале `pts/0` с хоста `192.168.1.4` начал сеанс в `Sat Jun 6` в `14:25` и все еще `logged in`. Система - с использованием ядра `4.19.0-9-amd64` - была запущена (`reboot system boot`) в `Sat Jun 6` в `14:24`, `still running`. 
2. Пользователь `mimi` на терминале `pts/0` с хоста `192.168.1.4` начал сеанс в `Sat Jun 6` в `12:07` и вышел из системы в `14:24` (сеанс длился в общей сложности (`02:16`) часов). Система - с использованием ядра `4.19.0-9-amd64` - была запущена (`reboot system boot`) в `Sat Jun 6` в `12:07` и выключена в `14:24` (она работала в течение (`02:17`) часов) .

>Строка `wtmpwtmp begins Sun May 31 14:14:58 2020`, относится к `/var/log/wtmp`, который является специальным файлом журнала, из которого последний раз получает информацию.

Вы можете передать `last` имя пользователя, чтобы отображались только записи для этого пользователя:

```console
root@debian:~# last carol
carol    pts/0        192.168.1.4      Sat Jun  6 14:25   still logged in
carol    pts/0        192.168.1.4      Sat Jun  6 12:07 - 14:24  (02:16)
carol    pts/0        192.168.1.4      Fri Jun  5 00:48 - 01:28  (00:39)
(...)
```

Что касается второго столбца (терминала), `pts` обозначает псевдотерминальное ведомое устройство - в отличие от правильного *TeleTYpewriter* или `tty`-терминала; `0` относится к первому (счет начинается с нуля).

>Чтобы проверить неудачные попытки входа в систему, запустите `lastb` вместо `last`

Утилиты `who` и `w` ориентированы на пользователей, вошедших в систему в данный момент, и очень похожи. Первая показывает, кто вошел в систему, а вторая также показывает информацию о том, что они делают. 

При выполнении без параметров, `who` будет отображать четыре столбца, соответствующие зарегистрированному пользователю, терминалу, дате и времени и имени хоста:

```console
root@debian:~# who
carol    pts/0        2020-06-06 17:16 (192.168.1.4)
mimi     pts/1        2020-06-06 17:28 (192.168.1.4)
```

`who` принимает ряд вариантов, среди которых можно выделить следующие: 

`-b`, `--boot`  
Отображение времени последней загрузки системы. 

`-r`, `--runlevel`  
Показать текущий уровень выполнения. 

`-H`, `-heading`  
Печатать заголовки столбцов. 

По сравнению с `who`, `w` дает более подробный вывод:

```console
root@debian:~# w
 17:56:12 up 40 min,  2 users,  load average: 0.04, 0.12, 0.09
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
carol    pts/0    192.168.1.4    17:16    1.00s  0.15s  0.05s sshd: carol [priv]
mimi     pts/1    192.168.1.4    17:28   15:08   0.05s  0.05s -bash
```

В верхней строке представлена информация о текущем времени (`17:56:12`), о том, как долго система была запущена и работала (`up 40 min`), о количестве пользователей, вошедших в систему в данный момент (`2 users`) и средних  нагрузках (`load average: 0.04, 0.12, 0.09`). Эти значения относятся к числу заданий в очереди выполнения, усредненному за последние 1, 5 и 15 минут соответственно. 

Затем вы находите восемь столбцов; давайте разберем их: 

`USER`  
Логин пользователя. 

`TTY`  
Имя терминала, на котором находится пользователь. 

`FROM`  
Удаленный хост, с которого пользователь вошел в систему. 

`LOGIN@`  
Время входа. 

`IDLE`  
Время простоя. 

`JCPU`  
Время, используемое всеми процессами, подключенными к tty (включая текущие фоновые задания). 

`PCPU`  
Время, используемое текущим процессом (то, что отображается под `WHAT`). 

`WHAT`  
Командная строка текущего процесса. 

Как и в случае с `who`, вы можете передать `w` имена пользователей:

```console
root@debian:~# w mimi
 18:23:15 up  1:07,  2 users,  load average: 0.00, 0.02, 0.05
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
mimi     pts/1    192.168.1.4      17:28    9:23   0.06s  0.06s -bash
```


## Базовая конфигурация и использование `sudo`

