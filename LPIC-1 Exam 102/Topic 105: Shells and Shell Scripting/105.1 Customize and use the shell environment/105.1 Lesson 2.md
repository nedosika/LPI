# 105.1 Урок 2

| **Сертификат:** | LPIC-1                                      |
|:----------------|:--------------------------------------------|
| **Версия:**     | 5.0                                         |
| **Тема:**       | 105 Оболочки и сценарии оболочки            |                           
| **Цель:**       | 105.1 Настройка и использование окружения оболочки |
| **Урок:**       | 2 из 3                                      |


## Введение

Подумайте о переменной как о воображаемом блоке, в который можно временно поместить часть информации. Как и в случае со своими сценариями инициализации, Bash классифицирует переменные как *shell/local* (те, которые живут только в пределах оболочки, в которой они были созданы), так и *environment/global* (те, которые наследуются дочерними оболочками и/или процессами). Фактически, в предыдущем уроке мы рассмотрели оболочки и их сценарии настройки или инициализации. Теперь удобно отметить, что сила этих файлов запуска заключается в том, что они позволяют нам использовать переменные, а также псевдонимы и функции, которые помогают нам создавать и настраивать среду оболочки по нашему выбору.


## Переменные: присвоение и ссылка

Переменная может быть определена как имя, содержащее значение. 

В Bash присвоение значения имени называется *присвоением переменной* и является способом, которым мы создаем или устанавливаем переменные. С другой стороны, процесс доступа к значению, содержащемуся в имени, называется *ссылкой на переменную*. 

Синтаксис для присвоения переменных:

```console
<variable_name>=<variable_value>
```

Например:

```console
$ distro=zorinos
```

Переменная `distro` равна `zorinos`, то есть есть часть памяти, содержащая значение `zorinos`, причем `distro` является указателем на нее. 

Однако обратите внимание, что при присвоении переменной не может быть пробелов по обе стороны от знака равенства:

```console
$ distro =zorinos
-bash: distro: command not found
$ distro= zorinos
-bash: zorinos: command not found
```

Из-за нашей ошибки Bash считал `distro` и `zorinos` командами. 

Для ссылки на переменную (то есть для проверки ее значения) мы используем команду `echo` перед именем переменной со знаком `$`:

```console
$ echo $distro
zorinos
```


## Имена переменных

При выборе имени переменных необходимо учитывать определенные правила. 

Имя переменной может содержать буквы (`a-z`, `A-Z`), цифры (`0-9`) и символы подчеркивания (`_`):

```console
$ distro=zorinos
$ echo $distro
zorinos
$ DISTRO=zorinos
$ echo $DISTRO
zorinos
$ distro_1=zorinos
$ echo $distro_1
zorinos
$ _distro=zorinos
$ echo $_distro
zorinos
```

Он не может начинаться с числа, иначе Bash запутается:

```console
$ 1distro=zorinos
-bash: 1distro=zorinos: command not found
```

Он не может содержать пробелов (даже без кавычек); по соглашению вместо них используются подчеркивания:

```console
$ "my distro"=zorinos
-bash: my: command not found
$ my_distro=zorinos
$ echo $my_distro
zorinos
```


## Значения переменных

Что касается ссылки или значения переменных, также важно учитывать ряд правил. 

Переменные могут содержать любые буквенно-цифровые символы (`a-z`, `A-Z`, `0-9`), а также большинство других символов (`?`,`!`,`*`,`.`,`/` и т. д.):

```console
$ distro=zorin12.4?
$ echo $distro
zorin12.4?
```

Значения переменных должны быть заключены в кавычки, если они содержат одиночные пробелы:

```console
$ distro=zorin 12.4
-bash: 12.4: command not found
$ distro="zorin 12.4"
$ echo $distro
zorin 12.4
$ distro='zorin 12.4'
$ echo $distro
zorin 12.4
```

Значения переменных также должны быть заключены в кавычки, если они содержат такие символы, как те, которые используются для перенаправления (`<`,`>`) или символ вертикальной черты (`|`). Единственное, что делает следующая команда, - это создает пустой файл с именем `zorin`:

```console
$ distro=>zorin
$ echo $distro

$ ls zorin
zorin
```

```console
$ distro=">zorin"
$ echo $distro
>zorin
```

Однако одинарные и двойные кавычки не всегда взаимозаменяемы. В зависимости от того, что мы делаем с переменной (присваивание или ссылка), использование одной или другой имеет последствия и даст разные результаты. В контексте присвоения переменных одинарные кавычки буквально принимают все символы значения переменной, тогда как двойные кавычки допускают замену переменных:

```console
$ lizard=uromastyx
$ animal='My $lizard'
$ echo $animal
My $lizard
$ animal="My $lizard"
$ echo $animal
My uromastyx
```

С другой стороны, при ссылке на переменную, значение которой включает некоторые начальные (или дополнительные) пробелы - иногда в сочетании со звездочками - обязательно использовать двойные кавычки после команды `echo`, чтобы избежать *разделения полей* и *расширения имени пути*:

```console
$ lizard="   genus   |   uromastyx"
$ echo $lizard
genus | uromastyx
$ echo "$lizard"
   genus   |   uromastyx
```

Если ссылка на переменную содержит закрывающий восклицательный знак, это должен быть последний символ в строке (иначе Bash будет думать, что мы имеем в виду событие истории):


```console
$ distro=zorin.?/!os
-bash: !os: event not found
$ distro=zorin.?/!
$ echo $distro
zorin.?/!
```

Любая обратная косая черта должна быть экранирована другой обратной косой чертой. Кроме того, если обратная косая черта является последним символом в строке, и мы не избегаем ее, Bash интерпретирует, что нам нужен разрыв строки, и выдаст нам новую строку:

```console
$ distro=zorinos\
>
$ distro=zorinos\\
$ echo $distro
zorinos\
```

В следующих двух разделах мы суммируем основные различия между *локальными* переменными и переменными *среды*.


## Локальные переменные или переменные оболочки

Локальные переменные или переменные оболочки существуют только в той оболочке, в которой они созданы. По соглашению локальные переменные пишутся строчными буквами. 

Для проведения нескольких тестов создадим локальную переменную. Как объяснялось выше, мы выбираем подходящее имя переменной и приравниваем его к соответствующему значению. Например:

```console
$ reptile=tortoise
```

Давайте теперь используем команду `echo` для ссылки на нашу переменную и проверяем, что все прошло, как ожидалось:

```console
$ echo $reptile
tortoise
```

В определенных сценариях - например, при написании скриптов - неизменяемость может быть интересной особенностью переменных. Если мы хотим, чтобы наши переменные были неизменными, мы можем создать их `readonly`:

```console
$ readonly reptile=tortoise
```

Или поверните их так после того, как они были созданы:

```console
$ reptile=tortoise
$ readonly reptile
```

Теперь, если мы попытаемся изменить значение `reptile`, Bash откажется:

```console
$ reptile=lizard
-bash: distro: readonly variable
```

>Чтобы вывести список всех переменных только для чтения в нашем текущем сеансе, введите в терминал `readonly` или `readonly -p`.

`set` полезная команда при работе с локальными переменными. 

`set` выводит все текущие назначенные переменные и функции оболочки. Так как может быть много строк (попробуйте сами!), рекомендуется использовать ее в сочетании с пагинатором, например `less`:

```console
$ set | less
BASH=/bin/bash
BASHOPTS=checkwinsize:cmdhist:complete_fullquote:expand_aliases:extglob:extquote:force_fignore:histappend:interactive_comments:login_shell:progcomp:promptvars:sourcepath
BASH_ALIASES=()
BASH_ARGC=()
BASH_ARGV=()
BASH_CMDS=()
BASH_COMPLETION_COMPAT_DIR=/etc/bash_completion.d
BASH_LINENO=()
BASH_SOURCE=()
BASH_VERSINFO=([0]="4" [1]="4" [2]="12" [3]="1" [4]="release" [5]="x86_64-pc-linux-gnu")
BASH_VERSION='4.4.12(1)-release'
(...)
```

Есть ли у нашей `reptile`  переменная?

```console
$ set | grep reptile
reptile=tortoise
```

Да вот она! 

Однако `reptile`, будучи локальной переменной, не будет унаследована никакими дочерними процессами, порожденными текущей оболочкой:

```console
$ bash
$ set | grep reptile
$
```

И, конечно же, мы не можем повторить его значение:

```console
$ echo $reptile
$
```

>Набрав команду `bash` в терминал, мы открываем новую (дочернюю) оболочку.

Чтобы отключить любые переменные (локальные или глобальные), мы используем команду `unset`:


```console
$ echo $reptile
tortoise
$ unset reptile
$ echo $reptile
$
```

>После `unset` должно следовать только имя переменной (без символа `$`).


## Глобальные переменные или переменные окружения

Глобальные переменные или переменные окружения существуют для текущей оболочки, а также для всех последующих процессов, порожденных из нее. По соглашению переменные окружения пишутся прописными буквами:

```console
$ echo $SHELL
/bin/bash
```

Мы можем рекурсивно передать значение этих переменных другим переменным, и значение последней в конечном итоге расширится до значения первой:

```console
$ my_shell=$SHELL
$ echo $my_shell
/bin/bash
$ your_shell=$my_shell
$ echo $your_shell
/bin/bash
$ our_shell=$your_shell
$ echo $our_shell
/bin/bash
```

Чтобы локальная переменная оболочки стала переменной окружения, необходимо использовать команду экспорта:

```console
$ export reptile
```

С помощью `export reptile` мы превратили нашу локальную переменную в переменную окружения, чтобы дочерние оболочки могли ее распознать и использовать:

```console
$ bash
$ echo $reptile
tortoise
```

Точно так же экспорт можно использовать для одновременной установки и экспорта переменной:

```console
$ export amphibian=frog
```

Теперь мы можем открыть новый экземпляр Bash и успешно сослаться на новую переменную:

```console
$ bash
$ echo $amphibian
frog
```

>С помощью `export -n <VARIABLE-NAME>` переменная будет преобразована обратно в локальную переменную оболочки.

Команда `export` также предоставит нам список всех существующих переменных окружения при вводе самостоятельно (или с параметром `-p`):

```console
$ export
declare -x HOME="/home/user2"
declare -x LANG="en_GB.UTF-8"
declare -x LOGNAME="user2"
(...)
declare -x PATH="/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games"
declare -x PWD="/home/user2"
declare -x SHELL="/bin/bash"
declare -x SHLVL="1"
declare -x SSH_CLIENT="192.168.1.10 49330 22"
declare -x SSH_CONNECTION="192.168.1.10 49330 192.168.1.7 22"
declare -x SSH_TTY="/dev/pts/0"
declare -x TERM="xterm-256color"
declare -x USER="user2"
declare -x XDG_RUNTIME_DIR="/run/user/1001"
declare -x XDG_SESSION_ID="8"
declare -x reptile="tortoise"
```

>Команда `declare -x` эквивалентна `export`.

Еще две команды, которые можно использовать для печати списка всех переменных окружения: `env` и `printenv`:

```console
$ env
SSH_CONNECTION=192.168.1.10 48678 192.168.1.7 22
LANG=en_GB.UTF-8
XDG_SESSION_ID=3
USER=user2
PWD=/home/user2
HOME=/home/user2
SSH_CLIENT=192.168.1.10 48678 22
SSH_TTY=/dev/pts/0
MAIL=/var/mail/user2
TERM=xterm-256color
SHELL=/bin/bash
SHLVL=1
LOGNAME=user2
XDG_RUNTIME_DIR=/run/user/1001
PATH=/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games
_=/usr/bin/env
```

Помимо того, что это синоним `env`, мы можем иногда использовать `printenv` аналогично тому, как мы используем команду `echo` для проверки значения переменной:

```console
$ echo $PWD
/home/user2
$ printenv PWD
/home/user2
```

Однако обратите внимание, что с `printenv` перед именем переменной не ставится знак $.

>`PWD` хранит путь к текущему рабочему каталогу. Об этой и других общих переменных окружения мы узнаем позже.


## Запуск программы в измененном окружении

`env` можно использовать для изменения окружения оболочки во время выполнения программы. 

Чтобы начать новый сеанс Bash с максимально пустой средой - очистив большинство переменных (а также функции и псевдонимы) - мы будем использовать `env` с параметром `-i`:

```console
$ env -i bash
```

Теперь большинство переменных нашего окружения исчезли:

```console
$ echo $USER
$
```

Осталось всего лишь несколько:

```console
$ env
LS_COLORS=
PWD=/home/user2
SHLVL=1
_=/usr/bin/printenv
```

Мы также можем использовать `env` для установки определенной переменной для конкретной программы. 

В нашем предыдущем уроке, обсуждая неинтерактивные оболочки без входа в систему, мы видели, как сценарии не считывают стандартные файлы запуска, а вместо этого ищут значение переменной `BASH_ENV` и используют его в качестве своего файла запуска, если он существует.

Продемонстрируем этот процесс: 

1. Мы создаем собственный файл запуска с именем `.startup_script` со следующим содержимым:

```console
CROCODILIAN=caiman
```

2. Мы пишем сценарий Bash с именем `test_env.sh` со следующим содержимым:

```console
#!/bin/bash

echo $CROCODILIAN
```

3. Мы устанавливаем исполняемый бит для нашего скрипта `test_env.sh`:

```console
$ chmod +x test_env.sh
```

4. Наконец, мы используем `env`, чтобы установить `BASH_ENV` в `.startup_script` для `test_env.sh`:

```console
$ env BASH_ENV=/home/user2/.startup_script ./test_env.sh
caiman
```

Команда `env` неявна, даже если мы избавимся от нее:

```console
$ BASH_ENV=/home/user2/.startup_script ./test_env.sh
caiman
```

>Если вы не понимаете строку `#!/bin/bash` или команду `chmod +x`, не паникуйте! Мы узнаем все необходимое о сценариях оболочки в будущих уроках. На данный момент просто помните, что для выполнения сценария из его собственного каталога мы используем `./some_script`.


## Общие переменные среды

Пришло время рассмотреть некоторые из наиболее важных переменных окружения, которые установлены в конфигурационных файлах Bash.

`DISPLAY`  
Применительно к X-серверу значение этой переменной обычно состоит из трех элементов: 

* Имя хоста (его отсутствие означает `localhost`), на котором работает X-сервер. 
* Двоеточие в качестве разделителя. 
* Число (обычно это `0` и относится к дисплею компьютера).  
```console
$ printenv DISPLAY
:0
```
Пустое значение этой переменной означает сервер без системы X Window. Дополнительный номер - как в `my.xserver: 0:1` - будет относиться к номеру экрана, если существует больше одного.

`HISTCONTROL`  
Эта переменная контролирует, какие команды сохраняются в `HISTFILE` (см. ниже). Возможных три их значения: 

`ignorespace`  
Команды, начинающиеся с пробела, не сохраняются. 

`ignoredups`  
Команда, аналогичная предыдущей, не будет сохранена. 

`ignoreboth`  
Команды, которые попадают в любую из двух предыдущих категорий, не будут сохранены.
```console
$ echo $HISTCONTROL
ignoreboth
```

`HISTSIZE`  
Она устанавливает количество команд, которые будут храниться в памяти, пока длится сеанс оболочки.
```console
$ echo $HISTSIZE
1000
```

`HISTFILESIZE`  
Она устанавливает количество команд, которые будут сохранены в `HISTFILE` как в начале, так и в конце сеанса:
```console
$ echo $HISTFILESIZE
2000
```

`HISTFILE`  
Имя файла, в котором хранятся все команды по мере их ввода. По умолчанию этот файл находится в `~/.bash_history`:
```console
$ echo $HISTFILESIZE
2000
```

`HISTFILE`  
Имя файла, в котором хранятся все команды по мере их ввода. По умолчанию этот файл находится в `~/.bash_history`:
```console
$ echo $HISTFILE
/home/user2/.bash_history
```

>Чтобы просмотреть содержимое `HISTFILE`, мы просто набираем `history`. В качестве альтернативы мы можем указать количество команд, которые мы хотим видеть, передав аргумент (количество самых последних команд) в `history`, например `history 3`.

`HOME`  
Эта переменная хранит абсолютный путь к домашнему каталогу текущего пользователя и устанавливается, когда пользователь входит в систему. 

Этот фрагмент кода - из `~/.profile` - не требует пояснений (он является источником `"$HOME/.bashrc"`, если он существует):

```console
    # include .bashrc if it exists
    if [ -f "$HOME/.bashrc" ]; then
	. "$HOME/.bashrc"
    fi
```

>Если вы не совсем понимаете оператор `if`, не беспокойтесь: просто обратитесь к урокам по написанию сценариев оболочки.

Помните, что `~` эквивалентно `$HOME`:

```console
$ echo ~; echo $HOME
/home/carol
/home/carol
```

>Команды можно объединять точкой с запятой (`;`).

Мы также можем доказать это с помощью оператора `if`:

```console
$ if [ ~ == "$HOME" ]; then echo "true"; else "false"; fi
true
```

>Помните: знак равенства `=` используется для присвоения переменной. `==` используется для проверки равенства.

`HOSTNAME`  
В этой переменной хранится имя TCP/IP хост-компьютера:
```console
$ echo $HOSTNAME
debian
```

`HOSTTYPE`  
Здесь хранится архитектура процессора главного компьютера:

```console
$ echo $HOSTTYPE
x86_64
```

`LANG`  
Эта переменная сохраняет локаль системы:

```console
$ echo $LANG
en_UK.UTF-8
```

`LD_LIBRARY_PATH`  
Эта переменная состоит из набора разделенных двоеточиями каталогов, в которых разделяемые библиотеки используются программами совместно:

```console
$ echo $LD_LIBRARY_PATH
/usr/local/lib
```

`MAIL`  
В этой переменной хранится файл, в котором Bash ищет электронную почту:

```console
$ echo $MAIL
/var/mail/carol
```
Другое распространенное значение этой переменной - `/var/spool/mail/$USER`.


`MAILCHECK`  
Эта переменная хранит числовое значение, которое указывает в секундах частоту, с которой Bash проверяет наличие новой почты:

```console
$ echo $MAILCHECK
60
```

`PATH`  
Эта переменная среды хранит список каталогов, в которых Bash ищет исполняемые файлы, когда ему предлагается запустить любую программу. В нашем примере машины эта переменная устанавливается через общесистемный файл `/etc/profile`:

```console
if [ "`id -u`" -eq 0 ]; then
  PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
else
  PATH="/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games"
fi
export PATH
```

С помощью оператора `if` проверяется личность пользователя, и - в зависимости от результата теста (`root` или иной) - мы получим тот или иной `PATH`. Наконец, выбранный `PATH` распространяется при помощи `export`. Обратите внимание на две вещи относительно значения `PATH`: 

* Имена каталогов записываются с использованием абсолютных путей. 
* Двоеточие используется как разделитель. 

Если мы хотим включить папку `/usr/local/sbin` в `PATH` для обычных пользователей, мы изменим строку так, чтобы она выглядела следующим образом:

```console
(...)
else
  PATH="/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games:/usr/local/sbin"
fi
export PATH
```

Теперь мы можем увидеть, как изменяется значение переменной, когда мы авторизуемся как обычный пользователь:
```console
# su - carol
$ echo $PATH
/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games:/usr/local/sbin
```

>Мы также могли бы добавить `/usr/local/sbin` в пользовательский `PATH` в командной строке, набрав либо `PATH=/usr/local/sbin:$PATH`, либо `PATH=$PATH:/usr/local/sbin` - первое создание `/usr/local/sbin` - первый каталог, в котором выполняется поиск исполняемых файлов; последний делает его последним.

`PS1`  
В этой переменной хранится значение приглашения Bash. В следующем фрагменте кода (также из `/etc/profile`) оператор `if` проверяет личность пользователя и соответственно выдает ему очень дискретную подсказку (`#` для `root` или `$` для обычных пользователей):
```console
if [ "`id -u`" -eq 0 ]; then
  PS1='# '
else
  PS1='$ '
fi
```

Идентификатор `root` равен 0. Станьте пользователем `root` и проверьте его самостоятельно с помощью `id -u`.

Другие переменные подсказки включают: 

`PS2`  
Обычно устанавливается на `>` и используется как подсказка для продолжения для длинных многострочных команд. 

`PS3`  
Используется как подсказка для команды выбора. 

`PS4`  
Обычно устанавливается на `+` и используется для отладки. 

`SHELL`  
Эта переменная хранит абсолютный путь к текущей оболочке:

```console
$ echo $SHELL
/bin/bash
```

`USER`  
Здесь хранится имя текущего пользователя:

```console
$ echo $USER
carol
```


# Упражнения для закрепления

1. Обратите внимание на присвоение переменных в столбце «Команда(ы)» и укажите, является ли результирующая переменная «локальной» или «глобальной»:

| Команда(ы)                       | Локальная | Глобпльная |
|:---------------------------------|:----------|:-----------|
| `debian=mother`                  |           |            |
| `ubuntu=deb-based`               |           |            |
| `mint=ubuntu-based; export mint` |           |            |
| `export suse=rpm-based`          |           |            |
| `zorin=ubuntu-based`             |           |            |

2. Изучите «Команда» и «Вывод» и объясните значение: 

| Команда(ы)          | Вывод                       | Значение   |
|:--------------------|:----------------------------|:-----------|
| `echo $HISTCONTROL` | `ignoreboth`                |            |   
| `echo ~`            | `/home/carol`               |            |
| `echo $DISPLAY`     | `reptilium:0:2`             |            |
| `echo $MAILCHECK`   | `60` |                      |            |
| `echo $HISTFILE`    | `/home/carol/.bash_history` |            |

3. Переменные задаются неправильно в столбце «Неправильная команда». Предоставьте недостающую информацию в разделах «Правильная команда» и «Ссылка на переменную», чтобы мы получили «Ожидаемый результат»:

| Команда(ы)                 | Правильная команда | Ссылка на переменную | Ожидаемый результат |
|:---------------------------|:-------------------|:---------------------|:--------------------|
| `lizard =chameleon`        |                    |                      | `chameleon`         |
| `cool lizard=chameleon`    |                    |                      | `chameleon`         |
| `lizard=cha|me|leon`       |                    |                      | `cha|me|leon`       |
| `lizard=/** chameleon **/` |                    |                      | `/** chamelon **/`  |
| `win_path=C:\path\to\dir\` |                    |                      | `C:\path\to\dir\`   |


## Упражнения на размышление




## Резюме




## Ответы на упражнения для закрепления




## Ответы на упражнения для размышления
