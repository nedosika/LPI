# 105.1 Урок 1

| **Сертификат:** | LPIC-1                                      |
|:----------------|:--------------------------------------------|
| **Версия:**     | 5.0                                         |
| **Тема:**       | 105 Оболочки и сценарии оболочки            |                           
| **Цель:**       | 105.1 Основы интернет-протоколов            |
| **Урок:**       | 1 из 3                                      |


## Введение

Оболочка, возможно, является самым мощным инструментом в системе Linux и может быть определена как интерфейс между пользователем и ядром операционной системы. Она интерпретирует команды, введенные пользователем. Следовательно, все системные администраторы должны иметь опыт работы с оболочкой. Как мы уже наверняка знаем, Bourne Again Shell (*Bash*) *де-факто* является оболочкой для подавляющего большинства дистрибутивов Linux. 

После запуска первое, что делает Bash - или любая другая оболочка, если на то пошло - выполняет серию сценариев запуска. Эти сценарии настраивают среду сеанса. Существуют как общесистемные, так и пользовательские скрипты. Мы можем поместить в эти сценарии свои личные предпочтения или настройки, которые лучше всего соответствуют потребностям наших пользователей, в форме переменных, псевдонимов и функций. 

Точная серия файлов запуска зависит от очень важного параметра: типа оболочки. Давайте посмотрим на разнообразие существующих оболочек.


## Типы оболочки: интерактивная против неинтерактивной и Login против Non-Login входа в систему

Для начала давайте проясним концепции *интерактивности* и *входа* в систему в контексте оболочек: 

Интерактивные/неинтерактивные оболочки  
Этот вид оболочки относится к взаимодействию, которое происходит между пользователем и оболочкой: пользователь обеспечивает ввод, вводя команды в терминал с помощью клавиатуры; оболочка обеспечивает вывод, выводя сообщения на экран. 

Login/Non-login оболочки  
Этот вид оболочки относится к событию, когда пользователь обращается к компьютерной системе, предоставляя свои учетные данные, такие как имя пользователя и пароль. 

Как интерактивные, так и неинтерактивные оболочки могут быть как для входа, так и без входа, и любая возможная комбинация этих типов имеет свое конкретное применение. 

*Интерактивные оболочки входа в систему* выполняются, когда пользователи входят в систему, и используются для настройки конфигураций пользователей в соответствии с их потребностями. Хорошим примером этого типа оболочки может быть группа пользователей, принадлежащих к одному отделу, которым требуется конкретная переменная, установленная в их сеансах. 

Под *интерактивными оболочками без входа в систему* мы понимаем любые другие оболочки, открытые пользователем после входа в систему. Пользователи используют эти оболочки во время сеансов для выполнения задач обслуживания и администрирования, таких как установка переменных, времени, копирование файлов, написание сценариев и т. д. 

С другой стороны, *неинтерактивные оболочки* не требуют какого-либо взаимодействия с человеком. Таким образом, эти оболочки не запрашивают у пользователя ввод, а их вывод, если таковой имеется, в большинстве случаев записывается в журнал. 

*Неинтерактивные оболочки входа в систему* довольно редки и непрактичны. Их использование практически не существует, и мы будем комментировать их только для понимания поведения оболочки. Некоторые странные примеры включают принудительный запуск сценария из оболочки входа с помощью `/bin/bash --login <some_script>` или передачу стандартного вывода (*stdout*) команды на стандартный ввод (*stdin*`) ssh-соединения:

```console
<some_command> | ssh <some_user>@<some_server>
```

Что *касается неинтерактивной оболочки без входа в систему*, то здесь нет ни взаимодействия, ни входа в систему от имени пользователя, поэтому здесь мы имеем в виду использование автоматизированных сценариев. Эти скрипты в основном используются для выполнения повторяющихся задач администрирования и обслуживания, например, тех, которые включены в cronjobs. В таких случаях `bash` не читает файлы запуска.


### Открытие терминала

Когда мы находимся в среде рабочего стола, мы можем либо открыть приложение терминала, либо переключиться на одну из системных консолей. Следовательно, новая оболочка является либо оболочкой `pts` при открытии из эмулятора терминала в графическом интерфейсе пользователя, либо оболочкой `tty` при запуске из системной консоли. В первом случае мы имеем дело не с терминалом, а с эмулятором терминала. В рамках графических сеансов эмуляторы терминалов, такие как *gnome-terminal* или *konsole*, очень многофункциональны и удобны для пользователя по сравнению с терминалами с текстовым интерфейсом пользователя. Менее функциональные эмуляторы терминала включают, среди прочего, *XTerm* и *sakura*. 

Используя комбинации <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>F1</kbd>-<kbd>F6</kbd>, мы можем перейти к входам в консоль, которые открывают интерактивную текстовую оболочку входа. <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>F7</kbd> вернет сеанс обратно на рабочий стол.

>`tty` - телетайп; `pts` обозначает псевдотерминальное ведомое устройство. Для получения дополнительной информации: `man tty` и `man pts`


### Запуск оболочек с помощью `bash`

После входа в систему введите `bash` в терминал, чтобы открыть новую оболочку. Технически эта оболочка является дочерним процессом текущей оболочки. 

При запуске дочернего процесса `bash` мы можем указать различные переключатели, чтобы определить, какую оболочку мы хотим запустить. Вот некоторые важные параметры вызова `bash`: 

`bash -l` или `bash --login`  
вызовет оболочку входа в систему. 

`bash -i`  
вызовет интерактивную оболочку. 

`bash --noprofile`  
с оболочками входа в систему будут игнорировать как общесистемный файл запуска `/etc/profile`, так и файлы запуска уровня пользователя `~/.bash_profile`, `~/.bash_login` и `~/.profile`

`.bash --norc`  
с интерактивными оболочками игнорирует как общесистемный файл запуска `/etc/bash.bashrc`, так и файл запуска уровня пользователя `~/.bashrc`. 

`bash --rcfile <file>`  
с интерактивными оболочками будет использовать `<file>` в качестве файла запуска, игнорируя общесистемный `/etc/bash.bashrc` и пользовательский уровень `~/.bashrc`. 

Ниже мы обсудим различные файлы запуска.


### Запуск оболочек с помощью `su` и `sudo`

Используя эти две похожие программы, мы можем получить определенные типы оболочек: 

`su`  
Изменяет ID пользователя или становится суперпользователем (`root`). С помощью этой команды мы можем вызывать как оболочки с входом, так и оболочки без входа: 
* `su - user2`, `su -l user2` или `su --login user2` запустят интерактивную оболочку входа в систему как `user2`. * `su user2` запустит интерактивную оболочку без входа в систему как `user2`. 
* `su - root` или `su` - запустит интерактивную оболочку входа в систему как `root`. 
* `su root` или `su` запустит интерактивную оболочку без входа в систему от имени пользователя `root`. 

`sudo`  
Выполнять команды от имени другого пользователя(включая суперпользователя). Поскольку эта команда в основном используется для временного получения привилегий `root`, пользователь, использующий ее, должен находиться в файле `sudoers`. Чтобы добавить пользователей в `sudoers`, нам нужно стать `root`, а затем запустить:

```console
root@debian:~# usermod -aG sudo user2
```

Так же, как `su`, `sudo` позволяет нам вызывать как оболочки входа, так и оболочки без входа: 
* `sudo su - user2`, `sudo su -l user2` или `sudo su --login user2` запустит интерактивную оболочку входа в систему как `user2`. 
* `sudo su user2` запустит интерактивную оболочку без входа в систему как `user2`. 
* `sudo -u user2 -s` запустит интерактивную оболочку без входа в систему как `user2`. 
* `sudo su - root` или `sudo su` - запустит интерактивную оболочку входа в систему с правами `root`. 
* `sudo -i` запустит интерактивную оболочку входа в систему с правами `root`. 
* `sudo -i <some_command>` запустит интерактивную оболочку входа в систему от имени пользователя `root`, выполнит команду и вернется к исходному пользователю. 
* `sudo su root` или `sudo su` запустит интерактивную оболочку без входа в систему с правами `root`. 
* `sudo -s` или `sudo -u root -s` запустит оболочку без входа в систему с правами `root`. 

При использовании `su` или `sudo` важно учитывать наш конкретный сценарий запуска новой оболочки: нужна ли нам среда целевого пользователя или нет? Если это так, мы бы использовали параметры, которые вызывают оболочки входа в систему; если нет, то те, которые вызывают оболочки без входа в систему.


### Какой у нас тип оболочки?

Чтобы узнать, с какой оболочкой мы работаем, мы можем ввести в терминал `echo $0` и получить следующий вывод: 

Интерактивный вход  
`-bash` или `-su` 

Интерактивный без входа в систему  
`bash` или `/bin/bash` 

Неинтерактивный без входа в систему (скрипты)  
`<name_of_script>`


### Сколько у нас оболочек?

Чтобы узнать, сколько оболочек `bash` запущено в системе, мы можем использовать команду `ps aux | grep bash`:

```console
user2@debian:~$ ps aux | grep bash
user2       5270  0.1  0.1  25532  5664 pts/0    Ss   23:03   0:00 bash
user2       5411  0.3  0.1  25608  5268 tty1     S+   23:03   0:00 -bash
user2       5452  0.0  0.0  16760   940 pts/0    S+   23:04   0:00 grep --color=auto bash
```

`user2` в debian вошел в сеанс GUI (или X Window System) и открыл `gnome-terminal`, затем нажал <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>F1</kbd>, чтобы войти в сеанс терминала `tty`. Наконец, он вернулся к сеансу графического интерфейса пользователя, нажав <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>F7</kbd> и набрав команду `ps aux | grep bash`. Таким образом, вывод показывает интерактивную оболочку без входа через эмулятор терминала (`pts/0`) и интерактивную оболочку входа через соответствующий текстовый терминал (`tty1`). Также обратите внимание, что последнее поле каждой строки (команды) - это `bash` для первой и `-bash` для последней.


### Откуда оболочки получают свою конфигурацию: файлы запуска

Что ж, теперь, когда мы знаем типы оболочки, которые мы можем найти в системе Linux, самое время посмотреть, какие файлы запуска выполняются какой оболочкой. Обратите внимание, что общесистемные или глобальные сценарии помещаются в каталог `/etc/`, тогда как локальные или пользовательские сценарии находятся в домашней папке пользователя (`~`). Кроме того, при поиске более одного файла, как только один найден и запущен, остальные игнорируются. Исследуйте и изучайте эти файлы самостоятельно в своем любимом текстовом редакторе или набрав `less <startup_file>`.

>Файлы запуска можно разделить на специфические для Bash(ограниченные только конфигурациями и командами `bash`) и общие(относящиеся к большинству оболочек).


#### Интерактивная оболочка входа

##### Глобальный уровень

`/etc/profile`  
Это общесистемный файл `.profile` для оболочки Bourne и совместимых с Bourne оболочек (включая `bash`). Посредством серии операторов `if` этот файл устанавливает ряд переменных, таких как `PATH` и `PS1` соответственно, а также источник - если они существуют - как файл `/etc/bash.bashrc`, так и те, что находятся в каталоге `/etc/profile.d`. 

`/etc/profile.d/*`  
Этот каталог может содержать сценарии, которые запускаются `/etc/profile`.


##### Локальный уровень

`~/.bash_profile`  
Этот специальный файл Bash используется для настройки пользовательской среды. Его также можно использовать как источник `~/.bash_login` и `~/.profile`. 

`~/.bash_login`  
Также специфичен для Bash, этот файл будет выполняться только в том случае, если нет файла `~/.bash_profile`. Его название предполагает, что его следует использовать для выполнения команд, необходимых при входе в систему. 

`~/.profile`  
Этот файл не является специфичным для Bash и будет получен только в том случае, если не существует ни `~/.bash_profile`, ни `~/.bash_login`, что обычно имеет место. Таким образом, основная цель `~/.profile` - это проверка того, запущена ли оболочка Bash и - если да - поиск `~/.bashrc`, если он существует. Обычно он устанавливает переменную `PATH` так, чтобы она включала личный каталог пользователя `~/bin`, если он существует. 

`~/.bash_logout`  
Если он существует, этот специальный файл Bash выполняет некоторые операции очистки при выходе из оболочки. Это может быть удобно в таких случаях, как удаленные сеансы.


##### Изучение файлов конфигурации интерактивной оболочки входа

Давайте продемонстрируем некоторые из этих файлов в действии, изменив `/etc/profile` и `/home/user2/.profile`. Мы добавим к каждой строке, напоминающей нам о выполняемом файле:

```console
root@debian:~# echo 'echo Hello from /etc/profile' >> /etc/profile
root@debian:~# echo 'echo Hello from ~/.profile' >> ~/.profile
```

>Два оператора перенаправления `>>` добавляют вывод команды в существующий файл, но не перезаписывают его. Однако, если файл не существует, он будет создан.

Таким образом, через вывод соответствующих `echo` команд мы узнаем, когда каждый из этих файлов будет прочитан и выполнен. Чтобы доказать это, давайте посмотрим, что происходит, когда `user2` входит в систему через `ssh` с другой машины:

```console
user2@debian:~$ ssh user2@192.168.1.6
user2@192.168.1.6's password:
Linux debian 4.9.0-8-amd64 #1 SMP Debian 4.9.130-2 (2018-10-27) x86_64

The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
Last login: Tue Nov 27 19:57:19 2018 from 192.168.1.10
Hello from /etc/profile
Hello from /home/user2/.profile
```

Как показывают последние две строчки, это сработало. Также обратите внимание на три вещи: 

* Сначала был запущен глобальный файл. 
* В домашнем каталоге пользователя `user2` не было файлов `.bash_profile` или `.bash_login`. 
* Тильда (`~`) заменяется на абсолютный путь к файлу (`/home/user2/.profile`).


#### Интерактивная оболочка без входа

##### Глобальный уровень

`/etc/bash.bashrc`  
Это общесистемный файл `.bashrc` для интерактивных оболочек `bash`. Посредством своего выполнения `bash` гарантирует, что он выполняется в интерактивном режиме, проверяет размер окна после каждой команды (при необходимости обновляя значения `LINES` и `COLUMNS`) и устанавливает некоторые переменные.


##### Локальный уровень

`~/.bashrc`  
В дополнение к выполнению задач, аналогичных тем, которые описаны для `/etc/bash.bashrc` на уровне пользователя (например, проверка размера окна или запуск в интерактивном режиме), этот специальный файл Bash обычно устанавливает некоторые переменные истории и источники `~/.bash_aliases` если он существует. Кроме того, этот файл обычно используется для хранения конкретных псевдонимов и функций пользователей. 

Также стоит отметить, что `~/.bashrc` читается, если `bash` обнаруживает, что его `<stdin>` является сетевым соединением (как это было в случае с соединением *Secure Shell* (SSH) в приведенном выше примере).


##### Изучение интерактивных файлов конфигурации оболочки без входа в систему

Давайте теперь изменим `/etc/bash.bashrc` и `/home/user2/.bashrc`:

```console
root@debian:~# echo 'echo Hello from /etc/bash.bashrc' >> /etc/bash.bashrc
root@debian:~# echo 'echo Hello from ~/.bashrc' >> ~/.bashrc
```

И вот что происходит, когда `user2` запускает новую оболочку:

```console
user2@debian:~$ bash
Hello from /etc/bash.bashrc
Hello from /home/user2/.bashrc
```

И снова два файла были прочитаны и выполнены.

>Помните, что из-за порядка, в котором файлы запускаются, локальные файлы имеют приоритет над глобальными.


#### Неинтерактивная оболочка входа

Неинтерактивная оболочка с параметрами `-l` или `--login` вынуждена вести себя как оболочка входа в систему, поэтому запускаемые файлы запуска будут такими же, как и файлы для интерактивных оболочек входа. 

Чтобы доказать это, давайте напишем простой скрипт и сделаем его исполняемым. Мы не будем включать никаких shebang символов, потому что мы будем вызывать исполняемый файл bash (`/bin/bash` с параметром входа в систему) из командной строки. 

1. Мы создаем сценарий `test.sh`, содержащий строку echo `'Hello from a script'`, чтобы мы могли доказать, что сценарий выполняется успешно:  
```console
user2@debian:~$ echo "echo 'Hello from a script'" > test.sh
```
2. Делаем наш скрипт исполняемым:  
```console
user2@debian:~$ chmod +x ./test.sh
```
3. Наконец, мы вызываем `bash` с параметром `-l` для запуска сценария:  
```console
user2@debian:~$ bash -l ./test.sh
Hello from /etc/profile
Hello from /home/user2/.profile
Hello from a script
```
Оно работает! Перед запуском скрипта был выполнен вход в систему, и были выполнены как `/etc/profile`, так и `~/.profile`.

>Мы узнаем о *shebang* и всех других аспектах написания сценариев оболочки в будущих уроках.

Теперь у нас есть стандартный вывод (*stdout*) команды `echo` в стандартный ввод (*stdin*) `ssh` соединения с помощью конвейера (`|`):

```console
user2@debian:~$ echo "Hello-from-a-noninteractive-login-shell" | ssh user2@192.168.1.6
Pseudo-terminal will not be allocated because stdin is not a terminal.
user2@192.168.1.6's password:
Linux debian 4.9.0-8-amd64 #1 SMP Debian 4.9.130-2 (2018-10-27) x86_64

The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
Hello from /etc/profile
Hello from /home/user2/.profile
-bash: line 1: Hello-from-a-noninteractive-login-shell: command not found
```

Снова выполняются `/etc/profile` и `~/.profile`. В остальном первая и последняя строки вывода достаточно информативны, если речь идет о поведении оболочки.


#### Неинтерактивная оболочка без входа в систему

Сценарии не читают ни один из файлов, перечисленных выше, но ищут переменную среды `BASH_ENV`, при необходимости расширяют ее значение и используют в качестве имени файла запуска для чтения и выполнения команд. Мы узнаем больше о переменных среды в следующем уроке. 

Как упоминалось выше, обычно `/etc/profile` и `~/.profile` обеспечивают выполнение и `/etc/bash.bashrc`, и `~/.bashrc` после успешного входа в систему. Результат следующей команды показывает это явление:

```console
root@debian:~# su - user2
Hello from /etc/bash.bashrc
Hello from /etc/profile
Hello from /home/user2/.bashrc
Hello from /home/user2/.profile
```

Принимая во внимание строки, которые мы ранее добавляли к сценариям запуска - и вызывая оболочку интерактивного входа на уровне пользователя с `su - user2` - четыре строки вывода можно объяснить следующим образом: 

1. `Hello from /etc/bash.bashrc` означает, что `/etc/profile` получил `/etc/bash.bashrc`. 
2. `Hello from /etc/profile` означает, что `/etc/profile` полностью прочитан и выполнен. 
3. `Hello from /home/user2/.bashrc` означает, что `~/.profile` получил `~/.bashrc`. 
4. `Hello from /home/user2/.profile` означает, что `~/.profile` полностью прочитан и выполнен. 

Обратите внимание, как с `su - <username>` (также `su -l <username>` и `su --login <username>`) мы гарантируем вызов оболочки входа в систему, тогда как `su <username>` вызывал бы только `/etc/bash.bashrc` и `~/.bashrc`.


### Источники файлов

В предыдущих разделах мы обсуждали, что некоторые сценарии запуска включают или выполняют другие сценарии. Этот механизм называется поиском и объясняется в этом разделе.

Точка (`.`) Обычно встречается в файлах запуска. 

В файле `.profile` нашего сервера Debian мы можем найти, например, следующий блок:

```console
    # include .bashrc if it exists
    if [ -f "$HOME/.bashrc" ]; then
	. "$HOME/.bashrc"
    fi
```

Мы уже видели, как выполнение одного сценария может привести к другому. Таким образом, оператор `if` гарантирует, что файл `$HOME/.bashrc` - если он существует (`-f`) - будет получен (т.е. прочитан и выполнен) при входе в систему:

```console
. "$HOME/.bashrc"
```

>Как мы узнаем в следующем уроке, `$HOME` - это переменная среды, которая расширяется до абсолютного пути к домашнему каталогу пользователя.

Кроме того, мы можем использовать расширение `.` всякий раз, когда мы изменили файл запуска и хотим, чтобы изменения вступили в силу без перезагрузки. Например, мы можем:

* добавьте псевдоним в `~/.bashrc`:
```console
user2@debian:~$ echo "alias hi='echo We salute you.'" >> ~/.bashrc
```

>При отправке вывода одной команды в файл не следует путать добавление (`>>`) с перезаписью (`>`).

* выведите последнюю строку `~/.bashrc`, чтобы убедиться, что все прошло нормально:

```console
user2@debian:~$ tail -n 1 !$
tail -n 1 ~/.bashrc
alias hi='echo We salute you.'
```

> `!$` заменяется последним аргументом предыдущей команды, в нашем случае: `~/.bashrc`.

* создайте файл вручную:
```console
user2@debian:~$ . ~/.bashrc
```

* и вызовите псевдоним, чтобы доказать, что он работает:
```console
user2@debian:~$ hi
We salute you.
```

>Обратитесь к следующему уроку, чтобы узнать о *псевдонимах* и *переменных*.


#### Поиск файлов при помощи `source`

Команда `source` является синонимом `.`. Итак, для источника `~/.bashrc` мы также можем сделать это следующим образом:

```console
user2@debian:~$ source ~/.bashrc
```


### Происхождение файлов запуска оболочки: `SKEL`

`SKEL` - это переменная, значением которой является абсолютный путь к каталогу `skel`. Этот каталог служит шаблоном для структуры файловой системы домашних каталогов пользователей. Он включает файлы, которые будут унаследованы всеми созданными новыми учетными записями пользователей (включая, конечно же, файлы конфигурации для оболочек). `SKEL` и другие связанные переменные хранятся в `/etc/adduser.conf`, который является файлом конфигурации для `adduser`:

```console
user2@debian:~$ grep SKEL /etc/adduser.conf
# The SKEL variable specifies the directory containing "skeletal" user
SKEL=/etc/skel
# If SKEL_IGNORE_REGEX is set, adduser will ignore files matching this
SKEL_IGNORE_REGEX="dpkg-(old|new|dist|save)"
```

`SKEL` установлен в `/etc/skel`; таким образом, там лежат сценарии запуска, которые настраивают наши оболочки:

```console
user2@debian:~$ ls -a /etc/skel/
.  ..  .bash_logout  .bashrc  .profile
```

>Помните, что файлы, начинающиеся с `.` скрыты, поэтому мы должны использовать `ls -a`, чтобы увидеть их при выводе списка содержимого каталога.

Давайте теперь создадим каталог в `/etc/skel`, чтобы все новые пользователи могли хранить свои личные скрипты в: 

1. Как `root` мы переходим в `/etc/skel`:
```console
root@debian:~# cd /etc/skel/
root@debian:/etc/skel#
```

2. Перечислим его содержимое:
```console
root@debian:/etc/skel# ls -a
.  ..  .bash_logout  .bashrc  .profile
```

3. Создаем каталог и проверяем, все прошло как положено:
```console
root@debian:/etc/skel# mkdir my_personal_scripts
root@debian:/etc/skel# ls -a
.  ..  .bash_logout  .bashrc  my_personal_scripts  .profile
```

4. Теперь удаляем `user2` вместе с его домашним каталогом:
```console
root@debian:~# deluser --remove-home user2
Looking for files to backup/remove ...
Removing files ...
Removing user `user2' ...
Warning: group `user2' has no more members.
Done.
```

5. Мы снова добавляем `user2`, чтобы он получил новый домашний каталог:
```console
root@debian:~# adduser user2
Adding user `user2' ...
Adding new group `user2' (1001) ...
Adding new user `user2' (1001) with group `user2' ...
Creating home directory `/home/user2' ...
Copying files from `/etc/skel' ...
Enter new UNIX password:
Retype new UNIX password:
passwd: password updated successfully
Changing the user information for user2
Enter the new value, or press ENTER for the default
	Full Name []:
	Room Number []:
	Work Phone []:
	Home Phone []:
	Other []:
Is the information correct? [Y/n] y
```

6. Наконец, мы входим в систему как `user2` и перечисляем все файлы в `/home/user2`, чтобы убедиться, что все прошло так, как ожидалось:
```console
root@debian:~# su - user2
user2@debian:~$ pwd
/home/user2
user2@debian:~$ ls -a
.  ..  .bash_history  .bash_logout  .bashrc  my_personal_scripts  .profile
```
Это было так.


# Упражнения для закрепления

1. Изучите, как были запущены оболочки, в столбце «Shell Started with…» и укажите необходимую информацию:
| Оболочка запустилась с...| Интерактивный | Вход в систему | Результат вывода `echo $0` |
|--------------------------|---------------|----------------|----------------------------|
| `sudo ssh user2@machine2`|               |                |                            |
| <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>F2</kbd> ||           |                            |    
| `su - user2`             |               |                |                            |
| `gnome-terminal`         |               |                |                            |
| Обычный пользователь использует *консоль* для запуска экземпляра *sakura* |||          |
| Скрипт с именем `test.sh`, содержащий команду `echo $0` |||                            |

2. Напишите команды `su` и `sudo` для запуска указанной оболочки:  
Оболочка интерактивного входа в систему как `user2`  
`su`:  
`sudo`:  
Интерактивная оболочка входа в систему с правами `root`  
`su`:  
`sudo`:  
Интерактивная оболочка без входа в систему с правами `root`  
`su`:  
`sudo`:  
Интерактивная оболочка без входа в систему как `user2`  
`su`:  
`sudo`:

3. Какой файл запуска читается при запуске оболочки в разделе «Тип оболочки»?
| Тип оболочки | `/etc/profile` | `/etc/bash.bashrc` | `~/.profile` | `~/.bashrc` |
|--------------|----------------|--------------------|--------------|-------------|
| Оболочка интерактивного входа в систему как `user2` |||           |             |
| Интерактивная оболочка входа в систему с правами `root` |||       |             |    
| Интерактивная оболочка без входа в систему с правами `root` |||   |             | 
| Интерактивная оболочка без входа в систему как `user2` |||        |             |


## Упражнения на размышление




## Резюме




## Ответы на упражнения для закрепления




## Ответы на упражнения для размышления
