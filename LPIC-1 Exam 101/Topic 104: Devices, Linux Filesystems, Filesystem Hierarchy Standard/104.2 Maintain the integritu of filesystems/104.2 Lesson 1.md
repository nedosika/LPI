# 104.2 Урок 1

| Сертификат:   | LPIC-1                                      |
|:--------------|:--------------------------------------------|
| Версия:       | 5.0                                         |
| Тема:         | 104 устройства, файловые системы Linux, стандарт иерархии файловых систем |                           
| Цель:         | 104.1 Поддержание целостности файловых систем|
| Урок:         | 1 из 1                                      |


# Введение

Cовременные файловые системы Linux журналируемые. Это означает, что каждая операция перед выполнением регистрируется во внутреннем логе (the *journal*). Если операция прервана из-за системной ошибки (например, kernel panic, сбоя питания и т. д.), Ее можно восстановить, проверив журнал, чтобы избежать повреждения файловой системы и потери данных.

Это значительно снижает потребность в ручных проверках файловой системы, но они все равно могут понадобиться. Знание используемых для этого инструментов (и соответствующих параметров) может показать разницу между ужином дома с семьей или ночевкой в серверной на работе.

В этом уроке мы обсудим инструменты, доступные для мониторинга использования файловой системы, оптимизации ее работы, а также способы проверки и устранения повреждений.


# Проверка использования диска

Есть две команды, которые можно использовать для проверки того, сколько места используется и сколько осталось в файловой системе. Первый - `du`, что означает «disk usage»(использоваие диска).

`du` рекурсивен по своей природе. В своей самой простой форме команда просто покажет, сколько блоков размером 1 килобайт используется текущим каталогом и всеми его подкаталогами:
```
$ du
4816	.
```
Это не очень полезно, поэтому мы можем запросить более «удобочитаемый» вывод, добавив параметр `-h`:
```
$ du -h
4.8M	.
```
По умолчанию du показывает только счетчик использования каталогов (учитывая все файлы и подкаталоги внутри него). Чтобы показать индивидуальный счетчик для всех файлов в каталоге, используйте параметр `-a`:
```
$ du -ah
432K	./geminoid.jpg
508K	./Linear_B_Hero.jpg
468K	./LG-G8S-ThinQ-Mirror-White.jpg
656K	./LG-G8S-ThinQ-Range.jpg
60K	./Stranger3_Titulo.png
108K	./Baidu_Banho.jpg
324K	./Xiaomi_Mimoji.png
284K	./Mi_CC_9e.jpg
96K	./Mimoji_Comparativo.jpg
32K	./Xiaomi FCC.jpg
484K	./geminoid2.jpg
108K	./Mimoji_Abre.jpg
88K	./Mi8_Hero.jpg
832K	./Tablet_Linear_B.jpg
332K	./Mimoji_Comparativo.png
4.8M	.
```
Поведение по умолчанию - показать использование каждого подкаталога, а затем общее использование текущего каталога, включая подкаталоги:
```
$ du -h
4.8M	./Temp
6.0M	.
```
В приведенном выше примере мы видим, что подкаталог `Temp` занимает 4,8 МБ, а текущий каталог, *включая* `Temp`, занимает 6,0 МБ. Но сколько места занимают *файлы* в текущем каталоге, исключая подкаталоги? Для этого у нас есть параметр `-S`:
```
$ du -Sh
4.8M	./Temp
1.3M	.
```
>Помните, что параметры командной строки чувствительны к регистру: `-s` отличается от `-S`.

Если вы хотите сохранить это различие между пространством, используемым файлами в текущем каталоге, и пространством, используемым подкаталогами, но `также` хотите получить общий итог в конце, вы можете добавить параметр `-c`:
```
$ du -Shc
4.8M	./Temp
1.3M	.
6.0M	total
```
Вы можете контролировать, насколько «глубоким» должен быть вывод du с помощью параметра `-d N`, где `N` описывает уровни. Например, если вы используете параметр `-d 1`, он покажет текущий каталог и его подкаталоги, но не их подкаталоги.

Смотрите разницу ниже. Без `-d`:
```
$ du -h
216K	./somedir/anotherdir
224K	./somedir
232K	.
```
И ограничиваем глубину одним уровнем с помощью `-d 1`:
```
$ du -h -d1
224K	./somedir
232K	.
```
Обратите внимание, что даже если другой каталог не отображается, его размер все равно учитывается.

Вы можете исключить некоторые типы файлов из подсчета, что вы можете сделать с помощью `--exclude = "PATTERN"`, где `PATTERN` - это шаблон, с которым вы хотите сопоставить. Рассмотрим этот каталог:
```
$ du -ah
124K	./ASM68K.EXE
2.0M	./Contra.bin
36K	./fixheadr.exe
4.0K	./README.txt
2.1M	./Contra_NEW.bin
4.0K	./Built.bat
8.0K	./Contra_Main.asm
4.2M	.
```
Теперь мы будем использовать `--exclude`, чтобы отфильтровать каждый файл с расширением `.bin`:

Обратите внимание, что общая сумма больше не отражает размер исключенных файлов.
