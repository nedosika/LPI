# 104.2 Урок 1

| Сертификат:   | LPIC-1                                      |
|:--------------|:--------------------------------------------|
| Версия:       | 5.0                                         |
| Тема:         | 104 устройства, файловые системы Linux, стандарт иерархии файловых систем |                           
| Цель:         | 104.1 Поддержание целостности файловых систем|
| Урок:         | 1 из 1                                      |


# Введение

Cовременные файловые системы Linux журналируемые. Это означает, что каждая операция перед выполнением регистрируется во внутреннем логе (the *journal*). Если операция прервана из-за системной ошибки (например, kernel panic, сбоя питания и т. д.), Ее можно восстановить, проверив журнал, чтобы избежать повреждения файловой системы и потери данных.

Это значительно снижает потребность в ручных проверках файловой системы, но они все равно могут понадобиться. Знание используемых для этого инструментов (и соответствующих параметров) может показать разницу между ужином дома с семьей или ночевкой в серверной на работе.

В этом уроке мы обсудим инструменты, доступные для мониторинга использования файловой системы, оптимизации ее работы, а также способы проверки и устранения повреждений.


# Проверка использования диска

Есть две команды, которые можно использовать для проверки того, сколько места используется и сколько осталось в файловой системе. Первый - `du`, что означает «disk usage»(использоваие диска).

`du` рекурсивен по своей природе. В своей самой простой форме команда просто покажет, сколько блоков размером 1 килобайт используется текущим каталогом и всеми его подкаталогами:
```
$ du
4816	.
```
Это не очень полезно, поэтому мы можем запросить более «удобочитаемый» вывод, добавив параметр `-h`:
```
$ du -h
4.8M	.
```
По умолчанию du показывает только счетчик использования каталогов (учитывая все файлы и подкаталоги внутри него). Чтобы показать индивидуальный счетчик для всех файлов в каталоге, используйте параметр `-a`:
```
$ du -ah
432K	./geminoid.jpg
508K	./Linear_B_Hero.jpg
468K	./LG-G8S-ThinQ-Mirror-White.jpg
656K	./LG-G8S-ThinQ-Range.jpg
60K	./Stranger3_Titulo.png
108K	./Baidu_Banho.jpg
324K	./Xiaomi_Mimoji.png
284K	./Mi_CC_9e.jpg
96K	./Mimoji_Comparativo.jpg
32K	./Xiaomi FCC.jpg
484K	./geminoid2.jpg
108K	./Mimoji_Abre.jpg
88K	./Mi8_Hero.jpg
832K	./Tablet_Linear_B.jpg
332K	./Mimoji_Comparativo.png
4.8M	.
```
Поведение по умолчанию - показать использование каждого подкаталога, а затем общее использование текущего каталога, включая подкаталоги:
```
$ du -h
4.8M	./Temp
6.0M	.
```
В приведенном выше примере мы видим, что подкаталог `Temp` занимает 4,8 МБ, а текущий каталог, *включая* `Temp`, занимает 6,0 МБ. Но сколько места занимают *файлы* в текущем каталоге, исключая подкаталоги? Для этого у нас есть параметр `-S`:
```
$ du -Sh
4.8M	./Temp
1.3M	.
```
>Помните, что параметры командной строки чувствительны к регистру: `-s` отличается от `-S`.

Если вы хотите сохранить это различие между пространством, используемым файлами в текущем каталоге, и пространством, используемым подкаталогами, но `также` хотите получить общий итог в конце, вы можете добавить параметр `-c`:
```
$ du -Shc
4.8M	./Temp
1.3M	.
6.0M	total
```
Вы можете контролировать, насколько «глубоким» должен быть вывод du с помощью параметра `-d N`, где `N` описывает уровни. Например, если вы используете параметр `-d 1`, он покажет текущий каталог и его подкаталоги, но не их подкаталоги.

Смотрите разницу ниже. Без `-d`:
```
$ du -h
216K	./somedir/anotherdir
224K	./somedir
232K	.
```
И ограничиваем глубину одним уровнем с помощью `-d 1`:
```
$ du -h -d1
224K	./somedir
232K	.
```
Обратите внимание, что даже если другой каталог не отображается, его размер все равно учитывается.

Вы можете исключить некоторые типы файлов из подсчета, что вы можете сделать с помощью `--exclude = "PATTERN"`, где `PATTERN` - это шаблон, с которым вы хотите сопоставить. Рассмотрим этот каталог:
```
$ du -ah
124K	./ASM68K.EXE
2.0M	./Contra.bin
36K	./fixheadr.exe
4.0K	./README.txt
2.1M	./Contra_NEW.bin
4.0K	./Built.bat
8.0K	./Contra_Main.asm
4.2M	.
```
Теперь мы будем использовать `--exclude`, чтобы отфильтровать каждый файл с расширением `.bin`:
```
$ du -ah --exclude="*.bin"
124K	./ASM68K.EXE
36K	./fixheadr.exe
4.0K	./README.txt
4.0K	./Built.bat
8.0K	./Contra_Main.asm
180K	.
```

Обратите внимание, что общая сумма больше не отражает размер исключенных файлов.


# Проверка свободного места

`du` работает на уровне файлов. Есть еще одна команда, которая может показать вам использование диска и сколько места доступно на уровне файловой системы. Это команда `df`.

Команда `df` предоставит список всех доступных (уже смонтированных) файловых систем в вашей системе, включая их общий размер, сколько места было использовано, сколько места доступно, процент использования и место монтирования:
```
$ df
Filesystem     1K-blocks      Used Available Use% Mounted on
udev             2943068         0   2943068   0% /dev
tmpfs             595892      2496    593396   1% /run
/dev/sda1      110722904  25600600  79454800  25% /
tmpfs            2979440    951208   2028232  32% /dev/shm
tmpfs               5120         0      5120   0% /run/lock
tmpfs            2979440         0   2979440   0% /sys/fs/cgroup
tmpfs             595888        24    595864   1% /run/user/119
tmpfs             595888       116    595772   1% /run/user/1000
/dev/sdb1          89111      1550     80824   2% /media/carol/part1
/dev/sdb3          83187      1550     75330   3% /media/carol/part3
/dev/sdb2          90827      1921     82045   3% /media/carol/part2
/dev/sdc1      312570036 233740356  78829680  75% /media/carol/Samsung Externo
```
Однако показывать размер блоками по 1 КБ не очень удобно. Как и в случае с `du`, вы можете добавить параметры `-h`, чтобы получить более «удобочитаемый» вывод:
```
$ df -h
Filesystem      Size  Used Avail Use% Mounted on
udev            2.9G     0  2.9G   0% /dev
tmpfs           582M  2.5M  580M   1% /run
/dev/sda1       106G   25G   76G  25% /
tmpfs           2.9G  930M  2.0G  32% /dev/shm
tmpfs           5.0M     0  5.0M   0% /run/lock
tmpfs           2.9G     0  2.9G   0% /sys/fs/cgroup
tmpfs           582M   24K  582M   1% /run/user/119
tmpfs           582M  116K  582M   1% /run/user/1000
/dev/sdb1        88M  1.6M   79M   2% /media/carol/part1
/dev/sdb3        82M  1.6M   74M   3% /media/carol/part3
/dev/sdb2        89M  1.9M   81M   3% /media/carol/part2
/dev/sdc1       299G  223G   76G  75% /media/carol/Samsung Externo
```
Вы также можете использовать параметр `-i` для отображения используемых / доступных inode вместо блоков:
```
$ df -i
Filesystem      Inodes  IUsed   IFree IUse% Mounted on
udev            737142    547  736595    1% /dev
tmpfs           745218    908  744310    1% /run
/dev/sda6      6766592 307153 6459439    5% /
tmpfs           745218    215  745003    1% /dev/shm
tmpfs           745218      4  745214    1% /run/lock
tmpfs           745218     18  745200    1% /sys/fs/cgroup
/dev/sda1        62464    355   62109    1% /boot
tmpfs           745218     43  745175    1% /run/user/1000
```
Одним из полезных параметров является `-T`, который также выводит тип каждой файловой системы:
```
$ df -hT
Filesystem     Type      Size  Used Avail Use% Mounted on
udev           devtmpfs  2.9G     0  2.9G   0% /dev
tmpfs          tmpfs     582M  2.5M  580M   1% /run
/dev/sda1      ext4      106G   25G   76G  25% /
tmpfs          tmpfs     2.9G  930M  2.0G  32% /dev/shm
tmpfs          tmpfs     5.0M     0  5.0M   0% /run/lock
tmpfs          tmpfs     2.9G     0  2.9G   0% /sys/fs/cgroup
tmpfs          tmpfs     582M   24K  582M   1% /run/user/119
tmpfs          tmpfs     582M  116K  582M   1% /run/user/1000
/dev/sdb1      ext4       88M  1.6M   79M   2% /media/carol/part1
/dev/sdb3      ext4       82M  1.6M   74M   3% /media/carol/part3
/dev/sdb2      ext4       89M  1.9M   81M   3% /media/carol/part2
/dev/sdc1      fuseblk   299G  223G   76G  75% /media/carol/Samsung Externo
```
Зная тип файловой системы, вы можете фильтровать вывод. Вы можете показать только файловые системы заданного типа с помощью -`t TYPE` или исключить файловые системы заданного типа с помощью `-x TYPE`, как в примерах ниже. 

Исключая файловые системы `tmpfs`:
```
$ df -hx tmpfs
Filesystem      Size  Used Avail Use% Mounted on
udev            2.9G     0  2.9G   0% /dev
/dev/sda1       106G   25G   76G  25% /
/dev/sdb1        88M  1.6M   79M   2% /media/carol/part1
/dev/sdb3        82M  1.6M   74M   3% /media/carol/part3
/dev/sdb2        89M  1.9M   81M   3% /media/carol/part2
/dev/sdc1       299G  223G   76G  75% /media/carol/Samsung Externo
```
Показаны только файловые системы `ext4`:
```
$ df -ht ext4
Filesystem      Size  Used Avail Use% Mounted on
/dev/sda1       106G   25G   76G  25% /
/dev/sdb1        88M  1.6M   79M   2% /media/carol/part1
/dev/sdb3        82M  1.6M   74M   3% /media/carol/part3
/dev/sdb2        89M  1.9M   81M   3% /media/carol/part2
```
Вы также можете настроить вывод `df`, выбрав, что должно отображаться и в каком порядке, используя параметр `--output =`, за которым следует список полей, которые вы хотите отображать, через запятую. Некоторые из доступных полей:

`source` - Устройство, соответствующее файловой системе.

`fstype` - Тип файловой системы.

`size` - Общий размер файловой системы.

`used` - Сколько места используется.

`avail` - Сколько места доступно.

`pcent` - Процент использования.

`target` - Где смонтирована файловая система (точка монтирования).

Если вам нужен вывод, показывающий цель, источник, тип и использование, вы можете использовать:
```
$ df -h --output=target,source,fstype,pcent
Mounted on                    Filesystem     Type     Use%
/dev                          udev           devtmpfs   0%
/run                          tmpfs          tmpfs      1%
/                             /dev/sda1      ext4      25%
/dev/shm                      tmpfs          tmpfs     32%
/run/lock                     tmpfs          tmpfs      0%
/sys/fs/cgroup                tmpfs          tmpfs      0%
/run/user/119                 tmpfs          tmpfs      1%
/run/user/1000                tmpfs          tmpfs      1%
/media/carol/part1            /dev/sdb1      ext4       2%
/media/carol/part3            /dev/sdb3      ext4       3%
/media/carol/part2            /dev/sdb2      ext4       3%
/media/carol/Samsung Externo  /dev/sdc1      fuseblk   75%
```
`df` также можно использовать для проверки информации inode, передав следующие поля в `--output =`:

`itotal` - Общее количество индексных дескрипторов в файловой системе.

`iused` - Количество используемых inodes в файловой системе.

`iavail` - Количество доступных inodes в файловой системе.

`ipcent` - Процент используемых индексных дескрипторов в файловой системе.

Например:
```
$ df --output=source,fstype,itotal,iused,ipcent
Filesystem     Type      Inodes  IUsed IUse%
udev           devtmpfs  735764    593    1%
tmpfs          tmpfs     744858   1048    1%
/dev/sda1      ext4     7069696 318651    5%
tmpfs          tmpfs     744858    222    1%
tmpfs          tmpfs     744858      3    1%
tmpfs          tmpfs     744858     18    1%
tmpfs          tmpfs     744858     22    1%
tmpfs          tmpfs     744858     40    1%
```

# Поддержка файловых систем ext2, ext3 и ext4

Чтобы проверить файловую систему на наличие ошибок (и, надеюсь, исправить их), Linux предоставляет утилиту `fsck` (подумайте о «проверке файловой системы», и вы никогда не забудете ее название). В самой простой форме вы можете вызвать его с помощью `fsck`, за которым следует расположение файловой системы, которое вы хотите проверить:
```
# fsck /dev/sdb1
fsck from util-linux 2.33.1
e2fsck 1.44.6 (5-Mar-2019)
DT_2GB: clean, 20/121920 files, 369880/487680 blocks
```
>НИКОГДА не запускайте `fsck` (или связанные с ним утилиты) на смонтированной файловой системе. Если это все равно будет сделано, данные могут быть потеряны.

Сам `fsck` не будет проверять файловую систему, он просто вызовет соответствующую утилиту для этого типа файловой системы. В приведенном выше примере, поскольку тип файловой системы не был указан, `fsck` по умолчанию принял файловую систему ext2/3/4 и вызвал `e2fsck`.

Чтобы указать файловую систему, используйте параметр `-t`, за которым следует имя файловой системы, как в `fsck -t vfat /dev/sdc`. В качестве альтернативы вы можете напрямую вызвать утилиту, специфичную для файловой системы, например `fsck.msdos` для файловых систем FAT.

>Введите `fsck`, а затем дважды нажмите `Tab`, чтобы увидеть список всех связанных команд в вашей системе.

`fsck` может принимать некоторые аргументы командной строки. Вот некоторые из наиболее распространенных:

`-A` - Это проверит все файловые системы, перечисленные в /etc/fstab.

`-C` - Отображает индикатор выполнения при проверке файловой системы. В настоящее время работает только с файловыми системами ext2/3/4.

`-N` - Выведет, что сделано, и выйдет, фактически не проверяя файловую систему.

`-R` - При использовании вместе с `-A` это пропускает проверку корневой файловой системы.

`-V` - Подробный режим, во время работы печатается больше информации, чем обычно. Это полезно для отладки.

Специальная утилита для файловых систем ext2, ext3 и ext4 - это `e2fsck`, также называемая `fsck.ext2`, `fsck.ext3` и `fsck.ext4` (эти три являются просто ссылками на `e2fsck`). По умолчанию он работает в интерактивном режиме: при обнаружении ошибки файловой системы он останавливается и спрашивает пользователя, что делать. Пользователь должен ввести `y`, чтобы исправить проблему, `n`, чтобы оставить ее нерешенной, или `a`, чтобы исправить текущую проблему и все последующие.

Конечно, сидеть перед терминалом и ждать, пока e2fsck спросит, что делать, - непродуктивное использование вашего времени, особенно если вы имеете дело с большой файловой системой. Итак, есть параметры, которые заставляют `e2fsck` работать в неинтерактивном режиме:

`-p` - Это попытается автоматически исправить все обнаруженные ошибки. Если обнаружена ошибка, требующая вмешательства системного администратора, `e2fsck` предоставит описание проблемы и завершит работу.

`-y` - Это ответит `y` (да) на все вопросы.

`-n` - Противоположность `-y`. Помимо ответа `n` (нет) на все вопросы, это приведет к монтированию файловой системы только для чтения, поэтому ее нельзя будет изменить.

`-f` - Заставляет `e2fsck` проверять файловую систему, даже если она помечена как «чистая», т.е. была правильно размонтирована.


# Тонкая настройка файловой системы ext

Файловые системы ext2, ext3 и ext4 имеют ряд параметров, которые могут быть отрегулированы или «настроены» системным администратором в соответствии с потребностями системы. Утилита, используемая для отображения или изменения этих параметров, называется `tune2fs`.

Чтобы увидеть текущие параметры для любой данной файловой системы, используйте параметр `-l`, за которым следует устройство, представляющее раздел. В приведенном ниже примере показан вывод этой команды на первом разделе первого диска (`/dev/sda1`) машины:
```
# tune2fs -l /dev/sda1
tune2fs 1.44.6 (5-Mar-2019)
Filesystem volume name:   <none>
Last mounted on:          /
Filesystem UUID:          6e2c12e3-472d-4bac-a257-c49ac07f3761
Filesystem magic number:  0xEF53
Filesystem revision #:    1 (dynamic)
Filesystem features:      has_journal ext_attr resize_inode dir_index filetype needs_recovery extent 64bit flex_bg sparse_super large_file huge_file dir_nlink extra_isize metadata_csum
Filesystem flags:         signed_directory_hash
Default mount options:    user_xattr acl
Filesystem state:         clean
Errors behavior:          Continue
Filesystem OS type:       Linux
Inode count:              7069696
Block count:              28255605
Reserved block count:     1412780
Free blocks:              23007462
Free inodes:              6801648
First block:              0
Block size:               4096
Fragment size:            4096
Group descriptor size:    64
Reserved GDT blocks:      1024
Blocks per group:         32768
Fragments per group:      32768
Inodes per group:         8192
Inode blocks per group:   512
Flex block group size:    16
Filesystem created:       Mon Jun 17 13:49:59 2019
Last mount time:          Fri Jun 28 21:14:38 2019
Last write time:          Mon Jun 17 13:53:39 2019
Mount count:              8
Maximum mount count:      -1
Last checked:             Mon Jun 17 13:49:59 2019
Check interval:           0 (<none>)
Lifetime writes:          20 GB
Reserved blocks uid:      0 (user root)
Reserved blocks gid:      0 (group root)
First inode:              11
Inode size:	          256
Required extra isize:     32
Desired extra isize:      32
Journal inode:            8
First orphan inode:       5117383
Default directory hash:   half_md4
Directory Hash Seed:      fa95a22a-a119-4667-a73e-78f77af6172f
Journal backup:           inode blocks
Checksum type:            crc32c
Checksum:                 0xe084fe23
```
В файловых системах ext есть *mount counts*(счетчики монтирования). Счетчик увеличивается на 1 каждый раз при монтировании файловой системы, и когда достигается пороговое значение (максимальное количество монтируемых файлов), система будет автоматически проверяться с помощью `e2fsck` при следующей загрузке.

Максимальное количество монтируемых файлов можно установить с помощью параметра `-c N`, где `N` - это количество раз, когда файловая система может быть смонтирована без проверки. Параметр `-C N` устанавливает, сколько раз система монтировалась на значение `N`. Обратите внимание, что параметры командной строки чувствительны к регистру, поэтому `-c` отличается от `-C`.

Также можно определить временной интервал между проверками с помощью параметра `-i`, за которым следует число и буквы `d` для дней, `m` для месяцев и `y` для лет. Например, `-i 10d` будет проверять файловую систему при следующей перезагрузке каждые 10 дней. Используйте ноль в качестве значения, чтобы отключить эту функцию.

`-L` можно использовать для установки метки для файловой системы. Эта метка может содержать до 16 символов. Параметр `-U` устанавливает UUID для файловой системы, который представляет собой 128-битное шестнадцатеричное число.  приведенном выше примере UUID - `6e2c12e3-472d-4bac-a257-c49ac07f3761`. И метку, и UUID можно использовать вместо имени устройства (например, `/dev/sda1`) для монтирования файловой системы.

Параметр `-e BEHAVIOR` определяет поведение ядра при обнаружении ошибки файловой системы. Возможны три варианта поведения:

`continue` - Продолжит выполнение в обычном режиме.
`remount-ro` - Перемонтирует файловую систему как доступную только для чтения.
`panic` - Вызовет a kernel panic.

Поведение по умолчанию - продолжить. `remount-ro` может быть полезен в приложениях, чувствительных к данным, поскольку он немедленно останавливает запись на диск, избегая большего количества потенциальных ошибок.

Файловые системы ext3 - это в основном файловые системы ext2 с журналом. Используя `tune2fs`, вы можете добавить журнал в файловую систему ext2, таким образом преобразовав его в ext3. Процедура проста, просто передайте параметр `-j` в `tune2fs`, а затем укажите устройство, содержащее файловую систему:
```
# tune2fs -j /dev/sda1
```
После этого при монтировании преобразованной файловой системы не забудьте установить тип `ext3`, чтобы можно было использовать журнал. 

При работе с журналируемыми файловыми системами параметр `-J` позволяет вам использовать дополнительные параметры для установки некоторых параметров журнала, например `-J size =` для установки размера журнала (в мегабайтах), `-J location =` указать, где должен храниться журнал (либо конкретный блок, либо определенная позиция на диске с суффиксами, такими как `M` или `G`), и даже поместить журнал на внешнее устройство с помощью `-J device =`.

Вы можете указать сразу несколько параметров, разделив их запятыми. Например: `-J size=10,location=100M,device=/dev/sdb1` создаст журнал размером 10 МБ в позиции 100 МБ на устройстве `/dev/sdb1`.

>`tune2fs` имеет параметр «brute force» `-f`, который заставит его завершить операцию, даже если будут обнаружены ошибки. Излишне говорить, что это следует использовать с особой осторожностью.


# Поддержка файловых систем XFS

Для файловых систем XFS эквивалентом `fsck` является `xfs_repair`. Если вы подозреваете, что с файловой системой что-то не так, первое, что нужно сделать, - это просканировать ее на предмет повреждений.

Это можно сделать, передав параметр `-n` в `xfs_repair`, а затем - устройство, содержащее файловую систему. Параметр `-n` означает «без изменений»: файловая система будет проверена, будут сообщаться об ошибках, но исправления производиться не будут:
```
# xfs_repair -n /dev/sdb1
Phase 1 - find and verify superblock...
Phase 2 - using internal log
        - zero log...
        - scan filesystem freespace and inode maps...
        - found root inode chunk
Phase 3 - for each AG...
        - scan (but do not clear) agi unlinked lists...
        - process known inodes and perform inode discovery...
        - agno = 0
        - agno = 1
        - agno = 2
        - agno = 3
        - process newly discovered inodes...
Phase 4 - check for duplicate blocks...
        - setting up duplicate extent list...
        - check for inodes claiming duplicate blocks...
        - agno = 1
        - agno = 3
        - agno = 0
        - agno = 2
No modify flag set, skipping phase 5
Phase 6 - check inode connectivity...
        - traversing filesystem ...
        - traversal finished ...
        - moving disconnected inodes to lost+found ...
Phase 7 - verify link counts...
No modify flag set, skipping filesystem flush and exiting.
```
Если обнаружены ошибки, вы можете приступить к ремонту без параметра `-n`, например: `xfs_repair /dev/sdb1`. 

`xfs_repair` принимает ряд параметров командной строки. Среди них:

`-l LOGDEV` и `-r RTDEV`
>Они необходимы, если файловая система имеет разделы внешнего журнала и реального времени. В этом случае замените LOGDEV и RTDEV соответствующими устройствами.

`-m N`
>Используется для ограничения использования памяти `xfs_repair` до `N` мегабайт, что может быть полезно в настройках сервера. Согласно странице руководства, по умолчанию `xfs_repair` масштабирует использование памяти по мере необходимости до 75% физической памяти системы.

`-d`
>«Опасный» режим позволит восстановить файловые системы, смонтированные только для чтения.

`-v`
>Вы, наверное, догадались: подробный режим. Каждый раз, когда используется этот параметр, «подробность» увеличивается (например, `-v -v` выведет больше информации, чем просто `-v`).


Обратите внимание, что `xfs_repair` не может восстанавливать файловые системы с «грязным» журналом. Вы можете «обнулить» поврежденный журнал с помощью параметра `-L`, но имейте в виду, что это крайний метод, поскольку он может привести к повреждению файловой системы и потере данных.

Для отладки файловой системы XFS можно использовать утилиту `fs_db`, как в `xfs_db /dev/sdb1`. В основном это используется для проверки различных элементов и параметров файловой системы.

Эта утилита имеет интерактивную подсказку, как и `parted`, со многими внутренними командами. Также доступна справочная система: введите `help`, чтобы увидеть список всех команд, и `help`, за которым следует имя команды, чтобы увидеть дополнительную информацию о команде.

Еще одна полезная утилита - `xfs_fsr`, которую можно использовать для реорганизации («дефрагментации») файловой системы XFS. При выполнении без каких-либо дополнительных аргументов он будет работать в течение двух часов и попытается дефрагментировать все смонтированные файловые системы XFS с возможностью записи, перечисленные в файле `/etc/mtab/`. Вам может потребоваться установить эту утилиту с помощью диспетчера пакетов для вашего дистрибутива Linux, поскольку он может не входить в стандартную установку. Для получения дополнительной информации обратитесь к соответствующей странице руководства.


# Упражнения для закрепления

1. Используя `du`, как мы можем проверить, сколько места используется только файлами в текущем каталоге?
2. Используя `df`, перечислите информацию для каждой файловой системы ext4 с выходными данными, включая следующие поля, по порядку: устройство, точка монтирования, общее количество inodes, количество доступных inodes, процент свободного места.
3. Какая команда запускает `e2fsck` на `/dev/sdc1` в неинтерактивном режиме, пытаясь автоматически исправить большинство ошибок?
4. Предположим, `/dev/sdb1` - файловая система ext2. Как вы можете преобразовать его в ext3, и в то же время сбросить его счетчик монтирования и изменить его метку на `UserData`?
5. Как вы можете проверить наличие ошибок в файловой системе XFS, не исправляя обнаруженные повреждения?


# Упражнения на размышления

1. Предположим, у вас есть файловая система ext4 на `/dev/sda1` со следующими параметрами, полученными с помощью `tune2fs`:
```
Mount count:              8
Maximum mount count:      -1
```
Что будет при следующей загрузке, если будет введена команда `tune2fs -c 9 /dev/sda1`?

2. Рассмотрим следующий вывод `du -h`:
```
$ du -h
216K	./somedir/anotherdir
224K	./somedir
232K	.
```
Сколько места занимают только файлы в текущем каталоге? Как мы могли бы переписать команду, чтобы эта информация отображалась более четко?

3. Что произойдет с файловой системой ext2 `/dev/sdb1`, если будет введена указанная ниже команда?
```
# tune2fs -j /dev/sdb1 -J device=/dev/sdc1 -i 30d
```
4. Как мы можем проверить наличие ошибок в файловой системе XFS на `/dev/sda1`, которая имеет раздел журнала на `/dev/sdc1`, без фактического ремонта?
5. В чем разница между параметрами `-T` и `-t` для `df`?


# Резюме

На этом уроке вы узнали:

* Как проверить используемое и свободное место в файловой системе. 
* Как настроить вывод `df` под свои нужды. 
* Как проверить целостность и восстановить файловую систему с помощью `fsck` и `e2fsck`.
* Как настроить файловую систему ext с помощью `tune2fs`. 
* Как проверить и восстановить файловые системы XFS с помощью `xfs_repair`.

В этом уроке обсуждались следующие команды:

`du` - Просмотр количества используемого дискового пространства в файловой системе.
`df` - Просмотр объема доступного (свободного) дискового пространства в файловой системе.
`fsck` - Утилита восстановления файловой системы.
`e2fsck` - Утилита восстановления для проверки файловой системы, специфичная для расширенных (ext2/3/4) файловых систем.
`tune2fs` - Изменяет параметры файловой системы в расширенной (ext2/3/4) файловой системе.
`xfs_repair` - Эквивалент `fsck` для файловых систем XFS.
`xfs_db` - Эта утилита используется для просмотра различных параметров файловой системы XFS.


# Ответы на упражнения для закрепления


# Ответы на упражнения для размышления
