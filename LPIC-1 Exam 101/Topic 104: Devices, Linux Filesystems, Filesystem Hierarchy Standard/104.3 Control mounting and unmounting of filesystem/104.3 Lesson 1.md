# 104.1 Урок 1

| Сертификат:   | LPIC-1                                      |
|:--------------|:--------------------------------------------|
| Версия:       | 5                                           |
| Тема:         | 104 устройства, файловые системы Linux, стандарт иерархии файловых систем |                           
| Цель:         | 104.3 Контроль монтирования и размонтирования файловых систем |
| Урок:         | 1 из 1                                      |


# Введение

Ранее вы узнали как разбивать диски на разделы, а также как создавать и настравиать на них файловые системы. Однако, прежде чем к файловой системе получить доступ в Linux, ее необходимо смонтировать.

Прикрепление файловой системы к определенной точке в дереве каталогов вашей системы называется точкой монтирования. Файловые системы можно монтировать вручную или автоматически, и есть много способов сделать это. О некоторых из них мы узнаем в этом уроке.


# Монтирование и размонтирование файловых систем

Команда для ручного монтирования файловой системы называется `mount` и имеет синтаксис:
```
mount -t TYPE DEVICE MOUNTPOINT
```
Где:

`TYPE` - Тип монтируемой файловой системы (например, ext4, btrfs, exfat и т. д.).

`DEVICE` - Имя раздела, содержащего файловую систему (например, /dev/sdb1)

`MOUNTPOINT` - Где будет смонтирована файловая система. Примонтированный каталог не обязательно должен быть пустым, хотя он должен существовать. Однако любые файлы в нем будут недоступны по имени, пока файловая система смонтирована.

Например, чтобы смонтировать USB-накопитель, содержащий файловую систему exFAT, расположенный на `/dev/sdb1`, в каталог `flash` в вашем домашнем каталоге, вы можете использовать:
```
# mount -t exfat /dev/sdb1 ~/flash/
```
>Многие системы Linux используют оболочку Bash, и в них тильда `~` на пути к точке монтирования является сокращением для домашнего каталога текущего пользователя. Например, если текущего пользователя зовут `john`, он будет заменен на `/home/john`.

После монтирования содержимое файловой системы будет доступно в каталоге `~/flash`:
```
$  ls -lh ~/flash/
total 469M
-rwxrwxrwx 1 root root 454M jul 19 09:49 lineage-16.0-20190711-MOD-quark.zip
-rwxrwxrwx 1 root root  16M jul 19 09:44 twrp-3.2.3-mod_4-quark.img
```


# Вывод подключенных файловых систем

Если вы наберете просто `mount`, вы получите список всех файловых систем, смонтированных в настоящее время в вашей системе. Этот список может быть довольно большим, потому что помимо дисков, подключенных к вашей системе, он также содержит ряд исполняемых файловых систем в памяти, которые служат различным целям. Чтобы отфильтровать вывод, вы можете использовать параметр `-t` для вывода списка только файловых систем соответствующего типа, как показано ниже:
```
# mount -t ext4
/dev/sda1 on / type ext4 (rw,noatime,errors=remount-ro)
```
Вы можете указать несколько файловых систем одновременно, разделив их запятыми:
```
# mount -t ext4,fuseblk
/dev/sda1 on / type ext4 (rw,noatime,errors=remount-ro)
/dev/sdb1 on /home/carol/flash type fuseblk (rw,nosuid,nodev,relatime,user_id=0,group_id=0,default_permissions,allow_other,blksize=4096) [DT_8GB]
```
Вывод в приведенных выше примерах можно описать в формате:
```
SOURCE on TARGET type TYPE OPTIONS
```
Где `SOURCE` - это раздел, содержащий файловую систему, `TARGET` - это каталог, в котором он смонтирован, `TYPE` - это тип файловой системы, а `OPTIONS` - это параметры, переданные команде монтирования во время монтирования.


# Дополнительные параметры командной строки

Есть много параметров командной строки, которые можно использовать с `mount`. Вот некоторые из наиболее часто используемых:

-a 
>Это смонтирует все файловые системы, перечисленные в файле `/etc/fstab` (подробнее об этом в следующем разделе).

-o или --options
>Это передаст список параметров монтирования, разделенных запятыми, в команду `mount`, которая может изменить способ монтирования файловой системы. Это также будет обсуждаться вместе с файлом `/etc/fstab`.

-r или -ro
>Это смонтирует файловую систему как доступную только для чтения.

-w или -rw
>то сделает файловую систему монтируемой как доступной для записи.

Чтобы размонтировать файловую систему, используйте команду `umount`, за которой следует имя устройства или точка монтирования. Учитывая приведенный выше пример, приведенные ниже команды взаимозаменяемы:
```
# umount /dev/sdb1
# umount ~/flash
```

Некоторые из параметров командной строки для `umount`:

-a
>Это отключит все файловые системы, перечисленные в `/etc/fstab`.

-f
>Это приведет к отключению файловой системы. Это может быть полезно, если вы смонтировали удаленную файловую систему, которая стала недоступной.

-r
>Если файловая система не может быть размонтирована, она попытается сделать ее доступной только для чтения.


# Работа с открытыми файлами

При размонтировании файловой системы вы можете столкнуться с сообщением об ошибке о том, что `target is busy`. Это происходит, если какие-либо файлы в файловой системе открыты. Однако может быть не сразу очевидно, где находится открытый файл или к чему осуществляется доступ к файловой системе.

В таких случаях вы можете использовать команду `lsof`, за которой следует имя устройства, содержащего файловую систему, чтобы увидеть список процессов, обращающихся к нему, и какие файлы открыты. Например:
```
# umount /dev/sdb1
umount: /media/carol/External_Drive: target is busy.

# lsof /dev/sdb1
COMMAND  PID   USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
evince  3135 carol   16r   REG   8,17 21881768 5195 /media/carol/External_Drive/Documents/E-Books/MagPi40.pdf
```
`COMMAND` - это имя исполняемого файла, открывшего файл, а `PID` - это номер процесса. `NAME` - это имя открытого файла. В приведенном выше примере файл `MagPi40.pdf` открывается программой `evince` (просмотрщик PDF-файлов). Если мы закроем программу, мы сможем размонтировать файловую систему.

>Прежде чем появится вывод `lsof`, пользователи `GNOME` могут увидеть предупреждающее сообщение в окне терминала.
```
lsof: WARNING: can't stat() fuse.gvfsd-fuse file system /run/user/1000/gvfs
Output information may be incomplete.
```
>`lsof` пытается обработать все смонтированные файловые системы. Это предупреждающее сообщение появляется, потому что `lsof` обнаружил виртуальную файловую систему `GNOME` (GVFS). Это особый случай файловой системы в пространстве пользователя (`FUSE`). Он действует как мост между `GNOME`, его API и ядром. Никто - даже root - не может получить доступ к одной из этих файловых систем, кроме владельца, смонтировавшего ее (в данном случае `GNOME`). Вы можете игнорировать это предупреждение.


# Куда смонтировать?

Вы можете смонтировать файловую систему где угодно. Однако есть некоторые передовые методы, которым следует следовать, чтобы упростить системное администрирование.

Традиционно `/mnt` был каталогом, в котором монтируются все внешние устройства, а также ряд предварительно настроенных «точек привязки» для общих устройств, таких как приводы CD-ROM (`/mnt/cdrom`) и гибкие диски (`/mnt/floppy`) внутри него.

Он был заменен на `/media`, который теперь является точкой монтирования по умолчанию для любых съемных носителей (например, внешних дисков, USB-накопителей, устройств чтения карт памяти и т. Д.), подключенных к системе.

В большинстве современных дистрибутивов Linux и окружений рабочего стола съемные устройства автоматически монтируются в `/media/USER/LABEL` при подключении к системе, где `USER` - это имя пользователя, а `LABEL` - это метка устройства. Например, USB-накопитель с меткой `FlashDrive`, подключенный пользователем `john`, будет смонтирован в `/media/john/FlashDrive/`. То, как это делается, зависит от среды рабочего стола.

При этом всякий раз, когда вам нужно вручную смонтировать файловую систему, рекомендуется смонтировать ее в `/mnt`.


# Монтирование файловых систем при загрузке

Файл `/etc/fsta` содержит описания файловых систем, которые можно смонтировать. Это текстовый файл, каждая строка которого описывает монтируемую файловую систему с шестью полями в строке в следующем порядке:
```
FILESYSTEM MOUNTPOINT TYPE OPTIONS DUMP PASS
```
Где:

`FILESYSTEM`
>Устройство, содержащее монтируемую файловую систему. Вместо устройства вы можете указать UUID или метку раздела, что мы обсудим позже.

`MOUNTPOINT`
>Где будет смонтирована файловая система.

`TYPE`
>Тип файловой системы.

`OPTIONS`
>Параметры монтирования, которые будут переданы в mount.

`DUMP`
>Указывает, какие файловые системы ext2, ext3 или ext4 следует рассматривать для резервного копирования командой `dump`. Обычно это ноль, что означает, что их следует игнорировать.

`PASS`
>Если ненулевое значение, определяет порядок, в котором файловые системы будут проверяться при загрузке. Обычно это ноль.

Например, первый раздел на первом диске машины можно описать как:
```
/dev/sda1  /  ext4  noatime,errors
```
Параметры монтирования в `OPTIONS` представляют собой список параметров, разделенных запятыми, которые могут быть общими или специфичными для файловой системы. Среди общих у нас есть:

`atime` и `noatime`
>По умолчанию каждый раз при чтении файла обновляется информация о времени доступа. Отключение этого (с помощью `noatime`) может ускорить дисковый ввод-вывод. Не путайте это со временем модификации, которое обновляется каждый раз при записи файла.

`auto` и `noauto`
>Может ли файловая система (или не может) быть смонтирована автоматически с помощью `mount -a`.

`defaults`
>Это передаст параметры `rw`, `suid`, `dev`, `exec`, `auto`, `nouser` и `async` для монтирования.

`dev` и `nodev`
>Следует ли интерпретировать символьные или блочные устройства в смонтированной файловой системе.

`exec` и `noexec`
>Разрешить или запретить разрешение на выполнение двоичных файлов в файловой системе.

`user` и `nouser`
>Разрешает (или запрещает) монтировать файловую систему обычному пользователю.

`group`
>Позволяет пользователю монтировать файловую систему, если пользователь принадлежит к той же группе, которой принадлежит устройство, содержащее ее.

`owner`
>Позволяет пользователю монтировать файловую систему, если пользователь владеет устройством, содержащим ее.

`suid` и `nosuid`
>Разрешить или запретить битам SETUID и SETGID вступить в силу.

`ro` и `rw`
>Смонтируйте файловую систему как доступную только для чтения или запись.

`remount`
>Это попытается перемонтировать уже смонтированную файловую систему. Это не используется в `/etc/fstab`, но используется как параметр для монтирования `-o`. Например, чтобы перемонтировать уже смонтированный раздел `/dev/sdb1` как доступный только для чтения, вы можете использовать команду `mount -o remount`, `ro /dev/sdb1`. При повторном монтировании вам не нужно указывать тип файловой системы, только имя устройства или точку монтирования.

`sync` и `async`
>Следует ли выполнять все операции ввода-вывода с файловой системой синхронно или асинхронно. `async` обычно используется по умолчанию. Страница руководства по `mount` предупреждает, что использование `sync` на носителе с ограниченным числом циклов записи (например, флэш-накопителях или картах памяти) может сократить срок службы устройства.


# Использование UUID и меток

Указание имени устройства, содержащего монтируемую файловую систему, может вызвать некоторые проблемы. Иногда одно и то же имя устройства может быть назначено другому устройству в зависимости от того, когда и где оно было подключено к вашей системе. Например, флэш-накопитель USB на `/dev/sdb1` может быть назначен `/dev/sdc1`, если он подключен к другому порту, или после другого флэш-накопителя.

Один из способов избежать этого - указать метку или UUID (универсальный уникальный идентификатор) тома. Оба они указываются при создании файловой системы и не изменятся, если файловая система не будет уничтожена или вручную не будет присвоена новая метка или UUID.

Команду `lsblk` можно использовать для запроса информации о файловой системе и определения связанной с ней метки и UUID. Для этого используйте параметр `-f`, за которым следует имя устройства:
```
$ lsblk -f /dev/sda1
NAME FSTYPE LABEL UUID                                 FSAVAIL FSUSE% MOUNTPOINT
sda1 ext4         6e2c12e3-472d-4bac-a257-c49ac07f3761   64,9G    33% /
```
Вот значение каждого столбца:

`NAME`
>Имя устройства, содержащего файловую систему.

`FSTYPE`
>Тип файловой системы.

`LABEL`
>Метка файловой системы.

`UUID`
>Универсальный уникальный идентификатор (UUID), присвоенный файловой системе.

`FSAVAIL`
>Сколько места доступно в файловой системе.

`FSUSE%`
>Процент использования файловой системы.

`MOUNTPOINT`
>де смонтирована файловая система.

В `/etc/fstab` устройство может быть указано с помощью его UUID с параметром `UUID=`, за которым следует UUID, или с помощью `LABEL=`, за которым следует метка. Итак, вместо:
```
/dev/sda1  /  ext4  noatime,errors
```
Вы бы использовали:
```
UUID=6e2c12e3-472d-4bac-a257-c49ac07f3761  /  ext4  noatime,errors
```
Или, если у вас есть диск с пометкой `homedisk`:
```
LABEL=homedisk  /home ext4  defaults
```
Тот же синтаксис можно использовать с командой `mount`. Вместо имени устройства передайте UUID или метку. Например, чтобы смонтировать внешний NTFS-диск с UUID `56C11DCC5D2E1334` в `/mnt/external`, команда будет выглядеть так:
```
$ mount -t ntfs UUID=56C11DCC5D2E1334 /mnt/external
```


# Монтирование дисков с помощью Systemd

*Systemd* - это процесс инициализации, первый процесс, запускаемый во многих дистрибутивах Linux. Он отвечает за запуск других процессов, запуск служб и загрузку системы. Среди множества других задач systemd также можно использовать для управления монтированием (и автоматическим монтированием) файловых систем.

Чтобы использовать эту функцию systemd, вам необходимо создать файл конфигурации, называемый *mount unit*(модулем монтирования). Каждый монтируемый том получает свой собственный модуль монтирования, и они должны быть размещены в `/etc/systemd/system/`.

Модули монтирования - это простые текстовые файлы с расширением `.mount`. Базовый формат показан ниже:
```
[Unit]
Description=

[Mount]
What=
Where=
Type=
Options=

[Install]
WantedBy=
```
`Description=`
>Краткое описание модуля монтирования, что-то вроде `Mounts the backup disk`.

`What=`
>Что надо смонтировать. Том должен быть указан как `/dev/disk/by-uuid/VOL_UUID`, где `VOL_UUID` - это UUID тома.

`Where=`
>Должен быть полный путь к тому месту, где должен быть смонтирован том.

`Type=`
>Тип файловой системы.

`Options=`
>Параметры монтирования, которые вы, возможно, захотите передать, те же, что используются с командой mount или в `/etc/fstab`.

`WantedBy=`
>Используется для управления зависимостями. В этом случае мы будем использовать `multi-user.target`, что означает, что всякий раз, когда система загружается в многопользовательскую среду (обычная загрузка), модуль будет монтироваться.

Наш предыдущий пример внешнего диска мог быть записан как:
```
[Unit]
Description=External data disk

[Mount]
What=/dev/disk/by-uuid/56C11DCC5D2E1334
Where=/mnt/external
Type=ntfs
Options=defaults

[Install]
WantedBy=multi-user.target
```
Но мы еще не закончили. Для правильной работы модуль монтирования должен иметь то же имя, что и точка монтирования. В этом случае точка монтирования - `/mnt/external`, поэтому файл должен называться `mnt-external.mount`.

После этого вам нужно перезапустить демон systemd с помощью команды `systemctl` и запустить модуль:
```
# systemctl daemon-reload
# systemctl start mnt-external.mount
```
Теперь содержимое внешнего диска должно быть доступно в `/mnt/external`. Вы можете проверить статус монтирования с помощью команды `systemctl status mnt-external.mount`, как показано ниже:
```
# systemctl status mnt-external.mount
● mnt-external.mount - External data disk
   Loaded: loaded (/etc/systemd/system/mnt-external.mount; disabled; vendor pres
   Active: active (mounted) since Mon 2019-08-19 22:27:02 -03; 14s ago
    Where: /mnt/external
     What: /dev/sdb1
    Tasks: 0 (limit: 4915)
   Memory: 128.0K
   CGroup: /system.slice/mnt-external.mount

ago 19 22:27:02 pop-os systemd[1]: Mounting External data disk...
ago 19 22:27:02 pop-os systemd[1]: Mounted External data disk.
```
Команда `systemctl start mnt-external.mount` включит модуль только для текущего сеанса. Если вы хотите включать его при каждой загрузке, замените `start` на `enable`:
```
# systemctl enable mnt-external.mount
```


# Автомонтирование блочных устройств

Монтируемые блочные устройства можно автоматически монтировать при каждом доступе к точке монтирования. Для этого вам понадобится файл `.automount` вместе с файлом `.mount` с описанием устройства. Базовый формат:
```
[Unit]
Description=

[Automount]
Where=

[Install]
WantedBy=multi-user.target
```
Как и раньше,`Description=` - это краткое описание файла, а `Where=` - точка монтирования. Например, файл `.automount` для нашего предыдущего примера будет выглядеть так:
```
[Unit]
Description=Automount for the external data disk

[Automount]
Where=/mnt/external

[Install]
WantedBy=multi-user.target
```
Сохраните файл с тем же именем, что и точка монтирования (в данном случае `mnt-external.automount`), перезагрузите `systemd` и запустите модуль:
```
# systemctl daemon-reload
# systemctl start mnt-external.automount
```
Теперь при каждом обращении к каталогу `/mnt/external` диск будет смонтирован. Как и раньше, чтобы включить автоматическое монтирование при каждой загрузке, вы должны:
```
# systemctl enable mnt-external.automount
```

# Упражнения для закрепления

1. Используя mount, как вы можете смонтировать файловую систему ext4 на `/dev/sdc1` в `/mnt/external` как доступную только для чтения, используя параметры `noatime` и `async`?
2. При размонтировании файловой системы в `/dev/sdd2` вы получаете сообщение об ошибке `target is busy`. Как узнать, какие файлы в файловой системе открыты и какие процессы открывали их?
3. Рассмотрим следующую запись в `/etc/fstab`: `/dev/sdb1 /data ext4 noatime, noauto, async`. Будет ли эта файловая система смонтирована, если будет введена команда `mount -a`? Почему?
4. Как узнать UUID файловой системы в `/dev/sdb1`?
5. Как вы можете использовать `mount` для перемонтирования файловой системы exFAT в режиме «только чтение» с UUID `6e2c12e3-472d-4bac-a257-c49ac07f3761`, смонтированной в `/mnt/data`?
6. Как получить список всех файловых систем `ext3` и `ntfs`, смонтированных в настоящее время в системе?


# Упражнения на размышления

1. Рассмотрим следующую запись в `/etc/fstab`: `/dev/sdc1 /backup ext4 noatime, nouser, async`. Может ли пользователь смонтировать эту файловую систему с помощью команды `mount /backup`? Почему?
2. Рассмотрим удаленную файловую систему, смонтированную в `/mnt/server`, которая стала недоступной из-за потери сетевого подключения. Как вы могли заставить его быть размонтированным или монтируемым только для чтения, если это невозможно?
3. Напишите запись в `/etc/fstab`, которая будет монтировать том `btrfs` с меткой Backup на `/mnt/backup`, с параметрами по умолчанию и без разрешения выполнения из него двоичных файлов.
4. Рассмотрим следующий модуль монтирования `systemd`:
```
[Unit]
Description=External data disk

[Mount]
What=/dev/disk/by-uuid/56C11DCC5D2E1334
Where=/mnt/external
Type=ntfs
Options=defaults

[Install]
WantedBy=multi-user.target
```
Что было бы эквивалентной записью в `/etc/fstab` для этой файловой системы?

5. Каким должно быть имя файла для указанного выше модуля, чтобы его могла использовать `systemd`? Где его разместить?


# Резюме

В этом уроке вы узнали, как монтировать и размонтировать файловые системы вручную или автоматически. Вот некоторые из объясненных команд и концепций:

* `mount` (устанавливает устройство в определенное место) 
* `umount` (отключает устройство) 
* `lsof` (перечисляет процессы, обращающиеся к файловой системе) 
* `/mnt` и `/media` каталоги 
* `/etc/fstab`
* `lsblk` (перечисляет тип и UUID файловой системы) 
* Как смонтировать файловую систему, используя ее UUID или метку. 
* Как смонтировать файловую систему с помощью модулей монтирования systemd. 
* Как автоматически смонтировать файловую систему с помощью модулей монтирования systemd.

# Ответы на упражнения для закрепления

1. Используя mount, как вы можете смонтировать файловую систему ext4 на `/dev/sdc1` в `/mnt/external` как доступную только для чтения, используя параметры `noatime` и `async`?
```
# mount -t ext4 -o noatime,async,ro /dev/sdc1 /mnt/external
```
2. При размонтировании файловой системы в `/dev/sdd2` вы получаете сообщение об ошибке `target is busy`. Как узнать, какие файлы в файловой системе открыты и какие процессы открывали их?

Используйте lsof, за которым следует имя устройства:
```
$ lsof /dev/sdd2
```

3. Рассмотрим следующую запись в `/etc/fstab`: `/dev/sdb1/data ext4 noatime, noauto, async`. Будет ли эта файловая система смонтирована, если будет введена команда `mount -a`? Почему?

Он не будет установлен. Ключ `noauto` - это параметр, котрый означает, что эта запись игнорируется командой `mount -a`.

4. Как узнать UUID файловой системы в `/dev/sdb1`?

Используйте `lsblk -f`, за которым следует имя файловой системы:
```
$ lsblk -f /dev/sdb1
```
5. Как вы можете использовать `mount` для перемонтирования файловой системы exFAT в режиме «только чтение» с UUID `6e2c12e3-472d-4bac-a257-c49ac07f3761`, смонтированной в `/mnt/data`?

Поскольку файловая система смонтирована, вам не нужно беспокоиться о типе файловой системы или идентификаторе, просто используйте параметр remount с параметром ro (только для чтения) и точкой монтирования:
```
# mount -o remount,ro /mnt/data
```
6. Как получить список всех файловых систем `ext3` и `ntfs`, смонтированных в настоящее время в системе?

Используйте команду `mount -t`, за которой следует список файловых систем, разделенных запятыми:
```
# mount -t ext3,ntfs
```


# Ответы на упражнения для размышления

1. Рассмотрим следующую запись в `/etc/fstab`: `/dev/sdc1 /backup ext4 noatime, nouser, async`. Может ли пользователь смонтировать эту файловую систему с помощью команды `mount /backup`? Почему?

Нет, параметр `nouser` не позволит обычным пользователям монтировать эту файловую систему.

2. Рассмотрим удаленную файловую систему, смонтированную в `/mnt/server`, которая стала недоступной из-за потери сетевого подключения. Как вы могли заставить его быть размонтированным или монтируемым только для чтения, если это невозможно?

Передайте параметры `-f` и `-r` для размонтирования. Команда будет выглядеть так: `umount -f -r /mnt/server`. Помните, что вы можете группировать параметры, поэтому `umount -fr /mnt/server` также будет работать.

3. Напишите запись в `/etc/fstab`, которая будет монтировать том `btrfs` с меткой Backup на `/mnt/backup`, с параметрами по умолчанию и без разрешения выполнения из него двоичных файлов.

Строка должна быть `LABEL=Backup /mnt/backup btrfs defaults, noexec`.

4. Рассмотрим следующий модуль монтирования `systemd`:
```
[Unit]
Description=External data disk

[Mount]
What=/dev/disk/by-uuid/56C11DCC5D2E1334
Where=/mnt/external
Type=ntfs
Options=defaults

[Install]
WantedBy=multi-user.target
```
Что было бы эквивалентной записью в `/etc/fstab` для этой файловой системы?

Запись будет такой: `UUID = 56C11DCC5D2E1334 /mnt/external ntfs defaults`.


5. Каким должно быть имя файла для указанного выше модуля, чтобы его могла использовать `systemd`? Где его разместить?

Имя файла должно совпадать с точкой монтирования, поэтому `mnt-external.mount` помещается в `/etc/systemd/system`.
