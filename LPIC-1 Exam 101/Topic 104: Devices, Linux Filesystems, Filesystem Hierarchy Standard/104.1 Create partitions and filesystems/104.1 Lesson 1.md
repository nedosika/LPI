# 104.1 Урок 1

| Сертификат:   | LPIC-1                                      |
|:--------------|:--------------------------------------------|
| Версия:       | 5                                           |
| Тема:         | 104 устройства, файловые системы Linux, стандарт иерархии файловых систем |                           
| Цель:         | 104.1 Создание разделов и файловых систем   |
| Урок:         | 1 из 1                                      |


# Введение

В любой операционной системе перед использованием диск необходимо разбить на разделы.
Раздел - это логическое подмножество физического диска, и информация о разделах 
хранится в таблице разделов. Эта таблица включает информацию о первом и последнем 
секторах раздела и его типе, а также дополнительные сведения о каждом разделе.

Обычно каждый раздел рассматривается операционной системой как отдельный «диск», 
даже если все они находятся на одном физическом носителе. В системах Windows им 
присваиваются такие буквы, как `C:` (исторически основной диск), `D:` и так далее. В Linux
каждый раздел привязан к каталогу в `/dev`, например `/dev/sda1` или `/dev/sda2`.

В этом уроке вы узнаете, как создавать, удалять, восстанавливать и изменять размер
разделов с помощью трех наиболее распространенных утилит (fdisk, gdisk и parted), 
как создать на них файловую систему и как создать и настроить раздел подкачки или 
файл подкачки для использования в качестве виртуальной памяти.

>По историческим причинам в этом уроке мы будем называть носители данных «дисками», 
>хотя современные системы хранения, такие как твердотельные накопители и 
>флэш-накопители, вообще не содержат никаких «дисков».


# Понимание MBR и GPT

Есть два основных способа хранения информации о разделах на жестких дисках. Первый - 
это MBR (*Master Boot Record*), а второй - это GPT (*GUID Partition Table*).

MBR
Это пережиток первых дней MS-DOS (точнее, PC-DOS 2.0 с 1983 года) и на протяжении
десятилетий был стандартной схемой разделения на ПК. Таблица разделов хранится в 
первом секторе диска, называемом загрузочным сектором, вместе с загрузчиком, 
которым в системах Linux обычно является загрузчик GRUB. Но MBR имеет ряд 
ограничений, которые препятствуют его использованию в современных системах, 
например невозможность адресовать диски размером более 2 ТБ и ограничение в 4 
основных раздела на диск.

GPT
Система разделения, которая устраняет многие ограничения MBR. Практического 
ограничения на размер диска нет, а максимальное количество разделов ограничено 
только самой операционной системой. Это чаще встречается на более современных 
машинах, которые используют UEFI вместо старого BIOS ПК.

Во время задач системного администрирования весьма вероятно, что вы обнаружите, что обе схемы используются, поэтому важно знать, как использовать инструменты, связанные с каждой из них, для создания, удаления или изменения разделов.


# Управление разделами MBR с помощью FDISK

Стандартная утилита для управления разделами MBR в Linux - `fdisk`. Это интерактивная утилита с меню. Чтобы использовать его, введите `fdisk`, а затем имя устройства, соответствующего диску, который вы хотите редактировать. Например, команда
```
# fdisk /dev/sda
```
будет редактировать таблицу разделов первого устройства, подключенного к SATA (sda) в системе. Имейте в виду, что вам нужно указать устройство, соответствующее физическому диску, а не одному из его разделов (например, `/dev/sda1`).
>Все операции с дисками в этом уроке должны выполняться от имени пользователя root (системного администратора) или с правами root с помощью `sudo`.

При вызове fdisk покажет приветствие, затем предупреждение и будет ждать ваших команд.
```
# fdisk /dev/sda
Welcome to fdisk (util-linux 2.33.1).
Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

Command (m for help):
```
Предупреждение важно. Вы можете создавать, редактировать или удалять разделы по своему желанию, но ничего не будет записано на диск, если вы не используете команду write (`w`). Таким образом, вы можете «практиковаться» без риска потери данных, пока не нажимаете клавишу `w`. Чтобы выйти из `fdis`k без сохранения изменений, используйте команду `q`.
>При этом никогда не следует практиковаться на важном диске, поскольку всегда есть риски. Вместо этого используйте запасной внешний диск или USB-накопитель.


# Вывод текущей таблицы разделов

Команда `p` используется для печати текущей таблицы разделов. Результат будет примерно таким:
```
Command (m for help): p
Disk /dev/sda: 111.8 GiB, 120034123776 bytes, 234441648 sectors
Disk model: CT120BX500SSD1
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x97f8fef5

Device     Boot     Start       End   Sectors   Size Id Type
/dev/sda1            4096 226048942 226044847 107.8G 83 Linux
/dev/sda2       226048944 234437550   8388607     4G 82 Linux swap / Solaris
```
Вот значение каждого столбца:
* `Device` - Устройство, назначенное разделу.
* `Boot` - Показывает, является ли раздел загрузочным.
* `Start` - Сектор, в котором начинается раздел.
* `End` - Сектор, в котором заканчивается раздел.
* `Sectors` - Общее количество секторов в разделе. Умножьте его на размер сектора, чтобы получить размер раздела в байтах.
* `Size` - Размер раздела в формате, удобном для чтения. В приведенном выше примере значения указаны в гигабайтах.
* `Id` - Числовое значение, представляющее тип раздела.
* `Type` - Описание типа раздела.


# Основной или расширеный разделы

На MBR-диске может быть 2 основных типа разделов: *primary* и *extended*. Как мы уже говорили, у вас может быть только 4 основных раздела на диске, и если вы хотите сделать диск «загрузочным», первый раздел должен быть основным. 

Один из способов обойти это ограничение - создать расширенный раздел, который действует как контейнер для *logical* разделов. У вас может быть, например, первичный раздел, расширенный раздел, занимающий оставшуюся часть дискового пространства, и пять логических разделов внутри него.

Для такой операционной системы, как Linux, первичные и расширенные разделы обрабатываются одинаково, поэтому нет «преимуществ» использования одного над другим.


# Создание раздела

Чтобы создать раздел, используйте команду `n`. По умолчанию разделы будут созданы в начале незанятого пространства на диске. Вам будет предложено указать тип раздела (основной или расширенный), первый и последний сектор.

Для первого сектора вы обычно можете принять значение по умолчанию, предложенное `fdisk`, если вам не нужен раздел, начинающийся с определенного сектора. Вместо того, чтобы указывать последний сектор, вы можете указать размер, за которым следуют буквы `K`, `M`, `G`, `T` или `P` (Kilo, Mega, Giga, Tera или Peta). Итак, если вы хотите создать раздел размером 1 GB, вы можете указать `+1GB` в качестве `Last sector` (последнего сектора), и `fdisk` изменит размер раздела соответствующим образом. См. Этот пример для создания основного раздела:
```
Command (m for help): n
Partition type
   p   primary (0 primary, 0 extended, 4 free)
   e   extended (container for logical partitions)
Select (default p): p
Partition number (1-4, default 1): 1
First sector (2048-3903577, default 2048): 2048
Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-3903577, default 3903577): +1G
```


# Проверка на незанятое пространство

Если вы не знаете, сколько свободного места на диске, вы можете использовать команду `F`, чтобы показать нераспределенное пространство, например:
```
Command (m for help): F
Unpartitioned space /dev/sdd: 881 MiB, 923841536 bytes, 1804378 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes

  Start     End Sectors  Size
2099200 3903577 1804378  881M
```


# Удаление разделов

Чтобы удалить раздел, используйте команду `d`. `fdisk` спросит у вас номер раздела, который вы хотите удалить, если на диске нет только одного раздела. В этом случае этот раздел будет выбран и немедленно удален.

Имейте в виду, что если вы удалите расширенный раздел, все логические разделы внутри него также будут удалены.


# Обратите внимание на разрыв!

Имейте в виду, что при создании нового раздела с помощью fdisk максимальный размер будет ограничен максимальным объемом непрерывного нераспределенного пространства на диске. Скажем, например, что у вас есть следующая карта разделов:
```
Device     Boot   Start     End Sectors  Size Id Type
/dev/sdd1          2048 1050623 1048576  512M 83 Linux
/dev/sdd2       1050624 2099199 1048576  512M 83 Linux
/dev/sdd3       2099200 3147775 1048576  512M 83 Linux
```
Затем вы удаляете раздел 2 и проверяете наличие свободного места:
```
Command (m for help): F
Unpartitioned space /dev/sdd: 881 MiB, 923841536 bytes, 1804378 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes

  Start     End Sectors  Size
1050624 2099199 1048576  512M
3147776 3903577  755802  369M
```
Если сложить размер нераспределенного пространства, теоретически у нас будет 881 МБ. Но посмотрим, что произойдет, когда мы попытаемся создать раздел размером 700 МБ:
```
Command (m for help): n
Partition type
   p   primary (2 primary, 0 extended, 2 free)
   e   extended (container for logical partitions)
Select (default p): p
Partition number (2,4, default 2): 2
First sector (1050624-3903577, default 1050624):
Last sector, +/-sectors or +/-size{K,M,G,T,P} (1050624-2099199, default 2099199): +700M
Value out of range.
```
Это происходит потому, что наибольшее непрерывное незанятое пространство на диске - это блок размером 512 МБ, принадлежащий разделу 2. Ваш новый раздел не может «достучаться» до раздела 3, чтобы использовать часть нераспределенного пространства после него.


# Изменение типа раздела

Иногда вам может потребоваться изменить тип раздела, особенно при работе с дисками, которые будут использоваться в других операционных системах и платформах. Это делается с помощью команды `t`, за которой следует номер раздела, который вы хотите изменить. 

Тип раздела должен быть указан с помощью соответствующего шестнадцатеричного кода, и вы можете увидеть список всех допустимых кодов, используя команду `l`.

Не путайте тип раздела с используемой на нем файловой системой. Хотя сначала между ними существовала связь, сегодня вы не можете предполагать, что это правда. Например, раздел Linux может содержать любую файловую систему Linux, такую как *ext4* или *ReiserFS*.
>Разделы Linux относятся к типу 83 (Linux). Разделы подкачки имеют тип 82 (Linux Swap).


# Настройка разделов GPT с помощью GDISK

Утилита `gdisk` является эквивалентом `fdisk` при работе с дисками с разделами GPT. Фактически, интерфейс смоделирован по образцу `fdisk` с интерактивной подсказкой и такими же (или очень похожими) командами.


# Вывод текущей таблицы разделов

Команда `p` используется для печати текущей таблицы разделов. Результат будет примерно таким:
```
Command (? for help): p
Disk /dev/sdb: 3903578 sectors, 1.9 GiB
Model: DataTraveler 2.0
Sector size (logical/physical): 512/512 bytes
Disk identifier (GUID): AB41B5AA-A217-4D1E-8200-E062C54285BE
Partition table holds up to 128 entries
Main partition table begins at sector 2 and ends at sector 33
First usable sector is 34, last usable sector is 3903544
Partitions will be aligned on 2048-sector boundaries
Total free space is 1282071 sectors (626.0 MiB)

Number  Start (sector)    End (sector)  Size       Code  Name
   1            2048         2099199   1024.0 MiB  8300  Linux filesystem
   2         2623488         3147775   256.0 MiB   8300  Linux filesystem
```

С самого начала мы замечаем несколько разных вещей:
* Каждый диск имеет уникальный идентификатор диска (GUID). Это 128-битное шестнадцатеричное число, которое назначается случайным образом при создании таблицы разделов. GUID можно использовать для определения того, какие файловые системы монтировать во время загрузки (и где), избавляя от необходимости использовать для этого путь к устройству (например, `/dev/sdb`).
* Видите фразу Partition table holds up to 128 entries? Правильно, на GPT-диске может быть до 128 разделов. Благодаря этому нет необходимости в *primary* и *extended* разделах.
* Свободное пространство указано в последней строке, поэтому нет необходимости в эквиваленте команды `F` из `fdisk`.


# Создание раздела

Команда для создания раздела - `n`, как и в `fdisk`. Основное отличие состоит в том, что помимо номера раздела и первого и последнего секторов (или размера) вы также можете указать тип раздела во время создания. Разделы GPT поддерживают гораздо больше типов, чем MBR. Вы можете проверить список всех поддерживаемых типов с помощью команды `L`.


# Удаление раздела

Чтобы удалить раздел, введите `d` и номер раздела. В отличие от `fdisk`, первый раздел не будет автоматически выбран, если он единственный на диске. На GPT-дисках разделы можно легко переупорядочить или «отсортировать», чтобы избежать пробелов в последовательности нумерации. Для этого просто используйте команду `s`. Например, представьте себе диск со следующей таблицей разделов:
```
Number  Start (sector)    End (sector)  Size       Code  Name
   1            2048         2099199   1024.0 MiB  8300  Linux filesystem
   2         2099200         2361343   128.0 MiB   8300  Linux filesystem
   3         2361344         2623487   128.0 MiB   8300  Linux filesystem
```
Если вы удалите второй раздел, таблица станет:
```
Number  Start (sector)    End (sector)  Size       Code  Name
   1            2048         2099199   1024.0 MiB  8300  Linux filesystem
   3         2361344         2623487   128.0 MiB   8300  Linux filesystem
```
Если вы воспользуетесь командой `s`, она станет:
```
Number  Start (sector)    End (sector)  Size       Code  Name
   1            2048         2099199   1024.0 MiB  8300  Linux filesystem
   2         2361344         2623487   128.0 MiB   8300  Linux filesystem
```
Обратите внимание, что третий раздел стал вторым.


# Gap? что за Gap?

В отличие от дисков MBR, при создании раздела на дисках GPT размер не ограничивается максимальным объемом непрерывного нераспределенного пространства. Вы можете использовать каждый последний бит свободного сектора, независимо от того, где он находится на диске.


# Варианты восстановления

На дисках GPT хранятся резервные копии заголовка GPT и таблицы разделов, что упрощает восстановление дисков в случае повреждения этих данных. `gdisk` предоставляет функции для помощи в этих задачах восстановления, доступ к которым осуществляется с помощью команды `r`.

Вы можете восстановить поврежденный основной заголовок GPT или таблицу разделов с помощью `b` и `c`, соответственно, или использовать основной заголовок и таблицу для восстановления резервной копии с помощью `d` и `e`. Вы также можете преобразовать MBR в GPT с помощью f и сделать наоборот с помощью g, среди других операций. Ввдеите команду ? в меню восстановления, чтобы получить список всех доступных команд восстановления и описания того, что они делают.


# Создание файловых систем

Разбиение диска на разделы - это только первый шаг к использованию диска. После этого вам нужно будет отформатировать раздел с файловой системой, прежде чем использовать его для хранения данных.

Файловая система контролирует, как данные хранятся и доступны на диске. Linux поддерживает множество файловых систем, некоторые из которых являются собственными, например, семейство ext (Extended Filesystem), а другие происходят из других операционных систем, таких как FAT из MS-DOS, NTFS из Windows NT, HFS и HFS + из Mac OS и т. д.

Стандартный инструмент, используемый для создания файловой системы в Linux, - это mkfs, который имеет множество «разновидностей» в зависимости от файловой системы, с которой ему нужно работать.


# Создание файловой системы ext2 / ext3 / ext4

*Extended Filesystem* (ext) была первой файловой системой для Linux, и с годами была заменена новыми версиями под названием ext2, ext3 и ext4, которая в настоящее время является файловой системой по умолчанию для многих дистрибутивов Linux. Утилиты `mkfs.ext2`, `mkfs.ext3` и `mkfs.ext4` используются для создания файловых систем ext2, ext3 и ext4. Фактически, все эти «утилиты» существуют только как символические ссылки на другую утилиту под названием `mke2fs`. `mke2fs` изменяет свои значения по умолчанию в соответствии с именем, которым он вызван. Таким образом, все они имеют одинаковое поведение и параметры командной строки.

Самая простая форма использования:
```
# mkfs.ext2 TARGET
```

Где `TARGET` - это имя раздела, в котором должна быть создана файловая система. Например, для создания файловой системы ext3 на `/dev/sdb1` команда будет выглядеть так:
```
# mkfs.ext3 /dev/sdb1
```
Вместо использования команды, соответствующей файловой системе, которую вы хотите создать, вы можете передать `mke2fs` параметр `-t`, за которым следует имя файловой системы. Например, следующие команды эквивалентны и создадут файловую систему ext4 на `/dev/sdb1`.
```
# mkfs.ext4 /dev/sdb1
# mke2fs -t ext4 /dev/sdb1
```


# Параметры командной строки

`mke2fs` поддерживает широкий спектр параметров и опций командной строки. Вот некоторые из наиболее значимых. Все они также применимы к `mkfs.ext2`, `mkfs.ext3` и `mkfs.ext4`:

* `-b SIZE` - Устанавливает размер блоков данных в устройстве на `SIZE`, который может составлять 1024, 2048 или 4096 байтов на блок.
* `-c` - Проверяет целевое устройство на наличие bad-блоков перед созданием файловой системы. Вы можете выполнить тщательную, но гораздо более медленную проверку, дважды передав этот параметр, как в `mkfs.ext4 -c -c TARGET`.
* `-d DIRECTORY` - Копирует содержимое указанного каталога в корень новой файловой системы. Полезно, если вам нужно «предварительно заполнить» диск предопределенным набором файлов.
* `-F` - Опасно, Уилл Робинсон! Эта опция заставит mke2fs создать файловую систему, даже если другие параметры, переданные ей или цели, опасны или вообще не имеют смысла. Если указано дважды (как в `-F -F`), его можно даже использовать для создания файловой системы на устройстве, которое смонтировано или используется, что очень и очень плохо.
* `-L VOLUME_LABEL` - Устанавливает метку тома на ту, которая указана в `VOLUME_LABEL`. Этот ярлык должен состоять не более чем из 16 символов.
* `-n` - Это действительно полезная опция, которая имитирует создание файловой системы и показывает, что было бы сделано, если бы она была выполнена без опции `n`. Считайте это «пробным» режимом. Хорошо бы все проверить, прежде чем вносить какие-либо изменения на диск.
* `-q` - Тихий режим. `mke2fs` будет работать нормально, но не будет выводить данные на терминал. Полезно при запуске `mke2fs` из скрипта.
* `-U ID` - Это установит UUID (универсальный уникальный идентификатор) раздела на значение, указанное как ID. UUID - это 128-битные числа в шестнадцатеричной системе счисления, которые служат для однозначной идентификации раздела в операционной системе. Этот номер указывается в виде 32-значной строки в формате 8-4-4-4-12, что означает 8 цифр, дефис, 4 цифры, дефис, 4 цифры, дефис, 4 цифры, дефис, 12 цифр, например `D249E380- 7719-45A1-813C-35186883987E`. Вместо идентификатора вы также можете указать параметры, такие как `clear`, чтобы очистить UUID файловой системы, `random`, чтобы использовать случайно сгенерированный UUID, или `time`, чтобы создать UUID на основе времени.
* `-V` - Подробный режим, во время работы выводится гораздо больше информации, чем обычно. Полезно для отладки.


# Создание файловой системы XFS

XFS - это высокопроизводительная файловая система, первоначально разработанная Silicon Graphics в 1993 году для своей операционной системы IRIX. Благодаря своим характеристикам производительности и надежности, он обычно используется для серверов и других сред, требующих высокой (или гарантированной) пропускной способности файловой системы.

Инструменты для управления файловыми системами XFS являются частью пакета xfsprogs. Этот пакет может потребоваться установить вручную, поскольку он не включен по умолчанию в некоторые дистрибутивы Linux. Другие, например Red Hat Enterprise Linux 7, используют XFS в качестве файловой системы по умолчанию.

Файловые системы XFS разделены как минимум на 2 части: раздел журнала, в котором ведется журнал всех операций файловой системы (обычно называемый журналом), и раздел данных. Раздел журнала может быть расположен внутри раздела данных (поведение по умолчанию) или даже на отдельном диске, для повышения производительности и надежности.

Самая простая команда для создания файловой системы XFS - это `mkfs.xfs TARGET`, где `TARGET` - это раздел, в котором должна быть создана файловая система. Например: `mkfs.xfs /dev/sda1`.

Как и `mke2fs`, `mkfs.xfs` поддерживает ряд параметров командной строки. Вот некоторые из самых распространенных.

* `-b size=VALUE` - Устанавливает размер блока в файловой системе в байтах на значение, указанное в `VALUE`. Значение по умолчанию - 4096 байт (4 КиБ), минимальное - 512, максимальное - 65536 (64 КиБ).
* `-m crc=VALUE` - Параметры, начинающиеся с `-m`, являются параметрами метаданных. Это включает (если `VALUE` равно `1`) или отключает (если `VALUE` равно `0`) использование проверок CRC32c для проверки целостности всех метаданных на диске. Это обеспечивает лучшее обнаружение ошибок и восстановление после сбоев, связанных с аппаратными проблемами, поэтому по умолчанию эта функция включена. Влияние этой проверки на производительность должно быть минимальным, поэтому обычно нет причин отключать ее.
* `-m uuid=VALUE` - Устанавливает UUID раздела равным значению VALUE. Помните, что UUID - это 32-символьные (128-битные) числа в шестнадцатеричной системе счисления, указанные в группах из 8, 4, 4, 4 и 12 цифр, разделенных тире, например `1E83E3A3-3AE9-4AAC-BF7E-29DFFECD36C0`.
* `-f` - Принудительно создать файловую систему на целевом устройстве, даже если на нем обнаружена файловая система.
* `-l logdev=DEVICE` - Это поместит раздел журнала файловой системы на указанное устройство, а не в раздел данных.
* `-l size=VALUE` - Он установит размер раздела журнала равным значению, указанному в `VALUE`. Размер может быть указан в байтах, и могут использоваться суффиксы, такие как `m` или `g`. `-l size = 10m`, например, ограничит раздел журнала до 10 мегабайт.
* `-q` - Тихий режим. В этом режиме `mkfs.xfs` не печатает параметры создаваемой файловой системы.
* `-L LABEL` - Устанавливает метку файловой системы, длина которой не может превышать 12 символов.
* `-N` - Подобно параметру `-n` в `mke2fs`, заставит `mkfs.xfs` вывести все параметры для создания файловой системы, фактически не создавая ее.


# Создание файловой системы FAT или VFAT

Файловая система FAT возникла из MS-DOS и за эти годы претерпела множество изменений, кульминацией которых стал формат FAT32, выпущенный в 1996 году с Windows 95 OSR2.

VFAT - это расширение формата FAT16 с поддержкой длинных (до 255 символов) имен файлов. Обе файловые системы обрабатываются одной и той же утилитой `mkfs.fat`. `mkfs.vfat` - это его псевдоним.

Файловая система FAT имеет важные недостатки, которые ограничивают ее использование на больших дисках. Например, FAT16 поддерживает тома размером не более 4 ГБ и максимальный размер файла 2 ГБ. FAT32 увеличивает размер тома до 2 ПБ, а максимальный размер файла - до 4 ГБ. Из-за этого файловые системы FAT сегодня чаще используются на небольших флеш-накопителях или картах памяти (размером до 2 ГБ), а также на устаревших устройствах и ОС, которые не поддерживают более продвинутые файловые системы. 

Самая простая команда для создания файловой системы FAT - это `mkfs.fat TARGET`, где `TARGET` - это раздел, в котором должна быть создана файловая система. Например: `mkfs.fat /dev/sdc1`.

Как и другие утилиты, `mkfs.fat` поддерживает ряд параметров командной строки. Ниже приведены наиболее важные из них. Полный список и описание каждой опции можно прочитать в руководстве к утилите с помощью команды `man mkfs.fat`.

* `-c` - Проверяет целевое устройство на наличие bad-блоков перед созданием файловой системы.
* `-C FILENAME BLOCK_COUNT` - Создает файл, указанный в `FILENAME`, а затем создает внутри него файловую систему FAT, эффективно создавая пустой «образ диска», который впоследствии можно записать на устройство с помощью такой утилиты, как `dd`, или смонтировать как устройство обратной связи. При использовании этой опции количество блоков в файловой системе (`BLOCK_COUNT`) должно быть указано после имени устройства.
* `-F SIZE` - Выбирает размер FAT (таблицы размещения файлов) между 12, 16 или 32, то есть между FAT12, FAT16 или FAT32. Если не указан, `mkfs.fat` выберет соответствующий вариант в зависимости от размера файловой системы.
* `-n NAME` - Устанавливает метку тома или имя для файловой системы. Это может быть до 11 символов, по умолчанию имя отсутствует.
* `-v` - Подробный режим. Выводит гораздо больше информации, чем обычно, полезной для отладки.

>`mkfs.fat` не может создать «загрузочную» файловую систему. Согласно странице руководства, «это не так просто, как вы думаете» и не будет реализовано.


# Создание файловой системы exFAT

exFAT - это файловая система, созданная Microsoft в 2006 году, которая устраняет одно из наиболее важных ограничений FAT32: размер файла и диска. В exFAT максимальный размер файла составляет 16 эксабайт (с 4 ГБ в FAT32), а максимальный размер диска - 128 петабайт.

Поскольку он хорошо поддерживается всеми тремя основными операционными системами (Windows, Linux и Mac OS), это хороший выбор там, где требуется совместимость, например, на флэш-накопителях большой емкости, картах памяти и внешних дисках. Фактически, это файловая система по умолчанию, как определено SD Association, для карт памяти SDXC размером более 32 ГБ.

Утилита по умолчанию для создания файловых систем exFAT - `mkfs.exfat`, которая является ссылкой на `mkexfatfs`. Самая простая команда - это `mkfs.exfat TARGET`, где `TARGET` - это раздел, в котором должна быть создана файловая система. Например: `mkfs.exfat/dev/sdb2`.

В отличие от других утилит, обсуждаемых в этом уроке, у `mkfs.exfat` очень мало параметров командной строки. Они есть:

* `-i VOL_ID` - Устанавливает для идентификатора тома значение, указанное в `VOL_ID`. Это 32-битное шестнадцатеричное число. Если не определен, устанавливается идентификатор на основе текущего времени.
* `-n NAME` - Устанавливает метку тома или имя. Он может содержать до 15 символов, по умолчанию имя отсутствует.
* `-p SECTOR` - Задает первый сектор первого раздела на диске. Это необязательное значение, по умолчанию оно равно нулю.
* `-s SECTORS` - Определяет количество физических секторов на кластер распределения. Это должно быть степень двойки, например 1, 2, 4, 8 и т. д.


# Знакомство с файловой системой Btrfs

Btrfs (официально файловая система B-Tree, произносится как «Butter FS», «Better FS» или даже «Butterfuss», на ваш выбор) - это файловая система, которая разрабатывалась с 2007 года специально для Linux корпорацией Oracle и другие компании, включая Fujitsu, Red Hat, Intel и SUSE, среди прочих.

Есть много функций, которые делают Btrfs привлекательным в современных системах, где обычно используются большие объемы хранилища. Среди них - поддержка нескольких устройств (включая чередование, зеркалирование и чередование + зеркалирование, как в настройке RAID), прозрачное сжатие, оптимизация SSD, инкрементные резервные копии, моментальные снимки, оперативная дефрагментация, автономные проверки, поддержка вложенных томов (с квотами), дедупликация и многое другое.

Поскольку это файловая система с функцией *copy-on-write*(копирования при записи), она очень устойчива к сбоям. Кроме того, Btrfs прост в использовании и хорошо поддерживается многими дистрибутивами Linux. И некоторые из них, например SUSE, используют его как файловую систему по умолчанию.

>В традиционной файловой системе, когда вы хотите перезаписать часть файла, новые данные помещаются непосредственно поверх старых данных, которые они заменяют. В файловой системе с *copy-on-write* новые данные записываются в свободное место на диске, затем исходные метаданные файла обновляются, чтобы ссылаться на новые данные, и только тогда старые данные освобождаются, поскольку они больше не нужны. Это снижает вероятность потери данных в случае сбоя, поскольку старые данные удаляются только после того, как файловая система будет абсолютно уверена, что они больше не нужны, и новые данные будут на месте.


# Создание файловой системы Btrfs

Утилита mkfs.btrfs используется для создания файловой системы Btrfs. Использование команды без каких-либо параметров создает файловую систему Btrfs на данном устройстве, например:
```
# mkfs.btrfs /dev/sdb1
```
>Если в вашей системе нет утилиты mkfs.btrfs, поищите btrfs-progs в менеджере пакетов вашего дистрибутива.

Вы можете использовать `-L`, чтобы установить метку (или имя) для вашей файловой системы. Ярлыки Btrfs могут содержать до 256 символов, за исключением символов новой строки:
```
# mkfs.btrfs /dev/sdb1 -L "New Disk"
```
>Заключите метку в кавычки (как указано выше), если она содержит пробелы.

Обратите внимание на одну особенность Btrfs: вы можете передать несколько устройств команде `mkfs.btrfs`. Передача более одного устройства приведет к охвату файловой системы по всем устройствам, что аналогично настройке RAID или LVM. Чтобы указать, как метаданные будут распределяться в дисковом массиве, используйте параметр `-m`. Допустимые параметры: `raid0`, `raid1`, `raid5`, `raid6`, `raid10`, `single` и `dup`.

Например, чтобы создать файловую систему, охватывающую `/dev/sdb1` и `/dev/sdc1`, объединив два раздела в один большой раздел, используйте:
```
# mkfs.btrfs -d single -m single /dev/sdb /dev/sdc
```

>Файловые системы, охватывающие несколько разделов, такие как выше, могут сначала выглядеть выгодно, но не являются хорошей идеей с точки зрения безопасности данных, поскольку сбой на одном диске массива означает определенную потерю данных. Риск тем больше, чем больше дисков вы используете, так как у вас также больше возможных точек отказа.


# Управление подтомами

Подтомы подобны файловым системам внутри файловых систем. Думайте о них как о каталоге, который можно смонтировать (и рассматривать как) отдельную файловую систему. Подтомы упрощают организацию и администрирование системы, так как каждый из них может иметь отдельные квоты или правила для моментальных снимков.

>Подтомы не являются разделами. Раздел выделяет фиксированное пространство на диске. Это может привести к проблемам в дальнейшем, например, к тому, что в одном разделе не останется места, когда в другом осталось много места. С подобными томами дело обстоит иначе, поскольку они «делят» свободное пространство из своей корневой файловой системы и при необходимости растут.

Предположим, у вас есть файловая система Btrfs, смонтированная на `/mnt/disk`, и вы хотите создать внутри нее подтом для хранения резервных копий. Назовем это BKP:
```
# btrfs subvolume create /mnt/disk/BKP
```
Затем мы перечисляем содержимое файловой системы `/mnt/disk`. Вы увидите, что у нас есть новый каталог, названный в именем нашего подтома.
```bash
$ ls -lh /mnt/disk/
total 0
drwxr-xr-x 1 root   root     0 jul 13 17:35 BKP
drwxrwxr-x 1 carol carol 988 jul 13 17:30 Images
```
>Да, подтома также доступны, как и любой другой каталог.

Мы можем проверить, что подтом активен, с помощью команды:
```bash
# btrfs subvolume show /mnt/disk/BKP/
	Name: 			BKP
	UUID: 			e90a1afe-69fa-da4f-9764-3384f66fa32e
	Parent UUID: 		-
	Received UUID: 		-
	Creation time: 		2019-07-13 17:35:40 -0300
	Subvolume ID: 		260
	Generation: 		23
	Gen at creation: 	22
	Parent ID: 		5
	Top level ID: 		5
	Flags: 			-
	Snapshot(s):
```
Вы можете смонтировать подтом в `/mnt/BKP`, передав параметр `-t btrfs -o subvol = NAME` команде монтирования:
```bash
# mount -t btrfs -o subvol=BKP /dev/sdb1 /mnt/bkp
```
>Параметр `-t` указывает тип монтируемой файловой системы.


# Работа со снимками

Снимки похожи на подтома, но предварительно заполнены содержимым тома, из которого был сделан снимок.

При создании, моментальный снимок и исходный том имеют точно такое же содержимое. Но с этого момента они будут расходиться. Изменения, внесенные в исходный том (например, добавленные, переименованные или удаленные файлы), не будут отражены в снимке, и наоборот.

Имейте в виду, что моментальный снимок не дублирует файлы и изначально почти не занимает места на диске. Он просто дублирует дерево файловой системы, указывая на исходные данные.

Команда для создания моментального снимка такая же, как и для создания подтома, просто добавьте параметр `snapshot` после `btrfs subvolume`. Приведенная ниже команда создаст моментальный снимок файловой системы Btrfs, смонтированной в `/mnt/disk` в `/mnt/disk/snap`:
```
# btrfs subvolume snapshot /mnt/disk /mnt/disk/snap
```
Теперь представьте, что у вас есть следующее содержимое в `/mnt/disk`:
```
$ ls -lh
total 2,8M
-rw-rw-r-- 1 carol carol 109K jul 10 16:22 Galaxy_Note_10.png
-rw-rw-r-- 1 carol carol 484K jul  5 15:01 geminoid2.jpg
-rw-rw-r-- 1 carol carol 429K jul  5 14:52 geminoid.jpg
-rw-rw-r-- 1 carol carol 467K jul  2 11:48 LG-G8S-ThinQ-Mirror-White.jpg
-rw-rw-r-- 1 carol carol 654K jul  2 11:39 LG-G8S-ThinQ-Range.jpg
-rw-rw-r-- 1 carol carol  94K jul  2 15:43 Mimoji_Comparativo.jpg
-rw-rw-r-- 1 carol carol 112K jul 10 16:20 Note10Plus.jpg
drwx------ 1 carol carol  366 jul 13 17:56 snap
-rw-rw-r-- 1 carol carol 118K jul 11 16:36 Twitter_Down_20190711.jpg
-rw-rw-r-- 1 carol carol 324K jul  2 15:22 Xiaomi_Mimoji.png
```
Обратите внимание на каталог снимков, содержащий снимок. Теперь давайте удалим несколько файлов и проверим содержимое каталога:
```
$ rm LG-G8S-ThinQ-*
$ ls -lh
total 1,7M
-rw-rw-r-- 1 carol carol 109K jul 10 16:22 Galaxy_Note_10.png
-rw-rw-r-- 1 carol carol 484K jul  5 15:01 geminoid2.jpg
-rw-rw-r-- 1 carol carol 429K jul  5 14:52 geminoid.jpg
-rw-rw-r-- 1 carol carol  94K jul  2 15:43 Mimoji_Comparativo.jpg
-rw-rw-r-- 1 carol carol 112K jul 10 16:20 Note10Plus.jpg
drwx------ 1 carol carol  366 jul 13 17:56 snap
-rw-rw-r-- 1 carol carol 118K jul 11 16:36 Twitter_Down_20190711.jpg
-rw-rw-r-- 1 carol carol 324K jul  2 15:22 Xiaomi_Mimoji.png
```
Однако, если вы заглянете в каталог оснастки, файлы, которые вы удалили, останутся там и при необходимости могут быть восстановлены.
```
$ ls -lh snap/
total 2,8M
-rw-rw-r-- 1 carol carol 109K jul 10 16:22 Galaxy_Note_10.png
-rw-rw-r-- 1 carol carol 484K jul  5 15:01 geminoid2.jpg
-rw-rw-r-- 1 carol carol 429K jul  5 14:52 geminoid.jpg
-rw-rw-r-- 1 carol carol 467K jul  2 11:48 LG-G8S-ThinQ-Mirror-White.jpg
-rw-rw-r-- 1 carol carol 654K jul  2 11:39 LG-G8S-ThinQ-Range.jpg
-rw-rw-r-- 1 carol carol  94K jul  2 15:43 Mimoji_Comparativo.jpg
-rw-rw-r-- 1 carol carol 112K jul 10 16:20 Note10Plus.jpg
-rw-rw-r-- 1 carol carol 118K jul 11 16:36 Twitter_Down_20190711.jpg
-rw-rw-r-- 1 carol carol 324K jul  2 15:22 Xiaomi_Mimoji.png
```
Также возможно создавать моментальные снимки только для чтения. Они работают точно так же, как снимки с возможностью записи, с той разницей, что содержимое снимка нельзя изменить, они «заморожены» во времени. Просто добавьте параметр `-r` при создании снимка:
```
# btrfs subvolume snapshot -r /mnt/disk /mnt/disk/snap
```


# Несколько слов о сжатии

Btrfs поддерживает прозрачное сжатие файлов с тремя различными алгоритмами, доступными пользователю. Это выполняется автоматически для каждого файла, если файловая система смонтирована с параметром `-o compress`. Алгоритмы достаточно умны, чтобы обнаруживать несжимаемые файлы и не пытаются их сжимать, экономя системные ресурсы. Таким образом, в одном каталоге вы можете иметь сжатые и несжатые файлы вместе. Алгоритм сжатия по умолчанию - ZLIB, но доступны LZO (быстрее, хуже степень сжатия) или ZSTD (быстрее, чем ZLIB, сопоставимое сжатие) с несколькими уровнями сжатия (см. соответствующую цель по параметрам монтирования).


# Управление разделами с помощью GNU Parted

GNU Parted - очень мощный редактор разделов (отсюда и название), который можно использовать для создания, удаления, перемещения, изменения размера, восстановления и копирования разделов. Он может работать как с дисками GPT, так и с дисками MBR и покрывает почти все ваши потребности в управлении дисками.

Существует множество графических интерфейсов, которые значительно упрощают работу с `parted`, например GParted для сред рабочего стола на основе GNOME и KDE Partition Manager для рабочих столов KDE. Однако вы должны научиться использовать `parted` в командной строке, поскольку при настройке сервера вы врядли сможете рассчитывать на доступность графической среды рабочего стола.

>В отличие от fdisk и gdisk, parted вносит изменения на диск сразу после выполнения команды, не дожидаясь другой команды для записи изменений на диск. Во время практики целесообразно делать это на пустом или запасном диске или флэш-накопителе, чтобы не было риска потери данных в случае ошибки.

Самый простой способ начать использовать parted - ввести `parted DEVICE`, где `DEVICE` - это устройство, которым вы хотите управлять (`parted /dev/sdb`). Программа запускает интерактивный интерфейс командной строки, такой как `fdisk` и `gdisk`, с приглашением `(parted)` для ввода команд.
```
# parted /dev/sdb
GNU Parted 3.2
Using /dev/sdb
Welcome to GNU Parted! Type 'help' to view a list of commands.

(parted)
```
>Будь осторожен! Если вы не укажете устройство, parted автоматически выберет основной диск (обычно `/dev/sda`) для работы.


# Выбор дисков

Чтобы переключиться на диск, отличный от того, который указан в командной строке, вы можете использовать команду `select`, за которой следует имя устройства:
```
(parted) select /dev/sdb
Using /dev/sdb
```


# Получение информации

Команду `print` можно использовать для получения дополнительной информации о конкретном разделе или даже обо всех блочных устройствах (дисках), подключенных к вашей системе.

Чтобы получить информацию о текущем выбранном разделе, просто введите `print`:
```
(parted) print
Model: ATA CT120BX500SSD1 (scsi)
Disk /dev/sda: 120GB
Sector size (logical/physical): 512B/512B
Partition Table: msdos
Disk Flags:

Number  Start   End    Size    Type     File system     Flags
 1      2097kB  116GB  116GB   primary  ext4
 2      116GB   120GB  4295MB  primary  linux-swap(v1)
```
Вы можете получить список всех блочных устройств, подключенных к вашей системе с помощью `print devices`:
```
(parted) print devices
/dev/sdb (1999MB)
/dev/sda (120GB)
/dev/sdc (320GB)
/dev/mapper/cryptswap (4294MB)
```
Чтобы получить информацию обо всех подключенных устройствах сразу, вы можете использовать функцию `print all`. Если вы хотите узнать, сколько свободного места есть в каждом из них, вы можете использовать `print free`:
```
(parted) print free
Model: ATA CT120BX500SSD1 (scsi)
Disk /dev/sda: 120GB
Sector size (logical/physical): 512B/512B
Partition Table: msdos
Disk Flags:

Number  Start   End     Size    Type     File system     Flags
        32.3kB  2097kB  2065kB           Free Space
 1      2097kB  116GB   116GB   primary  ext4
        116GB   116GB   512B             Free Space
 2      116GB   120GB   4295MB  primary  linux-swap(v1)
        120GB   120GB   2098kB           Free Space
```


# Создание таблицы разделов на пустом диске

Чтобы создать таблицу разделов на пустом диске, используйте команду `mklabel`, а затем укажите тип таблицы разделов, который вы хотите использовать.

Существует много поддерживаемых типов таблиц разделов, но основные типы, о которых вам следует знать, - это `msdos`, который используется здесь для ссылки на таблицу разделов MBR, и `gpt` для ссылки на таблицу разделов GPT. Чтобы создать таблицу разделов MBR, введите:
```
(parted) mklabel msdos
```
А чтобы создать таблицу разделов GPT, используйте следующую команду:
```
(parted) mklabel gpt
```


# Создание раздела

Для создания раздела используется команда `mkpart` с синтаксисом `mkpart PARTTYPE FSTYPE START END`, где:

* `PARTTYPE` - Тип раздела, который может быть `primary`, `logical` или `extended` в случае использования таблицы разделов MBR.
* `FSTYPE` - Указывает, какая файловая система будет использоваться на этом разделе. Обратите внимание, что `parted` не создает файловую систему. Он просто устанавливает флаг на разделе, который сообщает ОС, какие данные от него ожидать.
* `START` - Указывает точную точку на устройстве, где начинается раздел. Вы можете использовать разные единицы измерения, чтобы указать эту точку. `2s` можно использовать для обозначения второго сектора диска, а `1m` относится к началу первого мегабайта диска. Другие распространенные единицы - это `B` (байты) и `%` (процент от диска).
* `END` - Задает конец раздела. Обратите внимание, что это не размер раздела, а точка на диске, где он заканчивается. Например, если вы укажете `100m`, раздел будет заканчиваться через 100 МБ после начала диска. Вы можете использовать те же единицы измерения, что и в параметре `START`.

Итак, команда:
```
(parted) mkpart primary ext4 1m 100m
```
Создает первичный раздел типа `ext4`, начиная с первого мегабайта диска и заканчивая 100-м мегабайтом.


# Удаление раздела

Чтобы удалить раздел, используйте команду `rm`, за которой следует номер раздела, который можно отобразить с помощью команды `print`. Таким образом, `rm 2` удалит второй раздел на текущем выбранном диске.


# Восстановление разделов

`parted` может восстановить удаленный раздел. Предположим, у вас есть следующая структура разделов:
```
Number  Start   End     Size    File system  Name     Flags
 1      1049kB  99.6MB  98.6MB  ext4         primary
 2      99.6MB  200MB   100MB   ext4         primary
 3      200MB   300MB   99.6MB  ext4         primary
```
Случайно вы удалили раздел 2 с помощью `rm 2`. Чтобы восстановить его, вы можете использовать команду `rescue` с синтаксисом `rescue START END`, где `START` - это приблизительное место, где начался раздел, а `END` - приблизительное место, где он закончился.

`parted` просканирует диск в поисках разделов и предложит восстановить все найденные разделы. В приведенном выше примере размер раздела 2 начинается с 99,6 МБ и заканчивается 200 МБ. Таким образом, вы можете использовать следующую команду для восстановления раздела:
```
(parted) rescue 90m 210m
Information: A ext4 primary partition was found at 99.6MB -> 200MB.
Do you want to add it to the partition table?

Yes/No/Cancel? y
```
Это восстановит раздел и его содержимое. Обратите внимание, что `rescue` может восстанавливать только разделы, на которых установлена файловая система. Пустые разделы не обнаруживаются.


# Изменение размера разделов ext2/3/4

`parted` можно использовать для изменения размера разделов, чтобы сделать их больше или меньше. Однако есть некоторые предостережения:
* Во время изменения размера раздел должен быть неиспользованным и отключенным. 
* Вам нужно достаточно свободного места после раздела, чтобы увеличить его до желаемого размера.

Команда - `resizepart`, за которой следует номер раздела и место, где он должен заканчиваться. Например, если у вас есть следующая таблица разделов:
```
Number  Start   End     Size    File system  Name     Flags
 1      1049kB  99.6MB  98.6MB  ext4         primary
 2      99.6MB  200MB   100MB   ext4
 3      200MB   300MB   99.6MB  ext4         primary
```
Попытка увеличить раздел `1` с помощью `resizepart` вызовет сообщение об ошибке, потому что с новым размером раздел `1` будет перекрываться с разделом `2`. Однако размер раздела `3` можно изменить, так как после него остается свободное место, что можно проверить с помощью команды `print free`:
```
(parted) print free
Model: Kingston DataTraveler 2.0 (scsi)
Disk /dev/sdb: 1999MB
Sector size (logical/physical): 512B/512B
Partition Table: gpt
Disk Flags:

 Number  Start   End     Size    File system  Name     Flags
        17.4kB  1049kB  1031kB  Free Space
 1      1049kB  99.6MB  98.6MB  ext4         primary
 2      99.6MB  200MB   100MB   ext4
 3      200MB   300MB   99.6MB  ext4         primary
        300MB   1999MB  1699MB  Free Space
```
Таким образом, вы можете использовать следующую команду для изменения размера раздела 3 до 350 МБ:
```
(parted) resizepart 3 350m

(parted) print
Model: Kingston DataTraveler 2.0 (scsi)
Disk /dev/sdb: 1999MB
Sector size (logical/physical): 512B/512B
Partition Table: gpt
Disk Flags:

Number  Start   End     Size    File system  Name     Flags
 1      1049kB  99.6MB  98.6MB  ext4         primary
 2      99.6MB  200MB   100MB   ext4
 3      200MB   350MB   150MB   ext4         primary
```
Помните, что новая конечная точка указывается, отсчитывая от начала диска. Итак, поскольку раздел `3` заканчивался на 300 МБ, теперь он должен заканчиваться на 350 МБ.

Но изменение размера раздела - это только часть задачи. Вам также необходимо изменить размер файловой системы, которая находится в ней. Для файловых систем ext2/3/4 это делается с помощью команды `resize2fs`. В случае приведенного выше примера, раздел `3` по-прежнему показывает «старый» размер при монтировании:
```
$ df -h /dev/sdb3
Filesystem      Size  Used Avail Use% Mounted on
/dev/sdb3        88M  1.6M   80M   2% /media/carol/part3
```
Для настройки размера можно использовать команду `resize2fs DEVICE SIZE`, где `DEVICE` соответствует разделу, размер которого вы хотите изменить, а `SIZE` - новому размеру. Если вы опустите параметр размера, он будет использовать все доступное пространство раздела. Перед изменением размера рекомендуется размонтировать раздел.

В приведенном выше примере:
```
$ sudo resize2fs /dev/sdb3
resize2fs 1.44.6 (5-Mar-2019)
Resizing the filesystem on /dev/sdb3 to 146212 (1k) blocks.
The filesystem on /dev/sdb3 is now 146212 (1k) blocks long.

$ df -h /dev/sdb3
Filesystem      Size  Used Avail Use% Mounted on
/dev/sdb3       135M  1.6M  123M   2% /media/carol/part3
```
Чтобы *уменьшить* раздел, процесс нужно проделать в обратном порядке. *Сначала* вы изменяете размер файловой системы до нового, меньшего размера, затем вы изменяете размер самого раздела с помощью `parted`.

>Обратите внимание, что при уменьшении разделов, если вы выполните действия в неправильном порядке, вы потеряете данные!

В нашем примере:
```
# resize2fs /dev/sdb3 88m
resize2fs 1.44.6 (5-Mar-2019)
Resizing the filesystem on /dev/sdb3 to 90112 (1k) blocks.
The filesystem on /dev/sdb3 is now 90112 (1k) blocks long.

# parted /dev/sdb3
(parted) resizepart 3 300m
Warning: Shrinking a partition can cause data loss, are you sure
you want to continue?

Yes/No? y

(parted) print
Model: Kingston DataTraveler 2.0 (scsi)
Disk /dev/sdb: 1999MB
Sector size (logical/physical): 512B/512B
Partition Table: gpt
Disk Flags:

Number  Start   End     Size    File system  Name     Flags
 1      1049kB  99.6MB  98.6MB  ext4         primary
 2      99.6MB  200MB   100MB   ext4
 3      200MB   300MB   99.7MB  ext4         primary
```
>Вместо того, чтобы указывать новый размер, вы можете использовать параметр `-M` для `resize2fs`, чтобы настроить размер файловой системы, чтобы она была достаточно большой для файлов на ней.


# Создание разделов подкачки

