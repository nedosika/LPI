# 103.5 Урок 1

| Сертификат:   | LPIC-1                                      |
|:--------------|:--------------------------------------------|
| Версия:       | 5.0                                         |
| Тема:         | 103 GNU и Unix комманды                     |                           
| Цель:         | 103.5 Создание, мониторинг и завершение процессов |
| Урок:         | 1 из 2                                      |


# Введение

Каждый раз, когда мы вызываем команду, запускаются один или несколько процессов. Хорошо обученный системный администратор должен не только создавать процессы, но и уметь отслеживать их и отправлять им различные типы сигналов, если это необходимо. В этом уроке мы рассмотрим управление заданиями и то, как отслеживать процессы.


## Управление заданиями

Задания - это процессы, которые были запущены в интерактивном режиме через терминал, отправлены в фоновый режим и еще не завершены. Вы можете узнать об активных заданиях (и их статусе) в вашей системе Linux, выполнив `jobs`:
```
$ jobs
```
Приведенная выше команда `jobs` не дала никаких результатов, что означает в данный момент нет активных заданий. Давайте создадим наше первое задание, запустив команду, выполнение которой занимает некоторое время (команда `sleep` с параметром `60`), и - во время работы - нажмите `Ctrl` + `Z`:
```
$ sleep 60
^Z
[1]+  Stopped                 sleep 60
```
Выполнение команды было остановлено (или, скорее, приостановлено), а командная строка снова доступна. Теперь запустив комманду `jobs` во второй раз, вы обнаружите приостановленное задание:
```
$ jobs
[1]+  Stopped                 sleep 60
```
Поясним результат:

* `[1]`  
Это число является идентификатором задания и может использоваться - перед ним стоит символ процента (`%`) - для изменения статуса задания с помощью утилит `fg`, `bg` и `kill` (как будет показано позже). 
* `+`  
Знак «плюс» указывает на текущее задание по умолчанию (то есть последнее приостановленное или отправленное в фоновом режиме). Предыдущее задание помечается знаком минус (`-`). Любые другие предыдущие работы не помечаются. 
* `Stopped`  
Описание статуса работы. 
* `sleep 60`  
Сама команда или задание. 


С параметром `-l` задания будут дополнительно отображать идентификатор процесса (PID) прямо перед статусом:
```
$ jobs -l
[1]+  1114 Stopped                 sleep 60
```
Остальные возможные варианты работы: 
* `-n`  
Перечисляет только процессы, которые изменили статус с момента последнего уведомления. Возможный статус: "Работает", "Остановлен", "Завершено" или "Готово". 
* `-p`  
Перечисляет идентификаторы процессов. 
* `-r`  
Перечисляет только запущенные задания. 
* `-s`  
Список только остановленных (или приостановленных) заданий.

>Помните, что у задания есть как идентификатор `задания`, так и `идентификатор процесса` (PID).


## Спецификация заданий

Команде `jobs`, а также другим утилитам, таким как `fg`, `bg` и `kill` (которые вы увидите в следующем разделе), требуется спецификация задания (или `jobspec`), чтобы действовать в соответствии с конкретным заданием. Как мы только что видели, это может быть - и обычно это - идентификатор задания, которому предшествует `%`. Однако возможны и другие спецификации работы. Давайте посмотрим на них: 

* `%n`  
Работа с идентификационным номером `n`:
```
$ jobs %1
[1]+  Stopped                 sleep 60
```
* `%str`  
Задание, командная строка которого начинается с `str`:
```
$ jobs %sl
[1]+  Stopped                 sleep 60
```
* `%?str`  
Задание, командная строка которого содержит `str`:
```
$ jobs %?le
[1]+  Stopped                 sleep 60
```
* `%+` или `%%`  
Текущее задание (последнее было запущено в фоновом режиме или приостановлено на переднем плане):
```
$ jobs %+
[1]+  Stopped                 sleep 60
```
* `%-`  
Предыдущее задание (то, которое было `%+` до задания по умолчанию, текущее):
```
$ jobs %-
[1]+  Stopped                 sleep 60
```
В нашем случае, поскольку есть только одно задание, оно одновременно и текущее, и предыдущее.


## Статус задания: приостановлено, передний план и фоновый режим

Когда задание находится в фоновом режиме или было приостановлено, мы можем сделать с ним любое из трех действий:
1. Вывести его на передний план с помощью `fg`:
```
$ fg %1
sleep 60
```
`fg` перемещает указанное задание на передний план и делает его текущим. Теперь мы можем дождаться его завершения, снова остановить его с помощью `Ctrl`+`Z` или завершить его с помощью `Ctrl`+`C`. 
2. Переместите его в фоновыйрежим с помощью `bg`:
```
$ bg %1
[1]+ sleep 60 &
```
Находясь в фоновом режиме, задание можно вернуть на передний план с помощью `fg` или завершить (см. ниже). Обратите внимание на амперсанд (`&`), означающий, что задание было отправлено в фоновый режим. Фактически, вы также можете использовать амперсанд для запуска процесса непосредственно в фоновом режиме:
```
$ sleep 100 &
[2] 970
```
Вместе с идентификатором нового задания (`[2]`) теперь мы также получаем его идентификатор процесса (`970`). Теперь оба задания работают в фоновом режиме:
```
$ jobs
[1]-  Running                 sleep 60 &
[2]+  Running                 sleep 100 &
```
Чуть позже завершается выполнение первого задания:
```
$ jobs
[1]-  Done                    sleep 60
[2]+  Running                 sleep 100 &
```
3. Завершите его сигналом `SIGTERM` с помощью `kill`:
```
$ kill %2
```
Чтобы убедиться, что задание было прервано, снова запустите `jobs`:
```
$ jobs
[2]+  Terminated                 sleep 100
```
>Если задание не указано, `fg` и `bg` будут действовать в соответствии с текущим заданием по умолчанию. `kill`, однако, всегда требует указания спецификации задания.


## Отключенные задания: `nohup`

Все задания, которые мы видели в предыдущих разделах, были привязаны к сеансу пользователя, который их вызвал. Это означает, что если сеанс завершается, задания исчезают. Однако можно отсоединять задания от сеансов и запускать их даже после закрытия сеанса. Это достигается с помощью команды `nohup` («без зависания»). Синтаксис следующий:
```
nohup COMMAND &
```
Помните, что `&` отправляет процесс в фоновый режим и освобождает терминал, на котором вы работаете. Давайте отключим фоновое задание `ping localhost` от текущего сеанса:
```
$ nohup ping localhost &
[1] 1251
$ nohup: ignoring input and appending output to 'nohup.out'
^C
```
Вывод показывает нам идентификатор задания (`[1]`) и PID (`1251`), за которым следует сообщение о файле `nohup.out`. Это файл по умолчанию, в котором будут сохранены `stdout` и `stderr`. Теперь мы можем нажать `Ctrl`+`C`, чтобы освободить командную строку, закрыть сеанс, запустить еще один как `root` и использовать `tail -f`, чтобы проверить, выполняется ли команда и выводятся ли данные в файл по умолчанию:
```
$ exit
logout
$ tail -f /home/carol/nohup.out
64 bytes from localhost (::1): icmp_seq=3 ttl=64 time=0.070 ms
64 bytes from localhost (::1): icmp_seq=4 ttl=64 time=0.068 ms
64 bytes from localhost (::1): icmp_seq=5 ttl=64 time=0.070 ms
^C
```
>Вместо использования `nohup.out` по умолчанию вы могли бы указать выходной файл по вашему выбору с помощью `nohup ping localhost > /path/to/your/file &`.

Если мы хотим завершить процесс, мы должны указать его PID:
```
# kill 1251
```


## Мониторинг процессов

Процесс или задача - это экземпляр запущенной программы. Таким образом, вы создаете новые процессы каждый раз, когда вводите команды в терминал. Команда `watch` выполняет программу периодически (по умолчанию 2 секунды) и позволяет нам наблюдать за изменением вывода программы с течением времени. Например, мы можем отслеживать, как изменяется средняя нагрузка по мере выполнения большего количества процессов, набрав `watch uptime`:
```
Every  2.0s: uptime          debian: Tue Aug 20 23:31:27 2019

 23:31:27 up 21 min,  1 user,  load average: 0.00, 0.00, 0.00
```
Команда выполняется до тех пор, пока не будет прервана, поэтому нам придется остановить ее с помощью `Ctrl`+`C`. В качестве вывода мы получаем две строки: первая соответствует `watch` и сообщает нам, как часто команда будет запускаться (Every `2.0s: uptime`), какую команду/программу нужно отслеживать (`uptime`), а также имя хоста и дата (`debian: Tue Aug 20 23:31:27 2019`). Вторая строка вывода - это время безотказной работы и включает время (`23:31:27`), сколько времени система работала (`up 21 min`), количество активных пользователей (`1 user`) и среднюю загрузку системы или количество процессы в состоянии выполнения или ожидания в течение последних 1, 5 и 15 минут (`load average: 0.00, 0.00, 0.00`). Точно так же вы можете проверить использование памяти при создании новых процессов с помощью `watch free`:
```
Every  2.0s: free            debian: Tue Aug 20 23:43:37 2019

 23:43:37 up 24 min,  1 user,  load average: 0.00, 0.00, 0.00
              total        used        free      shared  buff/cache   available
Mem:       16274868      493984    14729396       35064     1051488    15462040
Swap:      16777212           0    16777212
```
Чтобы изменить интервал обновления для `watch`, используйте параметры `-n` или `--interval` плюс количество секунд, как в:
```
$ watch -n 5 free
```
Теперь команда `free` будет запускаться каждые 5 секунд.

Для получения дополнительной информации о `uptime`, `free` и `watch`, пожалуйста, обратитесь к их страницам руководства.

>Информация, предоставленная `uptime` и `free`, также интегрирована в более полные инструменты `top` и `ps` (см. ниже).


## Отправка сигналов процессам: `kill`

Каждый процесс имеет уникальный идентификатор или PID. Один из способов узнать PID процесса - использовать команду `pgrep`, за которой следует имя процесса:
```
$ pgrep sleep
1201
```
>Идентификатор процесса также можно узнать с помощью команды `pidof` (например, `pidof sleep`).

Подобно `pgrep`, команда `pkill` завершает процесс на основе его имени:
```
$ pkill sleep
[1]+  Terminated              sleep 60
```
Чтобы завершить несколько экземпляров одного и того же процесса, можно использовать команду `killall`:
```
$ sleep 60 &
[1] 1246
$ sleep 70 &
[2] 1247
$ killall sleep
[1]-  Terminated              sleep 60
[2]+  Terminated              sleep 70
```
И `pkill`, и `killall` работают так же, как и `kill`, поскольку они отправляют сигнал завершения указанному процессу(ам). Если сигнал не предоставляется, отправляется значение по умолчанию `SIGTERM`. Однако `kill` принимает в качестве аргумента только задание или идентификатор процесса. 

Сигналы могут быть указаны как:
* Name:
```
$ kill -SIGHUP 1247
```
* Nummber:
```
$ kill -1 1247
```
* Option:
```
$ kill -s SIGHUP 1247
```
Чтобы `kill` работал аналогично `pkill` или `killall`(и сохранил себе команды, чтобы сначала узнать PID), мы можем использовать подстановку команд:
```
$ kill -1 $(pgrep sleep)
```
Как вы уже знаете, альтернативный синтаксис - `kill -1 'pgrep sleep'`.
>Чтобы получить исчерпывающий список всех сигналов завершения и их кодов, введите в терминал `kill -l`. Используйте `-KILL` (`-9` или `-s KILL`), чтобы завершить необходимый процесс при сбое любого другого сигнала.


## `top` и `ps`

Когда дело доходит до мониторинга процессов, есть два незаменимых инструмента - `top` и `ps`. В то время как первое производит вывод динамически, второе - статически. В любом случае, обе являются отличными утилитами для полного обзора всех процессов в системе.


### Взаимодействие с `top`

Чтобы вызвать `top`, просто введите `top`:
```
$ top

top - 11:10:29 up  2:21,  1 user,  load average: 0,11, 0,20, 0,14
Tasks:  73 total,   1 running,  72 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0,0 us,  0,3 sy,  0,0 ni, 99,7 id,  0,0 wa,  0,0 hi,  0,0 si,  0,0 st
KiB Mem :  1020332 total,   909492 free,    38796 used,    72044 buff/cache
KiB Swap:  1046524 total,  1046524 free,        0 used.   873264 avail Mem

   PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND
   436 carol     20   0   42696   3624   3060 R  0,7  0,4   0:00.30 top
     4 root      20   0       0      0      0 S  0,3  0,0   0:00.12 kworker/0:0
   399 root      20   0   95204   6748   5780 S  0,3  0,7   0:00.22 sshd
     1 root      20   0   56872   6596   5208 S  0,0  0,6   0:01.29 systemd
     2 root      20   0       0      0      0 S  0,0  0,0   0:00.00 kthreadd
     3 root      20   0       0      0      0 S  0,0  0,0   0:00.02 ksoftirqd/0
     5 root       0 -20       0      0      0 S  0,0  0,0   0:00.00 kworker/0:0H
     6 root      20   0       0      0      0 S  0,0  0,0   0:00.00 kworker/u2:0
     7 root      20   0       0      0      0 S  0,0  0,0   0:00.08 rcu_sched
     8 root      20   0       0      0      0 S  0,0  0,0   0:00.00 rcu_bh
     9 root      rt   0       0      0      0 S  0,0  0,0   0:00.00 migration/0
    10 root       0 -20       0      0      0 S  0,0  0,0   0:00.00 lru-add-drain
    (...)
```
`top` позволяет пользователю некоторое взаимодействие. По умолчанию вывод сортируется по проценту процессорного времени, используемого каждым процессом, в порядке убывания. Это поведение можно изменить, нажав следующие клавиши `top`:

* `M`  
Сортировать по использованию памяти.  
* `N`  
Сортировать по идентификатору процесса.  
* `Т`  
Сортировать по времени работы.  
* `P`  
Сортировать по проценту использования ЦП.

>Для переключения между порядком убывания и возрастания просто нажмите `R`.  

Другие интересные ключи для взаимодействия с `top`:
* `?` или `h`  
Помощь. 
* `k`  
Завершить процесс. `top` запросит `PID` процесса, который нужно убить, а также послать сигнал (по умолчанию `SIGTERM` или `15`). 
* `r`  
Изменить приоритет процесса (`renice`). `top` спросит у вас значение `nice`. Возможные значения находятся в диапазоне от -20 до 19, но только суперпользователь (`root`) может установить для него значение, отрицательное или меньшее, чем текущее. 
* `u`  
Список процессов определенного пользователя (по умолчанию отображаются процессы от всех пользователей). 
* `c`  
Показывать абсолютные пути программ и различать процессы пользовательского пространства и процессы пространства ядра (в квадратных скобках). 
* `V`  
Дерево/иерархия процессов. 
* `t` и `m`  
    Измените внешний вид показаний ЦП и памяти соответственно в четырехэтапном цикле: первые два нажатия показывают индикаторы выполнения, третье скрывает полосу, а четвертое возвращает ее. 
* `W`  
    Сохранить настройки конфигурации в `~/.toprc`.

>Более интересная и удобная версия `top` - это `htop`. Другая - возможно, более исчерпывающая альтернатива это `atop`. Если они еще не установлены в вашей системе, используйте диспетчер пакетов, чтобы установить их и попробовать.


### Расшифровка вывода `top`
Вывод `top` разделен на две области: `область сводки` и `область задач`.

#### Область суммарной информации `top`

*Область суммарной информации* состоит из пяти верхних строк и дает нам следующую информацию:
* `top - 11:10:29 up 2:21, 1 user, load average: 0,11, 0,20, 0,14`
    * `current time`(в 24-часовом формате): `11:20:29` 
    * `uptime`(сколько времени система была запущена и работала): `up 2:21` 
    * количество пользователей, вошедших в систему, и средняя загрузка ЦП за последние 1, 5 и 15 минут соответственно: `load average: 0,11, 0,20, 0,14` 

* `Tasks: 73 total, 1 running, 72 sleeping, 0 stopped, 0 zombie` (информация о процессах) 
    * общее количество процессов в активном режиме: `73 total` 
    * (выполняемые): `1 running` 
    * спящие (ожидающие возобновления исполнения): `72 sleeping`
    * (по сигналу управления заданием): `0 stopped` 
    * зомби (те, которые завершили выполнение, но все еще ждут, пока их родительский процесс удалит их из таблицы процессов): `0 zombie` 

* `%Cpu(s): 0,0 us, 0,3 sy, 0,0 ni, 99,7 id, 0,0 wa, 0,0 hi, 0,0 si, 0,0 st` (процент процессорного времени потрачено на) 
    * пользовательские процессы: `0,0 us` 
    * система/процессы ядра: `0,4 sy`
    * процессы установлены на хорошее значение - чем лучше значение, тем ниже приоритет: `0,0 ni`
    * ничего - время простоя процессора: `99,7 id`
    * процессы, ожидающие операций ввода/вывода: `0,0 wa` 
    * процессы, обслуживающие аппаратные прерывания - периферийные устройства, отправляющие процессору сигналы, требующие внимания: `0,0 hi` 
    * процессы, обслуживающие программные прерывания: `0,0 si` 
    * процессы, обслуживающие задачи других виртуальных машин в виртуальной среде, следовательно, крадут время: `0,0 st` 

* `KiB Mem : 1020332 total, 909492 free, 38796 used, 72044 buff/cache` (информация о памяти в килобайтах) 
    * общий объем памяти: `1020332 total` 
    * неиспользуемая память: `909492 free` 
    * используемая память: `38796 used`  
    * память, которая буферизуется и кэшируется, чтобы избежать чрезмерного доступа к диску: `72044 buff/cache`  
Обратите внимание,`total` является суммой трех других значений - `free`, `used` и `buff/cache` - (в нашем случае примерно 1 ГБ). 

* `KiB Swap: 1046524 total, 1046524 free, 0 used. 873264 avail Mem` (информация подкачки в килобайтах) 
    * общий объем подкачки: `1046524 total` 
    * неиспользуемое пространство подкачки: `1046524 free` 
    * пространство подкачки используется: `0 used` 
    * объем памяти подкачки, который может быть выделен процессам без дополнительной подкачки: `873264 avail Mem`


#### Область задач `top`: поля и столбцы

Под областью суммарной информации находится область задач, которая включает ряд полей и столбцов, сообщающих информацию о запущенных процессах: 

* `PID`  
Идентификатор процесса. 
* `USER`  
Пользователь, выполнивший команду, сгенерировавшую процесс. 
* `PR`  
Приоритет процесса ядру. 
* `NI`  
Значение приоритета процесса. Более низкие значения имеют более высокий приоритет, чем более высокие. 
* `VIRT`  
Общий объем памяти, используемый процессом (включая Swap). 
* `RES`  
Оперативная память, используемая процессом. 
* `SHR`  
Общая память процесса с другими процессами. 
* `S`  
Статус процесса. Значения включают в себя: `S` (прерывистый сон - ожидание завершения события), `R` (рабочий - выполняется или находится в очереди для выполнения) или `Z` (зомби - завершенные дочерние процессы, структуры данных которых еще не были удалены из таблицы процессов). 
* `%CPU`  
Процент процессора, используемого процессом. 
* `%MEM`  
Процент ОЗУ, используемого процессом, то есть значение `RES`, выраженное в процентах. 
* `TIME+`  
Общее время активности процесса. 
* `COMMAND`  
Имя команды/программы, сгенерировавшей процесс.


### Статический просмотр процессов: `ps`

Как было сказано выше, `ps` показывает список процессов. Чтобы увидеть все процессы с помощью терминала (tty), введите `ps a`:
```
$ ps a
  PID TTY      STAT   TIME COMMAND
  386 tty1     Ss+    0:00 /sbin/agetty --noclear tty1 linux
  424 tty7     Ssl+   0:00 /usr/lib/xorg/Xorg :0 -seat seat0 (...)
  655 pts/0    Ss     0:00 -bash
 1186 pts/0    R+     0:00 ps a
 (...)
 ```
 
 #### Описание синтаксиса параметров и вывода `ps`
 
Что касается опций, `ps` может принимать три разных стиля: BSD, UNIX и GNU. Давайте посмотрим, как каждый из этих стилей будет работать при сообщении информации о конкретном идентификаторе процесса:

* BSD  
Дефис не ставится перед параметрами:
```
$ ps p 811
  PID TTY      STAT   TIME COMMAND
  811 pts/0    S      0:00 -su
```
* UNIX  
Параметры идут после дефиса:
```
$ ps -p 811
  PID TTY          TIME CMD
  811 pts/0    00:00:00 bash
```
* GNU  
Параметры сопровождаются двойным дефисом в начале:
```
$ ps --pid 811
  PID TTY          TIME CMD
  811 pts/0    00:00:00 bash
```
Во всех трех случаях `ps` сообщает информацию о процессе с `PID` равным `811`, в данном случае это `bash`. 

Точно так же вы можете использовать `ps` для поиска процессов, запущенных конкретным пользователем: 
* `ps U carol` (BSD) 
* `ps -u carol` (UNIX) 
* `ps --user carol` (GNU) 

Давайте проверим процессы, запущенные `carol`:
```
$ ps U carol
  PID TTY      STAT   TIME COMMAND
  811 pts/0    S      0:00 -su
  898 pts/0    R+     0:00 ps U carol
```
Она запустила два процесса: `bash` (`-su`) и `ps` (`ps U carol`). Столбец `STAT` сообщает нам состояние процесса (см. ниже). 

Мы можем получить максимум от `ps`, комбинируя некоторые из его параметров. Очень полезной командой (выводящей результат, аналогичной команде `top`) является `ps aux` (стиль BSD). В этом случае отображаются процессы из всех оболочек (не только текущей). Смысл переключателей следующий: 
* `а`  
Показать процессы, подключенные к `tty` или терминалу. 
* `u`  
Формат отображения, ориентированный на пользователя. 
* `x`  
Показать процессы, не подключенные к `tty` или терминалу.
```
$ ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.1 204504  6780 ?        Ss   14:04   0:00 /sbin/init
root         2  0.0  0.0      0     0 ?        S    14:04   0:00 [kthreadd]
root         3  0.0  0.0      0     0 ?        S    14:04   0:00 [ksoftirqd/0]
root         5  0.0  0.0      0     0 ?        S<   14:04   0:00 [kworker/0:0H]
root         7  0.0  0.0      0     0 ?        S    14:04   0:00 [rcu_sched]
root         8  0.0  0.0      0     0 ?        S    14:04   0:00 [rcu_bh]
root         9  0.0  0.0      0     0 ?        S    14:04   0:00 [migration/0]
(...)
```
Поясним столбцы: 
* `USER`  
Владелец процесса. 
* `PID`  
Идентификатор процесса. 
* `%CPU`  
Процент использования ЦП. 
* `%MEM`  
Процент используемой физической памяти. 
* `VSZ`  
Виртуальная память процесса в KB. 
* `RSS`  
Физическая память без подкачки, используемая процессом в KB. 
* `TT`  
Терминал (`tty`), контролирующий процесс. 
* `STAT`  
Код, представляющий состояние процесса. Помимо `S`, `R` и `Z` (которые мы видели при описании вывода команды `top`), другие возможные значения включают: `D` (непрерывный сон - обычно ожидает ввода/вывода), `T` (остановлен - обычно по управляющему сигналу). Некоторые дополнительные модификаторы включают: `<`(высокий приоритет - не подходит для других процессов), `N` (низкий приоритет - подходит для других процессов) или `+` (в группе процессов переднего плана). 
* `STARTED`  
Время начала процесса. 
* `TIME`  
Накопленное процессорное время. 
* `COMMAND`  
Команда, запустившая процесс.


# Упражнения для закрепления

1. `oneko` - это забавная программа, которая отображает кошку, преследующую ваш курсор мыши. Если она еще не установлена на вашей системе, установите ее с помощью менеджера пакетов вашего дистрибутива. Мы будем использовать ее для изучения управления заданиями. 
* Запустите программу. Как бы вы это сделали?
```
   
```
* Переместите курсор мыши, чтобы увидеть, как кошка его преследует. Теперь приостановите процесс. Как бы вы это сделали? Что будет на экране? 
```

```
* Проверьте, сколько у вас сейчас работающих заданий. Как бы ты это сделал? Что будет на экране?
```

```
* Теперь отправьте его в фоновый режим, указав его идентификатор задания. Что будет на экране?
```

```
* Как узнать, что задание выполняется в фоновом режиме? 
```

```
* Наконец, завершите задание, указав его номер. Как бы ты это сделал?
```

```
2. Найдите `PID` всех процессов, порожденных веб-сервером Apache HTTPD(`apache2`), с помощью двух разных команд: 
```


```
3. Завершите все процессы `apache2` без использования их PID и двумя разными командами: 
```


```
4. Предположим, вам нужно завершить работу всех экземпляров `apache2`, и у вас нет времени узнать их идентификаторы `PID`. Как бы вы это сделали, используя `kill` с сигналом `SIGTERM` по умолчанию одной строкой: 
```

```
5. Запустите `top` и взаимодействуйте с ним, выполнив следующие действия: 
* Покажите список процессов в виде дерева: 
```

```
* Покажите полные пути процессов, различающих пространство пользователя и пространство ядра: 
```

```
6. Введите команду `ps`, чтобы отобразить все процессы, запущенные пользователем веб-сервера Apache HTTPD (`www-data`): 
* Используя синтаксис BSD: 
```

```
* Используя синтаксис UNIX: 
```

```
* Используя синтаксис GNU:
```

```


# Упражнения на размышление

1. Сигнал `SIGHUP` может использоваться как способ перезапуска определенных демонов. Например, отправка `SIGHUP` родительскому процессу веб-сервера *Apache HTTPD*(запущенному `init`) убивает его дочерние процессы. Однако родительский процесс повторно считывает свои файлы конфигурации, повторно открывает файлы журнала и порождает новый набор дочерних процессов. Выполните следующие задачи: 
* Запустите веб-сервер: 
```

```

* Убедитесь, что вы знаете PID родительского процесса: 
```
 
```
* Сделайте перезапуск веб-сервера *Apache HTTPD*, отправив ему сигнал `SIGHUP` родительскому процессу: 
```

```
* Убедитесь, что родитель не был убит и были созданы новые дочерние элементы: 
```

```

2. Хотя изначально вывод `ps` был статическим, его можно превратить в динамический, объединив `ps` и `watch`. Мы будем отслеживать веб-сервер *Apache HTTPD* на предмет новых подключений. Перед выполнением задач, описанных ниже, рекомендуется прочитать описание директивы `MaxConnectionsPerChild` в [Apache MPM Common Directives](https://httpd.apache.org/docs/current/mod/mpm_common.html). 
* Добавьте директиву `MaxConnectionsPerChild` со значением 1 в файл конфигурации apache2 - в *Debian* подобны ОС, он находится в `/etc/apache2/apache2.conf`; в семействе *CentOS* в `/etc/httpd/conf/httpd.conf`. Не забудьте перезапустить `apache2`, чтобы изменения вступили в силу. 
```

```
* Введите команду, которая использует `watch`, `ps` и `grep` для соединений `apache2`. 
```

```
* Теперь откройте веб-браузер или используйте браузер командной строки, например `lynx`, чтобы установить соединение с веб-сервером через его IP-адрес. Что вы наблюдаете на выходе `watch`? 
```

```

3. Как вы узнали, по умолчанию `top` сортирует задачи по проценту использования ЦП в порядке убывания (более высокие значения вверху). Это поведение можно изменить с помощью интерактивных клавиш `M` (использование памяти), `N` (уникальный идентификатор процесса), `T` (время работы) и `P` (процент времени ЦП). Однако вы также можете отсортировать список задач по своему вкусу, запустив `top` с помощью параметра `-o` (для получения дополнительной информации проверьте страницу руководства `top`). Теперь выполните следующие задачи: 
* Запустите `top`, чтобы задачи были отсортированы по использованию памяти: 
```

```

* Убедитесь, что вы ввели правильную команду, выделив столбец памяти: 
```

```

4. `ps` также имеет параметр `o`, чтобы указать столбцы, которые вы хотите показать. Изучите этот вариант и выполните следующие задачи: 
* Запустите `ps`, чтобы отображалась только информация о пользователе, процентах используемой памяти, процентах используемого процессорного времени и полной команде: 
```

```
* Теперь запустите `ps`, чтобы отображалась только информация о пользователе и названии программ, которые он использует:
```

```


# Резюме

В этом уроке вы узнали о *заданиях* и *контроле над ними*. Следует помнить о следующих важных фактах и концепциях: 
* Задания - это процессы, которые отправляются в фоновый режим. 
* Помимо идентификатора процесса, при создании, заданиям также назначается идентификатор задания. 
* Для управления заданиями требуется спецификация задания (`jobpec`). 
* Задания могут быть переведены на передний план, отправлены на задний план, приостановлены и прекращены (или *уничтожены*). 
* Задание можно отсоединить от терминала и сеанса, в котором оно было создано.


Точно так же мы также обсудили концепцию процессов и мониторинга процессов. Наиболее актуальные идеи: 
* Процессы - это запущенные программы. 
* Процессы можно контролировать. 
* Различные утилиты позволяют нам узнавать идентификаторы процессов, а также посылать им сигналы для их завершения. 
* Сигналы могут быть указаны по имени (например, `-SIGTERM`), номеру (например, `-15`) или параметру (например, `-s SIGTERM`). 
* `top` и `ps` очень эффективны, когда дело касается процессов мониторинга. Результат первого является динамическим и постоянно обновляется; с другой стороны, `ps` показывает вывод статически. 


Команды, используемые в этом уроке: 

* `jobs`  
Отображение активных заданий и их статуса. 
* `sleep`  
Приостановка процесса на определенное время. 
* `fg`  
Перевести задание на передний план. 
* `bg`  
Перевести задание в фоновый режим. 
* `kill`  
Завершить задание. 
* `nohup`  
Отсоединить задание от сеанса/терминала. 
* `exit`  
Выйти из текущей оболочки. 
* `tail`  
Показать самые последние строки в файле. 
* `watch`  
Выполнять команду повторно(по умолчанию цикл составляет 2 секунды). 
* `uptime`  
Отображение продолжительности работы системы, количества текущих пользователей и средней нагрузки на систему. 
* `free`  
Отображение использования памяти. 
* `pgrep`  
Найти идентификатор процесса по имени. 
* `pidof`  
Найти идентификатор процесса по имени. 
* `pkill`  
Отправить сигнал процессу по имени. 
* `killall`  
Убить процесс(ы) по имени. 
* `top`  
Отображение процессов Linux. 
* `ps`  
Показать список текущих процессов статически.


# Ответы на упражнения для закрепления

1. `oneko` - это забавная программа, которая отображает кошку, преследующую ваш курсор мыши. Если она еще не установлена на вашей системе, установите ее с помощью менеджера пакетов вашего дистрибутива. Мы будем использовать ее для изучения управления заданиями. 
* Запустите программу. Как бы вы это сделали?  
  Набираем `oneko` в терминале.

* Переместите курсор мыши, чтобы увидеть, как кошка его преследует. Теперь приостановите процесс. Как бы вы это сделали? Что будет на экране?  
Нажимаем комбинацию клавиш `Ctrl`+`z`:  
```
[1]+  Stopped                 oneko
```

* Проверьте, сколько у вас сейчас работающих процессов. Что бы ты это сделал? Что будет на экране?
```
$ jobs
[1]+  Stopped                 oneko
```

* Теперь отправьте его в фоновый режим, указав его идентификатор задания. Что будет на экране? Как узнать, что задание выполняется в фоновом режиме? 
```
$ bg %1
[1]+ oneko &
```  
Кот снова движется. 

* Наконец, завершите задание, указав его идентификатор. Что бы ты набрал?  
```
$ kill %1
```

2. Найдите `PID` всех процессов, порожденных веб-сервером Apache HTTPD(`apache2`), с помощью двух разных команд: 
```
$ pgrep apache2
$ pidof apache2
```
3. Завершите все процессы `apache2` без использования их PID и двумя разными командами: 
```
$ pkill apache2
$ killall apache2
```
4. Предположим, вам нужно завершить работу всех экземпляров `apache2`, и у вас нет времени узнать их идентификаторы `PID`. Как бы вы это сделали, используя `kill` с сигналом `SIGTERM` по умолчанию одной строкой: 
```
$ kill $(pgrep apache2)
$ kill `pgrep apache2`

$ kill $(pidof apache2)
$ kill `pidof apache2`
```
>	Поскольку `SIGTERM` (`15`) является сигналом по умолчанию, нет необходимости передавать какие-либо параметры `kill`.
5. Запустите `top` и взаимодействуйте с ним, выполнив следующие действия: 
* Покажите список процессов в виде дерева:  
Нажимаем `V`
* Покажите полные пути процессов, различающих пространство пользователя и пространство ядра:  
Нажимаем `c`
6. Введите команду `ps`, чтобы отобразить все процессы, запущенные пользователем веб-сервера Apache HTTPD (`www-data`): 
* Используя синтаксис BSD: 
```
$ pu U www-data
```
* Используя синтаксис UNIX: 
```
$ ps -u www-data
```
* Используя синтаксис GNU:
```
$ ps --user www-data
```


# Ответы на упражнения для размышления

1. Сигнал `SIGHUP` может использоваться как способ перезапуска определенных демонов. Например, отправка `SIGHUP` родительскому процессу веб-сервера *Apache HTTPD*(запущенному `init`) убивает его дочерние процессы. Однако родительский процесс повторно считывает свои файлы конфигурации, повторно открывает файлы журнала и порождает новый набор дочерних процессов. Выполните следующие задачи: 
* Запустите веб-сервер: 
```
$ sudo systemctl start apache2
```

* Убедитесь, что вы знаете PID родительского процесса: 
```
$ ps aux | grep apache2 
```
Родительский процесс запущен пользователем `root`. В нашем случае тот, у которого PID `1653`.
* Сделайте перезапуск веб-сервера *Apache HTTPD*, отправив ему сигнал `SIGHUP` родительскому процессу: 
```
$ kill -SIGHUP 1653
```
* Убедитесь, что родитель не был убит и были созданы новые дочерние элементы: 
```
$ ps aux | grep apache2
```

2. Хотя изначально вывод `ps` был статическим, его можно превратить в динамический, объединив `ps` и `watch`. Мы будем отслеживать веб-сервер *Apache HTTPD* на предмет новых подключений. Перед выполнением задач, описанных ниже, рекомендуется прочитать описание директивы `MaxConnectionsPerChild` в [Apache MPM Common Directives](https://httpd.apache.org/docs/current/mod/mpm_common.html). 

* Добавьте директиву `MaxConnectionsPerChild` со значением 1 в файл конфигурации apache2 - в *Debian* подобны ОС, он находится в `/etc/apache2/apache2.conf`; в семействе *CentOS* в `/etc/httpd/conf/httpd.conf`. Не забудьте перезапустить `apache2`, чтобы изменения вступили в силу. 
Строка, которую нужно включить в файл конфигурации, - это `MaxConnectionsPerChild 1`. Один из способов перезапустить веб-сервер - через `sudo systemctl restart apache2`.

* Введите команду, которая использует `watch`, `ps` и `grep` для соединений `apache2`. 
```
$ watch 'ps aux | grep apache2'
или
$ watch "ps aux | grep apache2"
```

* Теперь откройте веб-браузер или используйте браузер командной строки, например `lynx`, чтобы установить соединение с веб-сервером через его IP-адрес. Что вы наблюдаете на выходе `watch`?  
Один из дочерних процессов, принадлежащих `www-data`, исчезает.

3. Как вы узнали, по умолчанию `top` сортирует задачи по проценту использования ЦП в порядке убывания (более высокие значения вверху). Это поведение можно изменить с помощью интерактивных клавиш `M` (использование памяти), `N` (уникальный идентификатор процесса), `T` (время работы) и `P` (процент времени ЦП). Однако вы также можете отсортировать список задач по своему вкусу, запустив `top` с помощью параметра `-o` (для получения дополнительной информации проверьте страницу руководства `top`). Теперь выполните следующие задачи: 
* Запустите `top`, чтобы задачи были отсортированы по использованию памяти: 
```
$ top -o %MEM
```
* Убедитесь, что вы ввели правильную команду, выделив столбец памяти:  
Нажимаем `x`.

4. `ps` также имеет параметр `o`, чтобы указать столбцы, которые вы хотите показать. Изучите этот вариант и выполните следующие задачи: 
* Запустите `ps`, так чтобы отображалась только информация о *user, percentage of memory used, percentage of CPU time used* и *full command*: 
```
$ ps o user,%mem,%cpu,cmd
```
* Теперь запустите `ps`, так чтобы отображалась только информация о пользователе и название программ, которые он использует:
```
$ ps o user,comm
```
