# 103.5 Урок 1

| Сертификат:   | LPIC-1                                      |
|:--------------|:--------------------------------------------|
| Версия:       | 5.0                                         |
| Тема:         | 103 GNU и Unix комманды                     |                           
| Цель:         | 103.5 Создание, мониторинг и завершение процессов |
| Урок:         | 1 из 2                                      |


# Введение

Каждый раз, когда мы вызываем команду, запускаются один или несколько процессов. Хорошо обученный системный администратор должен не только создавать процессы, но и уметь отслеживать их и отправлять им различные типы сигналов, если это необходимо. В этом уроке мы рассмотрим управление заданиями и то, как отслеживать процессы.


## Управление заданиями

Задания - это процессы, которые были запущены в интерактивном режиме через терминал, отправлены в фоновый режим и еще не завершены. Вы можете узнать об активных заданиях (и их статусе) в вашей системе Linux, выполнив `jobs`:
```
$ jobs
```
Приведенная выше команда `jobs` не дала никаких результатов, что означает в данный момент нет активных заданий. Давайте создадим наше первое задание, запустив команду, выполнение которой занимает некоторое время (команда `sleep` с параметром `60`), и - во время работы - нажмите `Ctrl` + `Z`:
```
$ sleep 60
^Z
[1]+  Stopped                 sleep 60
```
Выполнение команды было остановлено (или, скорее, приостановлено), а командная строка снова доступна. Теперь запустив комманду `jobs` во второй раз, вы обнаружите приостановленное задание:
```
$ jobs
[1]+  Stopped                 sleep 60
```
Поясним результат:

`[1]` 

Это число является идентификатором задания и может использоваться - перед ним стоит символ процента (`%`) - для изменения статуса задания с помощью утилит `fg`, `bg` и `kill` (как будет показано позже). 

`+` 

Знак «плюс» указывает на текущее задание по умолчанию (то есть последнее приостановленное или отправленное в фоновом режиме). Предыдущее задание помечается знаком минус (`-`). Любые другие предыдущие работы не помечаются. 

`Stopped` 

Описание статуса работы. 

`sleep 60` 

Сама команда или задание. 


С параметром `-l` задания будут дополнительно отображать идентификатор процесса (PID) прямо перед статусом:
```
$ jobs -l
[1]+  1114 Stopped                 sleep 60
```
Остальные возможные варианты работы: 

`-n` 

Перечисляет только процессы, которые изменили статус с момента последнего уведомления. Возможный статус: "Работает", "Остановлен", "Завершено" или "Готово". 

`-p` 

Перечисляет идентификаторы процессов. 

`-r` 

Перечисляет только запущенные задания. 

`-s` 

Список только остановленных (или приостановленных) заданий.

>Помните, что у задания есть как идентификатор `задания`, так и `идентификатор процесса` (PID).


## Спецификация заданий

Команде `jobs`, а также другим утилитам, таким как `fg`, `bg` и `kill` (которые вы увидите в следующем разделе), требуется спецификация задания (или `jobspec`), чтобы действовать в соответствии с конкретным заданием. Как мы только что видели, это может быть - и обычно это - идентификатор задания, которому предшествует `%`. Однако возможны и другие спецификации работы. Давайте посмотрим на них: 

`%n` 

Работа с идентификационным номером `n`:
```
$ jobs %1
[1]+  Stopped                 sleep 60
```

`%str`

Задание, командная строка которого начинается с `str`:
```
$ jobs %sl
[1]+  Stopped                 sleep 60
```

`%?str` 

Задание, командная строка которого содержит `str`:
```
$ jobs %?le
[1]+  Stopped                 sleep 60
```

`%+` или `%%`

Текущее задание (последнее было запущено в фоновом режиме или приостановлено на переднем плане):
```
$ jobs %+
[1]+  Stopped                 sleep 60
```
`%-` 

Предыдущее задание (то, которое было `%+` до задания по умолчанию, текущее):
```
$ jobs %-
[1]+  Stopped                 sleep 60
```
В нашем случае, поскольку есть только одно задание, оно одновременно и текущее, и предыдущее.


## Статус задания: приостановлено, передний план и фоновый режим

Когда задание находится в фоновом режиме или было приостановлено, мы можем сделать с ним любое из трех действий:
1. Вывести его на передний план с помощью `fg`:
```
$ fg %1
sleep 60
```
`fg` перемещает указанное задание на передний план и делает его текущим. Теперь мы можем дождаться его завершения, снова остановить его с помощью `Ctrl`+`Z` или завершить его с помощью `Ctrl`+`C`. 
2. Переместите его в фоновыйрежим с помощью `bg`:
```
$ bg %1
[1]+ sleep 60 &
```
Находясь в фоновом режиме, задание можно вернуть на передний план с помощью `fg` или завершить (см. ниже). Обратите внимание на амперсанд (`&`), означающий, что задание было отправлено в фоновый режим. Фактически, вы также можете использовать амперсанд для запуска процесса непосредственно в фоновом режиме:
```
$ sleep 100 &
[2] 970
```
Вместе с идентификатором нового задания (`[2]`) теперь мы также получаем его идентификатор процесса (`970`). Теперь оба задания работают в фоновом режиме:
```
$ jobs
[1]-  Running                 sleep 60 &
[2]+  Running                 sleep 100 &
```
Чуть позже завершается выполнение первого задания:
```
$ jobs
[1]-  Done                    sleep 60
[2]+  Running                 sleep 100 &
```
3. Завершите его сигналом `SIGTERM` с помощью `kill`:
```
$ kill %2
```
Чтобы убедиться, что задание было прервано, снова запустите `jobs`:
```
$ jobs
[2]+  Terminated                 sleep 100
```
>Если задание не указано, `fg` и `bg` будут действовать в соответствии с текущим заданием по умолчанию. `kill`, однако, всегда требует указания спецификации задания.


## Отключенные задания: `nohup`

Все задания, которые мы видели в предыдущих разделах, были привязаны к сеансу пользователя, который их вызвал. Это означает, что если сеанс завершается, задания исчезают. Однако можно отсоединять задания от сеансов и запускать их даже после закрытия сеанса. Это достигается с помощью команды `nohup` («без зависания»). Синтаксис следующий:
```
nohup COMMAND &
```
Помните, что `&` отправляет процесс в фоновый режим и освобождает терминал, на котором вы работаете. Давайте отключим фоновое задание `ping localhost` от текущего сеанса:
```
$ nohup ping localhost &
[1] 1251
$ nohup: ignoring input and appending output to 'nohup.out'
^C
```
Вывод показывает нам идентификатор задания (`[1]`) и PID (`1251`), за которым следует сообщение о файле `nohup.out`. Это файл по умолчанию, в котором будут сохранены `stdout` и `stderr`. Теперь мы можем нажать `Ctrl`+`C`, чтобы освободить командную строку, закрыть сеанс, запустить еще один как `root` и использовать `tail -f`, чтобы проверить, выполняется ли команда и выводятся ли данные в файл по умолчанию:
```
$ exit
logout
$ tail -f /home/carol/nohup.out
64 bytes from localhost (::1): icmp_seq=3 ttl=64 time=0.070 ms
64 bytes from localhost (::1): icmp_seq=4 ttl=64 time=0.068 ms
64 bytes from localhost (::1): icmp_seq=5 ttl=64 time=0.070 ms
^C
```
>Вместо использования `nohup.out` по умолчанию вы могли бы указать выходной файл по вашему выбору с помощью `nohup ping localhost > /path/to/your/file &`.

Если мы хотим завершить процесс, мы должны указать его PID:
```
# kill 1251
```


## Мониторинг процессов

Процесс или задача - это экземпляр запущенной программы. Таким образом, вы создаете новые процессы каждый раз, когда вводите команды в терминал. Команда `watch` выполняет программу периодически (по умолчанию 2 секунды) и позволяет нам наблюдать за изменением вывода программы с течением времени. Например, мы можем отслеживать, как изменяется средняя нагрузка по мере выполнения большего количества процессов, набрав `watch uptime`:
```
Every  2.0s: uptime          debian: Tue Aug 20 23:31:27 2019

 23:31:27 up 21 min,  1 user,  load average: 0.00, 0.00, 0.00
```
Команда выполняется до тех пор, пока не будет прервана, поэтому нам придется остановить ее с помощью `Ctrl`+`C`. В качестве вывода мы получаем две строки: первая соответствует `watch` и сообщает нам, как часто команда будет запускаться (Every `2.0s: uptime`), какую команду/программу нужно отслеживать (`uptime`), а также имя хоста и дата (`debian: Tue Aug 20 23:31:27 2019`). Вторая строка вывода - это время безотказной работы и включает время (`23:31:27`), сколько времени система работала (`up 21 min`), количество активных пользователей (`1 user`) и среднюю загрузку системы или количество процессы в состоянии выполнения или ожидания в течение последних 1, 5 и 15 минут (`load average: 0.00, 0.00, 0.00`). Точно так же вы можете проверить использование памяти при создании новых процессов с помощью `watch free`:
```
Every  2.0s: free            debian: Tue Aug 20 23:43:37 2019

 23:43:37 up 24 min,  1 user,  load average: 0.00, 0.00, 0.00
              total        used        free      shared  buff/cache   available
Mem:       16274868      493984    14729396       35064     1051488    15462040
Swap:      16777212           0    16777212
```
Чтобы изменить интервал обновления для `watch`, используйте параметры `-n` или `--interval` плюс количество секунд, как в:
```
$ watch -n 5 free
```
Теперь команда `free` будет запускаться каждые 5 секунд.

Для получения дополнительной информации о `uptime`, `free` и `watch`, пожалуйста, обратитесь к их страницам руководства.

>Информация, предоставленная `uptime` и `free`, также интегрирована в более полные инструменты `top` и `ps` (см. ниже).


## Отправка сигналов процессам: `kill`

Каждый процесс имеет уникальный идентификатор или PID. Один из способов узнать PID процесса - использовать команду `pgrep`, за которой следует имя процесса:
```
$ pgrep sleep
1201
```
>Идентификатор процесса также можно узнать с помощью команды `pidof` (например, `pidof sleep`).

Подобно `pgrep`, команда `pkill` завершает процесс на основе его имени:
```
$ pkill sleep
[1]+  Terminated              sleep 60
```
Чтобы завершить несколько экземпляров одного и того же процесса, можно использовать команду `killall`:
```
$ sleep 60 &
[1] 1246
$ sleep 70 &
[2] 1247
$ killall sleep
[1]-  Terminated              sleep 60
[2]+  Terminated              sleep 70
```
И `pkill`, и `killall` работают так же, как и `kill`, поскольку они отправляют сигнал завершения указанному процессу(ам). Если сигнал не предоставляется, отправляется значение по умолчанию `SIGTERM`. Однако `kill` принимает в качестве аргумента только задание или идентификатор процесса. 

Сигналы могут быть указаны как:
* Name:
```
$ kill -SIGHUP 1247
```
* Nummber:
```
$ kill -1 1247
```
* Option:
```
$ kill -s SIGHUP 1247
```
Чтобы `kill` работал аналогично `pkill` или `killall`(и сохранил себе команды, чтобы сначала узнать PID), мы можем использовать подстановку команд:
```
$ kill -1 $(pgrep sleep)
```
Как вы уже знаете, альтернативный синтаксис - `kill -1 'pgrep sleep'`.
>Чтобы получить исчерпывающий список всех сигналов завершения и их кодов, введите в терминал `kill -l`. Используйте `-KILL` (`-9` или `-s KILL`), чтобы завершить необходимый процесс при сбое любого другого сигнала.


## `top` и `ps`

Когда дело доходит до мониторинга процессов, есть два незаменимых инструмента - `top` и `ps`. В то время как первое производит вывод динамически, второе - статически. В любом случае, обе являются отличными утилитами для полного обзора всех процессов в системе.


### Взаимодействие с `top`

Чтобы вызвать `top`, просто введите `top`:
```
$ top

top - 11:10:29 up  2:21,  1 user,  load average: 0,11, 0,20, 0,14
Tasks:  73 total,   1 running,  72 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0,0 us,  0,3 sy,  0,0 ni, 99,7 id,  0,0 wa,  0,0 hi,  0,0 si,  0,0 st
KiB Mem :  1020332 total,   909492 free,    38796 used,    72044 buff/cache
KiB Swap:  1046524 total,  1046524 free,        0 used.   873264 avail Mem

   PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND
   436 carol     20   0   42696   3624   3060 R  0,7  0,4   0:00.30 top
     4 root      20   0       0      0      0 S  0,3  0,0   0:00.12 kworker/0:0
   399 root      20   0   95204   6748   5780 S  0,3  0,7   0:00.22 sshd
     1 root      20   0   56872   6596   5208 S  0,0  0,6   0:01.29 systemd
     2 root      20   0       0      0      0 S  0,0  0,0   0:00.00 kthreadd
     3 root      20   0       0      0      0 S  0,0  0,0   0:00.02 ksoftirqd/0
     5 root       0 -20       0      0      0 S  0,0  0,0   0:00.00 kworker/0:0H
     6 root      20   0       0      0      0 S  0,0  0,0   0:00.00 kworker/u2:0
     7 root      20   0       0      0      0 S  0,0  0,0   0:00.08 rcu_sched
     8 root      20   0       0      0      0 S  0,0  0,0   0:00.00 rcu_bh
     9 root      rt   0       0      0      0 S  0,0  0,0   0:00.00 migration/0
    10 root       0 -20       0      0      0 S  0,0  0,0   0:00.00 lru-add-drain
    (...)
```
`top` позволяет пользователю некоторое взаимодействие. По умолчанию вывод сортируется по проценту процессорного времени, используемого каждым процессом, в порядке убывания. Это поведение можно изменить, нажав следующие клавиши `top`:

* `M`  
Сортировать по использованию памяти.  
* `N`  
Сортировать по идентификатору процесса.  
* `Т`  
Сортировать по времени работы.  
* `P`  
Сортировать по проценту использования ЦП.

>Для переключения между порядком убывания и возрастания просто нажмите `R`.  

Другие интересные ключи для взаимодействия с `top`:
* `?` или `h`  
Помощь. 
* `k`  
Завершить процесс. `top` запросит `PID` процесса, который нужно убить, а также послать сигнал (по умолчанию `SIGTERM` или `15`). 
* `r`  
Изменить приоритет процесса (`renice`). `top` спросит у вас значение `nice`. Возможные значения находятся в диапазоне от -20 до 19, но только суперпользователь (`root`) может установить для него значение, отрицательное или меньшее, чем текущее. 
* `u`  
Список процессов определенного пользователя (по умолчанию отображаются процессы от всех пользователей). 
* `c`  
Показывать абсолютные пути программ и различать процессы пользовательского пространства и процессы пространства ядра (в квадратных скобках). 
* `V`  
Дерево/иерархия процессов. 
* `t` и `m`  
    Измените внешний вид показаний ЦП и памяти соответственно в четырехэтапном цикле: первые два нажатия показывают индикаторы выполнения, третье скрывает полосу, а четвертое возвращает ее. 
* `W`  
    Сохранить настройки конфигурации в `~/.toprc`.

>Более интересная и удобная версия `top` - это `htop`. Другая - возможно, более исчерпывающая альтернатива это `atop`. Если они еще не установлены в вашей системе, используйте диспетчер пакетов, чтобы установить их и попробовать.


### Объяснение вывода `top`
Вывод `top` разделен на две области: `область сводки` и `область задач`.

#### Область сводки `top`

*Область сводки* состоит из пяти верхних строк и дает нам следующую информацию:
* `top - 11:10:29 up 2:21, 1 user, load average: 0,11, 0,20, 0,14`
    * `current time`(в 24-часовом формате): `11:20:29` 
    * `uptime`(сколько времени система была запущена и работала): `up 2:21` 
    * количество пользователей, вошедших в систему, и средняя загрузка ЦП за последние 1, 5 и 15 минут соответственно: `load average: 0,11, 0,20, 0,14` 

* `Tasks: 73 total, 1 running, 72 sleeping, 0 stopped, 0 zombie` (информация о процессах) 
    * общее количество процессов в активном режиме: `73 total` 
    * (выполняемые): `1 running` 
    * спящие (ожидающие возобновления исполнения): `72 sleeping`
    * (по сигналу управления заданием): `0 stopped` 
    * зомби (те, которые завершили выполнение, но все еще ждут, пока их родительский процесс удалит их из таблицы процессов): `0 zombie` 

* `%Cpu(s): 0,0 us, 0,3 sy, 0,0 ni, 99,7 id, 0,0 wa, 0,0 hi, 0,0 si, 0,0 st` (процент процессорного времени потрачено на) 
    * пользовательские процессы: `0,0 us` 
    * система/процессы ядра: `0,4 sy`
    * процессы установлены на хорошее значение - чем лучше значение, тем ниже приоритет: `0,0 ni`
    * ничего - время простоя процессора: `99,7 id`
    * процессы, ожидающие операций ввода/вывода: `0,0 wa` 
    * процессы, обслуживающие аппаратные прерывания - периферийные устройства, отправляющие процессору сигналы, требующие внимания: `0,0 hi` 
    * процессы, обслуживающие программные прерывания: `0,0 si` 
    * процессы, обслуживающие задачи других виртуальных машин в виртуальной среде, следовательно, крадут время: `0,0 st` 

* `KiB Mem : 1020332 total, 909492 free, 38796 used, 72044 buff/cache` (информация о памяти в килобайтах) 
    * общий объем памяти: `1020332 total` 
    * неиспользуемая память: `909492 free` 
    * используемая память: `38796 used`  
    * память, которая буферизуется и кэшируется, чтобы избежать чрезмерного доступа к диску: `72044 buff/cache` 
    
Обратите внимание,`total` является суммой трех других значений - `free`, `used` и `buff/cache` - (в нашем случае примерно 1 ГБ). 

* `KiB Swap: 1046524 total, 1046524 free, 0 used. 873264 avail Mem` (информация подкачки в килобайтах) 
    * общий объем подкачки: `1046524 total` 
    * неиспользуемое пространство подкачки: `1046524 free` 
    * пространство подкачки используется: `0 used` 
    * объем памяти подкачки, который может быть выделен процессам без дополнительной подкачки: `873264 avail Mem`

#### Область задач `top`: поля и столбцы
