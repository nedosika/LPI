# 103.5 Урок 1

| Сертификат:   | LPIC-1                                      |
|:--------------|:--------------------------------------------|
| Версия:       | 5.0                                         |
| Тема:         | 103 GNU и Unix комманды                     |                           
| Цель:         | 103.5 Создание, мониторинг и завершение процессов |
| Урок:         | 1 из 2                                      |


# Введение

Каждый раз, когда мы вызываем команду, запускаются один или несколько процессов. Хорошо обученный системный администратор должен не только создавать процессы, но и уметь отслеживать их и отправлять им различные типы сигналов, если это необходимо. В этом уроке мы рассмотрим управление заданиями и то, как отслеживать процессы.


## Управление заданиями

Задания - это процессы, которые были запущены в интерактивном режиме через терминал, отправлены в фоновый режим и еще не завершены. Вы можете узнать об активных заданиях (и их статусе) в вашей системе Linux, выполнив `jobs`:
```
$ jobs
```
Приведенная выше команда `jobs` не дала никаких результатов, что означает в данный момент нет активных заданий. Давайте создадим наше первое задание, запустив команду, выполнение которой занимает некоторое время (команда `sleep` с параметром `60`), и - во время работы - нажмите `Ctrl` + `Z`:
```
$ sleep 60
^Z
[1]+  Stopped                 sleep 60
```
Выполнение команды было остановлено (или, скорее, приостановлено), а командная строка снова доступна. Теперь запустив комманду `jobs` во второй раз, вы обнаружите приостановленное задание:
```
$ jobs
[1]+  Stopped                 sleep 60
```
Поясним результат:

`[1]` 

Это число является идентификатором задания и может использоваться - перед ним стоит символ процента (`%`) - для изменения статуса задания с помощью утилит `fg`, `bg` и `kill` (как будет показано позже). 

`+` 

Знак «плюс» указывает на текущее задание по умолчанию (то есть последнее приостановленное или отправленное в фоновом режиме). Предыдущее задание помечается знаком минус (`-`). Любые другие предыдущие работы не помечаются. 

`Stopped` 

Описание статуса работы. 

`sleep 60` 

Сама команда или задание. 


С параметром `-l` задания будут дополнительно отображать идентификатор процесса (PID) прямо перед статусом:
```
$ jobs -l
[1]+  1114 Stopped                 sleep 60
```
Остальные возможные варианты работы: 

`-n` 

Перечисляет только процессы, которые изменили статус с момента последнего уведомления. Возможный статус: "Работает", "Остановлен", "Завершено" или "Готово". 

`-p` 

Перечисляет идентификаторы процессов. 

`-r` 

Перечисляет только запущенные задания. 

`-s` 

Список только остановленных (или приостановленных) заданий.

>Помните, что у задания есть как идентификатор `задания`, так и `идентификатор процесса` (PID).


## Спецификация заданий

Команде `jobs`, а также другим утилитам, таким как `fg`, `bg` и `kill` (которые вы увидите в следующем разделе), требуется спецификация задания (или `jobspec`), чтобы действовать в соответствии с конкретным заданием. Как мы только что видели, это может быть - и обычно это - идентификатор задания, которому предшествует `%`. Однако возможны и другие спецификации работы. Давайте посмотрим на них: 

`%n` 

Работа с идентификационным номером `n`:
```
$ jobs %1
[1]+  Stopped                 sleep 60
```

`%str`

Задание, командная строка которого начинается с `str`:
```
$ jobs %sl
[1]+  Stopped                 sleep 60
```

`%?str` 

Задание, командная строка которого содержит `str`:
```
$ jobs %?le
[1]+  Stopped                 sleep 60
```

`%+` или `%%`

Текущее задание (последнее было запущено в фоновом режиме или приостановлено на переднем плане):
```
$ jobs %+
[1]+  Stopped                 sleep 60
```
`%-` 

Предыдущее задание (то, которое было `%+` до задания по умолчанию, текущее):
```
$ jobs %-
[1]+  Stopped                 sleep 60
```
В нашем случае, поскольку есть только одно задание, оно одновременно и текущее, и предыдущее.


## Статус задания: приостановлено, передний план и фоновый режим

Когда задание находится в фоновом режиме или было приостановлено, мы можем сделать с ним любое из трех действий:
1. Вывести его на передний план с помощью `fg`:
```
$ fg %1
sleep 60
```
`fg` перемещает указанное задание на передний план и делает его текущим. Теперь мы можем дождаться его завершения, снова остановить его с помощью `Ctrl`+`Z` или завершить его с помощью `Ctrl`+`C`. 
2. Переместите его в фоновыйрежим с помощью `bg`:
```
$ bg %1
[1]+ sleep 60 &
```
Находясь в фоновом режиме, задание можно вернуть на передний план с помощью `fg` или завершить (см. ниже). Обратите внимание на амперсанд (`&`), означающий, что задание было отправлено в фоновый режим. Фактически, вы также можете использовать амперсанд для запуска процесса непосредственно в фоновом режиме:
```
$ sleep 100 &
[2] 970
```
Вместе с идентификатором нового задания (`[2]`) теперь мы также получаем его идентификатор процесса (`970`). Теперь оба задания работают в фоновом режиме:
```
$ jobs
[1]-  Running                 sleep 60 &
[2]+  Running                 sleep 100 &
```
Чуть позже завершается выполнение первого задания:
```
$ jobs
[1]-  Done                    sleep 60
[2]+  Running                 sleep 100 &
```
3. Завершите его сигналом `SIGTERM` с помощью `kill`:
```
$ kill %2
```
Чтобы убедиться, что задание было прервано, снова запустите `jobs`:
```
$ jobs
[2]+  Terminated                 sleep 100
```
>Если задание не указано, `fg` и `bg` будут действовать в соответствии с текущим заданием по умолчанию. `kill`, однако, всегда требует указания спецификации задания.


## Отключенные задания: `nohup`

Все задания, которые мы видели в предыдущих разделах, были привязаны к сеансу пользователя, который их вызвал. Это означает, что если сеанс завершается, задания исчезают. Однако можно отсоединять задания от сеансов и запускать их даже после закрытия сеанса. Это достигается с помощью команды `nohup` («без зависания»). Синтаксис следующий:
```
nohup COMMAND &
```
Помните, что `&` отправляет процесс в фоновый режим и освобождает терминал, на котором вы работаете. Давайте отключим фоновое задание `ping localhost` от текущего сеанса:
```
$ nohup ping localhost &
[1] 1251
$ nohup: ignoring input and appending output to 'nohup.out'
^C
```
Вывод показывает нам идентификатор задания (`[1]`) и PID (`1251`), за которым следует сообщение о файле `nohup.out`. Это файл по умолчанию, в котором будут сохранены `stdout` и `stderr`. Теперь мы можем нажать `Ctrl`+`C`, чтобы освободить командную строку, закрыть сеанс, запустить еще один как `root` и использовать `tail -f`, чтобы проверить, выполняется ли команда и выводятся ли данные в файл по умолчанию:
```
$ exit
logout
$ tail -f /home/carol/nohup.out
64 bytes from localhost (::1): icmp_seq=3 ttl=64 time=0.070 ms
64 bytes from localhost (::1): icmp_seq=4 ttl=64 time=0.068 ms
64 bytes from localhost (::1): icmp_seq=5 ttl=64 time=0.070 ms
^C
```
>Вместо использования `nohup.out` по умолчанию вы могли бы указать выходной файл по вашему выбору с помощью `nohup ping localhost > /path/to/your/file &`.

Если мы хотим завершить процесс, мы должны указать его PID:
```
# kill 1251
```


## Мониторинг процессов

