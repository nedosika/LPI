# 104.1 Урок 1

| Сертификат:   | LPIC-1                                      |
|:--------------|:--------------------------------------------|
| Версия:       | 5.0                                         |
| Тема:         | 103 Команды GNU и Unix                      |                           
| Цель:         | 103.4 Использование потоков, конвееров и перенаправлений |
| Урок:         | 2 из 2                                      |


# Введение

Один из аспектов философии Unix гласит, что каждая программа должна иметь определенную цель и не должна пытаться включать функции, выходящие за пределы ее области ответственности. Но простота не означает меньше результативности, потому что разные программы могут быть объединены в цепочку для получения комбинированного результата. Символ вертикальной черты `|`, также известный как *pipeline*, можно использовать для создания конвейера, соединяющего вывод программы непосредственно с вводом другой программы, тогда как *подстановка команд* позволяет сохранить вывод программы в переменную или использовать его прямо как аргумент для другой команды.


# Конвееры

В отличие от перенаправлений, с конвеерами данные передаются слева направо в командной строке, а целью является другой процесс, а не путь файловой системы, дескриптор файла или Here document. Символ конвеера `|` указывает оболочке запускать все отдельные команды одновременно и соединять вывод предыдущей команды с вводом следующей команды слева направо. Например, вместо использования перенаправления содержимое файла `/proc/cpuinfo`, отправляемого на стандартный вывод с помощью `cat`, можно передать по конвееру на стандартный ввод `wc` с помощью следующей команды:
```**
$ cat /proc/cpuinfo | wc
   208    1184    6096
**```

При отсутствии пути к файлу `wc` подсчитывает количество строк, слов и символов, которые он получает на своем стандартном вводе, как в примере. В составной команде может присутствовать множество конвееров. В следующем примере используются два конвеера:
```
$ cat /proc/cpuinfo | grep 'model name' | uniq
model name      : Intel(R) Xeon(R) CPU           X5355  @ 2.66GHz
```
Содержимое файла `/proc/cpuinfo`, созданного с помощью `cat /proc/cpuinfo`, было передано команде `grep 'model name'`, которая затем выбирает только строки, содержащие имя `model name`. Машина, на которой выполняется пример, имеет много процессоров, поэтому есть повторяющиеся строки с названием модели. Последний канал соединяет `grep 'model name'` с `uniq`, который отвечает за пропуск любой строки, равной предыдущей. Конвееры можно комбинировать с перенаправлениями в одной командной строке. Предыдущий пример можно переписать в более простой форме:
```
$ grep 'model name' </proc/cpuinfo | uniq
model name      : Intel(R) Xeon(R) CPU           X5355  @ 2.66GHz
```
Перенаправление ввода для `grep` не является строго необходимым, поскольку `grep` принимает путь к файлу в качестве аргумента, но в примере показано, как создавать такие комбинированные команды. 

Конвееры и перенаправления являются эксклюзивными, то есть один источник может быть сопоставлен только с одной целью. Тем не менее, можно перенаправить вывод в файл и по-прежнему видеть его на экране с помощью программы `tee`. Для этого первая программа отправляет свой вывод на стандартный ввод команды `tee`, а последнему предоставляется имя файла для хранения данных:
```
$ grep 'model name' </proc/cpuinfo | uniq | tee cpu_model.txt
model name      : Intel(R) Xeon(R) CPU           X5355  @ 2.66GHz
$ cat cpu_model.txt
model name      : Intel(R) Xeon(R) CPU           X5355  @ 2.66GHz
```
Вывод последней программы в цепочке, сгенерированный `uniq`, отображается и сохраняется в файле `cpu_model.txt`. Чтобы не перезаписывать содержимое предоставленного файла, а добавлять к нему данные, для команды `tee` необходимо указать параметр `-a`. 

Конвеер захватывает только стандартный вывод процесса. Допустим, вы запустили долгий процесс компиляции на экране и в то же время хотите сохранить как стандартный вывод, так и стандартную ошибку в файл для последующей проверки. Предполагая, что в вашем текущем каталоге нет *Makefile*, следующая команда выдаст ошибку:
```
$ make | tee log.txt
make: *** No targets specified and no makefile found.  
Stop.
```
Хотя сообщение об ошибке отображается на экране, оно не было зафиксировано программой `tee`, и файл *log.txt* был создан пустым. Чтобы конвеер смог захватить stderr, необходимо выполнить перенаправление:
```
$ make 2>&1 | tee log.txt
make: *** No targets specified and no makefile found.  
Stop.
$ cat log.txt
make: *** No targets specified and no makefile found.  
Stop.
```
В этом примере stderr команды `make` был перенаправлен на стандартный вывод, поэтому `tee` смог захватить его с помощью конвейера, отобразить на экране и сохранить в файле `log.txt`. В подобных случаях может быть полезно сохранить сообщения об ошибках для последующей проверки.


# Подстановка команд

Другой метод захвата вывода команды - это подстановка команды. Помещая команду внутри обратных кавычек, Bash заменяет ее стандартным выводом. В следующем примере показано, как использовать стандартный вывод программы в качестве аргумента для другой программы:
```
$ mkdir `date +%Y-%m-%d`
$ ls
2019-09-05
```
Вывод программы `date`, текущая дата в формате *год-месяц-день*, использовался в качестве аргумента для создания каталога с помощью *mkdir*. Идентичный результат получается при использовании `$()` вместо обратных кавычек:
```
$ rmdir 2019-09-05
$ mkdir $(date +%Y-%m-%d)
$ ls
2019-09-05
```
Тот же метод можно использовать для сохранения вывода команды в виде переменной:
```
$ OS=`uname -o`
$ echo $OS
GNU/Linux
```
Команда `uname -o` выводит общее имя текущей операционной системы, которое было сохранено в переменной сеанса `OS`. Назначение вывода команды переменной очень полезно в сценариях, что позволяет сохранять и оценивать данные различными способами. В зависимости от вывода, сгенерированного замененной командой, встроенная подстановка команд может быть неподходящей. Более сложный метод использования вывода программы в качестве аргумента другой программы использует промежуточное звено, называемое `xargs`. Программа `xargs` использует содержимое, которое она получает через стандартный ввод, для запуска заданной команды с содержимым в качестве аргумента. В следующем примере показано, как `xargs` выполняет программу `identify` с аргументами, предоставленными программой `find`:
```
$ find /usr/share/icons -name 'debian*' | xargs identify -format "%f: %wx%h\n"
debian-swirl.svg: 48x48
debian-swirl.png: 22x22
debian-swirl.png: 32x32
debian-swirl.png: 256x256
debian-swirl.png: 48x48
debian-swirl.png: 16x16
debian-swirl.png: 24x24
debian-swirl.svg: 48x48
```
Программа `identify` является частью `ImageMagick`, набора инструментов командной строки для проверки, преобразования и редактирования большинства типов файлов изображений. В этом примере `xargs` взял все пути, перечисленные с помощью `find`, и поместил их в качестве аргументов для `identify`, которая затем показывает информацию для каждого файла, отформатированного в соответствии с опцией `-format`. Файлы, найденные с помощью команды `find` в примере, являются изображениями, содержащими логотип распространения в файловой системе Debian. `-format` - это параметр для `identify`, а не для `xargs`. 

Опция `-n 1` требует, чтобы `xargs` запускал данную команду только с одним аргументом за раз. В случае примера вместо передачи всех путей, найденных с помощью `find`, в виде списка аргументов для `identify`, использование `xargs -n 1` приведет к выполнению команды `identify` для каждого пути отдельно. Использование `-n 2` вызовет `identify` с двумя путями в качестве аргументов, `-n 3` с тремя путями в качестве аргументов и так далее. Точно так же, когда `xargs` обрабатывает многострочное содержимое - как в случае с вводом, предоставленным `find` - можно использовать параметр `-L`, чтобы ограничить количество строк, которые будут использоваться в качестве аргументов при выполнении команды.

>Использование `xargs` с опцией `-n 1` или `-L 1` для обработки вывода, созданного с помощью `find`, может быть ненужным. Команда `find` имеет параметр `-exec` для запуска заданной команды для каждого элемента результатов поиска.

Если в путях есть пробелы, важно запустить `find` с параметром `-print0`. Эта опция указывает `find` использовать нулевой символ между каждой записью, чтобы список мог быть правильно проанализирован с помощью `xargs`(вывод был подавлен):
```
$ find . -name '*avi' -print0 -o -name '*mp4' -print0 -o -name '*mkv' -print0 | xargs -0 du | sort -n
```
Параметр `-0` указывает `xargs`, что в качестве разделителя следует использовать нулевой символ. Таким образом, пути к файлам, заданные командой `find`, будут правильно проанализированы, даже если в них есть пробелы или другие специальные символы. В предыдущем примере показано, как использовать команду `du`, чтобы узнать использование диска каждым найденным файлом, а затем отсортировать результаты по размеру. Вывод был скрыт для краткости. Обратите внимание, что для каждого критерия поиска необходимо указать параметр `-print0` для поиска. 

По умолчанию `xargs` помещает аргументы выполняемой команды последними. Чтобы изменить это поведение, следует использовать параметр `-I`:
```
$ find . -mindepth 2 -name '*avi' -print0 -o -name '*mp4' -print0 -o -name '*mkv' -print0 | xargs -0 -I PATH mv PATH ./
```
В последнем примере каждый файл, найденный с помощью `find`, перемещается в текущий каталог. Поскольку исходный путь (пути) должен быть сообщен `mv` перед целевым путем, для опции `-I` в `xargs` дается термин замены, который затем соответствующим образом помещается рядом с `mv`. Используя нулевой символ в качестве разделителя, нет необходимости заключать термин замены в кавычки.
