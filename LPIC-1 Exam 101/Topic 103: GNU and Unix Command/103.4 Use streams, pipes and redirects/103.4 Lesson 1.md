# 104.1 Урок 1

| Сертификат:   | LPIC-1                                      |
|:--------------|:--------------------------------------------|
| Версия:       | 5.0                                         |
| Тема:         | 103 Команды GNU и Unix                      |                           
| Цель:         | 103.4 Использование потоков, каналов и перенаправлений |
| Урок:         | 1 из 2                                      |


# Введение

Все компьютерные программы следуют одному и тому же общему принципу: данные, полученные из какого-либо источника, преобразуются для получения понятного результата. В контексте оболочки Linux источником данных может быть локальный файл, удаленный файл, устройство (например, клавиатура) и т. д. Вывод программы обычно отображается на экране, но также обычно используется для хранения выходных данных в локальной файловой системе, выводе его на удаленном устройстве, воспроизведении через аудиоколонки и т. д. 

Операционные системы, вдохновленные Unix, такие как Linux, предлагают большое разнообразие методов ввода/вывода. В частности, метод *файловых дескрипторов* позволяет динамически связывать целые числа с каналами данных, чтобы процесс мог ссылаться на них как на свои потоки данных ввода/вывода. 

Стандартные процессы Linux имеют три открытых канала связи по умолчанию: *стандартный входной* канал (чаще всего называемый просто `stdin`), *стандартный выходной* канал (`stdout`) и *стандартный канал ошибок* (`stderr`). Цифровые файловые дескрипторы, назначенные этим каналам: `0` для `stdin`, `1` для `stdout` и `2` для `stderr`. Каналы связи также доступны через специальные устройства `/dev/stdin`, `/dev/stdout` и `/dev/stderr`. 

Эти три стандартных канала связи позволяют программистам писать код, который считывает и записывает данные, не беспокоясь о том, с какого носителя они поступают или на которые направляются. Например, если программе требуется набор данных в качестве ввода, она может просто запросить данные из стандартного ввода, и все, что используется в качестве стандартного ввода, предоставит эти данные. Точно так же самый простой метод, который программа может использовать для отображения своего вывода, - это записать его в стандартный вывод. В стандартном сеансе оболочки клавиатура определяется как `stdin`, а экран монитора определяется как `stdout` и `stderr`. 

Оболочка Bash имеет возможность переназначать каналы связи при загрузке программы. Это позволяет, например, переопределить экран как стандартный вывод и использовать файл в локальной файловой системе как стандартный вывод.


# Перенаправления

Перераспределение файлового дескриптора канала в оболочке называется перенаправлением. Перенаправление определяется специальным символом в командной строке. Например, чтобы перенаправить стандартный вывод процесса в файл, в конце команды помещается символ `>`, за которым следует путь к файлу, который получит перенаправленный вывод:
```
$ cat /proc/cpuinfo >/tmp/cpu.txt
```
По умолчанию перенаправляется только контент, поступающий на стандартный вывод. Это происходит потому, что числовое значение дескриптора файла должно быть указано непосредственно перед символом «больше», а если он не указан, Bash перенаправляет стандартный вывод. Следовательно, использование `>` эквивалентно использованию `1>` (значение дескриптора файла `stdout` равно `1`). 

Вместо этого для захвата содержимого `stderr` следует использовать перенаправление `2>`. Большинство программ командной строки отправляют отладочную информацию и сообщения об ошибках в стандартный канал ошибок. Например, можно записать сообщение об ошибке, вызванное попыткой прочитать несуществующий файл:
```
$ cat /proc/cpu_info 2>/tmp/error.txt
$ cat /tmp/error.txt
cat: /proc/cpu_info: No such file or directory
```
И `stdout`, и `stderr` перенаправляются на одну и ту же цель с помощью `&>` или `>&`. Важно не ставить пробелы рядом с амперсандом, иначе Bash воспользуется им как инструкцией для запуска процесса в фоновом режиме, а не для выполнения перенаправления. 

Целью должен быть путь к файлу с возможностью записи, например `/tmp/cpu.txt`, или дескриптор файла с возможностью записи. Целевой дескриптор файла представлен амперсандом, за которым следует числовое значение дескриптора файла. Например, `1>&2` перенаправляет `stdout` на `stderr`. Чтобы сделать наоборот, вместо этого следует использовать stderr to stdout, `2>&1`. 

Хотя это не очень полезно, учитывая, что существует более короткий способ выполнить ту же задачу, можно перенаправить `stderr` на `stdout`, а затем перенаправить его в файл. Например, перенаправление для записи и `stderr`, и `stdout` в файл с именем `log.txt` может быть записано как `>log.txt 2>&1`. Однако основной причиной перенаправления `stderr` на `stdout` являетсяразбор сообщений отладки и ошибок. Можно перенаправить стандартный вывод программы на стандартный ввод другой программы, но невозможно напрямую перенаправить стандартную ошибку на стандартный ввод другой программы. Таким образом, сообщения программы, отправленные на `stderr`, сначала необходимо перенаправить на `stdout`, чтобы их могла прочитать `stdin` другой программы. 

Чтобы просто отказаться от вывода команды, ее содержимое можно перенаправить в специальный файл `/dev/null`. Например, `>log.txt 2>/dev/null` сохраняет содержимое `stdout` в файле `log.txt` и отбрасывает `stderr`. Файл `/dev/null` доступен для записи любому пользователю, но никакие данные из него не могут быть восстановлены, так как нигде не хранятся. 

Сообщение об ошибке отображается, если указанный целевой объект недоступен для записи (если путь указывает на каталог или файл, доступный только для чтения), и в целевой объект не вносятся никакие изменения. Однако перенаправление вывода перезаписывает существующую цель с возможностью записи без какого-либо подтверждения. Файлы перезаписываются перенаправлением вывода, если не включена опция Bash - `noclobber`, что можно сделать для текущего сеанса с помощью команды `set -o noclobber` или `set -C`:
```
$ set -o noclobber
$ cat /proc/cpu_info 2>/tmp/error.txt
-bash: /tmp/error.txt: cannot overwrite existing file
```
Чтобы отключить параметр `noclobber` для текущего сеанса, запустите `set +o noclobber` или `set +C`. Чтобы сделать параметр `noclobber` постоянным, он должен быть включен в профиль пользователя Bash или в общесистемный профиль. 

Даже при включенной опции `noclobber` можно добавлять перенаправленные данные к существующему контенту. Это достигается с помощью перенаправления, написанного двумя символами "больше" - `>>`:
```
$ cat /proc/cpu_info 2>>/tmp/error.txt
$ cat /tmp/error.txt
cat: /proc/cpu_info: No such file or directory
cat: /proc/cpu_info: No such file or directory
```
В предыдущем примере новое сообщение об ошибке было добавлено к существующему в файле `/tmp/error.txt`. Если файл еще не существует, он будет создан с новыми данными. 

Источник данных стандартного ввода процесса также может быть переназначен. Символ `<` используется для перенаправления содержимого файла на стандартный ввод процесса. В этом случае данные передаются справа налево: предполагается, что переназначенный дескриптор равен 0 слева от символа «меньше», а источник данных (путь к файлу) должен находиться справа от символа «меньше». Команда `uniq`, как и большинство утилит командной строки для обработки текста, по умолчанию принимает данные, отправленные на стандартный ввод:
```
$ uniq -c </tmp/error.txt
      2 cat: /proc/cpu_info: No such file or directory
```
Параметр `-c` заставляет `uniq` отображать, сколько раз повторяющаяся строка появляется в тексте. Поскольку числовое значение перенаправленного дескриптора файла было подавлено, пример команды эквивалентен `uniq -c 0< /tmp/error.txt`. Использование файлового дескриптора, отличного от `0`, в перенаправлении ввода имеет смысл только в определенных контекстах, потому что программа может запрашивать данные в файловых дескрипторах `3`, `4` и т. д. Действительно, программы могут использовать любое целое число больше `2` как новое файловые дескрипторы ввода/вывода данных. Например, следующий код C считывает данные из файлового дескриптора `3` и просто реплицирует их в файловый дескриптор `4`:
>Программа должна правильно обрабатывать такие файловые дескрипторы, иначе она может попытаться выполнить недопустимую операцию чтения или записи и выйдет из строя.
```
#include <stdio.h>

int main(int argc, char **argv){
  FILE *fd_3, *fd_4;
  // Open file descriptor 3
  fd_3 = fdopen(3, "r");
  // Open file descriptor 4
  fd_4 = fdopen(4, "w");
  // Read from file descriptor 3
  char buf[32];
  while ( fgets(buf, 32, fd_3) != NULL ){
    // Write to file descriptor 4
    fprintf(fd_4, "%s", buf);
  }
  // Close both file descriptors
  fclose(fd_3);
  fclose(fd_4);
}
```
Чтобы проверить это, сохраните образец кода как `fd.c` и скомпилируйте его с помощью `gcc -o fd fd.c`. Этой программе нужны файловые дескрипторы `3` и `4`, чтобы она могла читать и писать в них. Например, ранее созданный файл `/tmp/error.txt` может использоваться в качестве источника для файлового дескриптора `3`, а файловый дескриптор `4` может быть перенаправлен на стандартный вывод:
```
$ ./fd 3</tmp/error.txt 4>&1
cat: /proc/cpu_info: No such file or directory
cat: /proc/cpu_info: No such file or directory
```
С точки зрения программиста, использование файловых дескрипторов позволяет избежать анализа параметров и путей файловой системы. Один и тот же файловый дескриптор может использоваться даже для ввода и вывода. В этом случае дескриптор файла определяется в командной строке символом "меньше" и "больше", как `3<> /tmp/error.txt`.


# Here Document и Here String

Другой способ перенаправления ввода - это методы *Here Document* и *Here String*. Перенаправление Here Document позволяет вводить многострочный текст, который будет использоваться в качестве перенаправленного содержимого. Два символа меньше `<<` указывают на перенаправление Here Document:
```
$ wc -c <<EOF
> How many characters
> in this Here document?
> EOF
43
```
Справа от двух символов `<<` находится знак конца файла `EOF`. Режим вставки завершится, как только будет введена строка, содержащая только знак конца файла. В качестве знака конца файла можно использовать любой другой знак, но важно не ставить пробелы между символом «меньше» и EOF. В приведенном выше примере две строки текста были отправлены на стандартный ввод команды `wc -c`, которая отображает количество символов. Как и в случае перенаправления ввода для файлов, предполагается, что стандартный ввод (дескриптор файла `0`), если дескриптор перенаправленного файла подавлен. 

Here String метод очень похож на Here document метод , но только для одной строки:
```
$ wc -c <<<"How many characters in this Here string?"
41
```
В этом примере строка справа от трех знаков меньше отправляется на стандартный ввод команды `wc -c`, которая подсчитывает количество символов. Строки, содержащие пробелы, должны быть внутри кавычек, иначе только первое слово будет использоваться в качестве Here string, а остальные будут переданы в качестве аргументов команде.


# Упражнения для закрепления

1. Помимо текстовых файлов, команда `cat` также может работать с двоичными данными, например отправлять содержимое блочного устройства в файл. Как с помощью перенаправления `cat` отправить содержимое устройства `/dev/sdc` в файл `sdc.img` в текущем каталоге? 
2. Как называется стандартный канал, перенаправляемый командой `date 1> now.txt`?
3. После попытки перезаписать файл с помощью перенаправления пользователь получает сообщение об ошибке, информирующее о том, что опция `noclobber` включена. Как можно отключить опцию `noclobber` для текущего сеанса? 
4. Что будет в результате выполнения команды `cat <<.> /dev/stdout`?


# Упражнения на размышления

1. Команда `cat /proc/cpu_info` отображает сообщение об ошибке, поскольку `/proc/cpu_info` не существует. Команда `cat /proc/cpu_info 2>1` перенаправляет сообщение об ошибке куда? 
2. Будет ли по-прежнему возможно отказаться от содержимого, отправленного в `/dev/null`, если для текущего сеанса оболочки включена опция `noclobber`? 
3. Как можно перенаправить содержимое переменной `$USER` на стандартный ввод команды `sha1sum` без использования `echo`? 
4. Ядро Linux хранит символические ссылки в `/proc/PID/fd/` на каждый файл, открытый процессом, где `PID` - это идентификационный номер соответствующего процесса. Как может системный администратор использовать этот каталог для проверки расположения файлов журнала, открытых `nginx`, если его PID равен `1234`? 
5. Можно выполнять арифметические вычисления, используя только встроенные команды оболочки, но для вычислений с плавающей запятой требуются специальные программы, такие как `bc` (базовый калькулятор). С помощью `bc` можно даже указать количество десятичных знаков с помощью шкалы параметров. Однако `bc` принимает операции только через стандартный ввод, обычно вводимый в интерактивном режиме. Используя Here string, как можно операцию с плавающей запятой `scale=6; 1/3` отправить на стандартный ввод `bc`?


# Резюме

В этом уроке рассматриваются методы запуска программы, перенаправляющей ее стандартные потокивывода. Процессы Linux используют эти стандартные потоки в качестве общих файловых дескрипторов для чтения и записи данных, что позволяет произвольно преобразовывать их в файлы или устройства. Урок состоит из следующих этапов: 
* Что такое файловые дескрипторы и какую роль они играют в Linux. 
* Стандартные потоки вывода каждого процесса: *stdin, stdout* и *stderr*. 
* Как правильно выполнить команду, используя перенаправление данных, как для потоков ввода, так и для потоков вывода. 
* Как использовать *Here Documents* и *Here Strings* при перенаправлении потока ввода. 

Были рассмотрены следующие команды и процедуры: 
* Операторы перенаправления: `>`, `<`, `>>`, `<<`, `<<<`. 
* Команды `cat`, `set`, `uniq` и `wc`.


# Ответы на упражнения для закрепления

1. Помимо текстовых файлов, команда `cat` также может работать с двоичными данными, например отправлять содержимое блочного устройства в файл. Как с помощью перенаправления `cat` отправить содержимое устройства `/dev/sdc` в файл `sdc.img` в текущем каталоге? 
```
$ cat /dev/sdc > sdc.img
```

2. Как называется стандартный канал, перенаправляемый командой `date 1> now.txt`?

Стандартный вывод или стандартный вывод

3. После попытки перезаписать файл с помощью перенаправления пользователь получает сообщение об ошибке, информирующее о том, что опция `noclobber` включена. Как можно отключить опцию `noclobber` для текущего сеанса? 

`set +C` или `set +o noclobber`

4. Что будет в результате выполнения команды `cat <<.> /dev/stdout`?

Bash войдет в режим ввода Heredoc, а затем выйдет, когда в строке появится точка. Введенный текст будет перенаправлен на стандартный вывод (выводится на экран).

# Ответы на упражнения для размышления

1. Команда `cat /proc/cpu_info` отображает сообщение об ошибке, поскольку `/proc/cpu_info` не существует. Команда `cat /proc/cpu_info 2>1` перенаправляет сообщение об ошибке куда? 

В файл с именем `1` в текущем каталоге.

2. Будет ли по-прежнему возможно отказаться от содержимого, отправленного в `/dev/null`, если для текущего сеанса оболочки включена опция `noclobber`? 

Да. `/dev/null` - это специальный файл, на который noclobber не влияет.

3. Как можно перенаправить содержимое переменной `$USER` на стандартный ввод команды `sha1sum` без использования `echo`? 
```
$ sha1sum <<<$USER
```

4. Ядро Linux хранит символические ссылки в `/proc/PID/fd/` на каждый файл, открытый процессом, где `PID` - это идентификационный номер соответствующего процесса. Как может системный администратор использовать этот каталог для проверки расположения файлов журнала, открытых `nginx`, если его PID равен `1234`? 

Выполнив команду `ls -l /proc/1234/fd`, которая отобразит цели каждой символической ссылки в каталоге.

5. Можно выполнять арифметические вычисления, используя только встроенные команды оболочки, но для вычислений с плавающей запятой требуются специальные программы, такие как `bc` (базовый калькулятор). С помощью `bc` можно даже указать количество десятичных знаков с помощью шкалы параметров. Однако `bc` принимает операции только через стандартный ввод, обычно вводимый в интерактивном режиме. Используя Here string, как можно операцию с плавающей запятой `scale=6; 1/3` отправить на стандартный ввод `bc`?
```
$ bc <<<"scale=6; 1/3"
```
