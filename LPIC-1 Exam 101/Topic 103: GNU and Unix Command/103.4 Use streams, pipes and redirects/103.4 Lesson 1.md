# 104.1 Урок 1

| Сертификат:   | LPIC-1                                      |
|:--------------|:--------------------------------------------|
| Версия:       | 5.0                                         |
| Тема:         | 103 Команды GNU и Unix                      |                           
| Цель:         | 103.4 Использование потоков, каналов и перенаправлений |
| Урок:         | 1 из 2                                      |


# Введение

Все компьютерные программы следуют одному и тому же общему принципу: данные, полученные из какого-либо источника, преобразуются для получения понятного результата. В контексте оболочки Linux источником данных может быть локальный файл, удаленный файл, устройство (например, клавиатура) и т. д. Вывод программы обычно отображается на экране, но также обычно используется для хранения выходных данных в локальной файловой системе, выводе его на удаленном устройстве, воспроизведении через аудиоколонки и т. д. 

Операционные системы, вдохновленные Unix, такие как Linux, предлагают большое разнообразие методов ввода/вывода. В частности, метод *файловых дескрипторов* позволяет динамически связывать целые числа с каналами данных, чтобы процесс мог ссылаться на них как на свои потоки данных ввода/вывода. 

Стандартные процессы Linux имеют три открытых канала связи по умолчанию: *стандартный входной* канал (чаще всего называемый просто `stdin`), *стандартный выходной* канал (`stdout`) и *стандартный канал ошибок* (`stderr`). Цифровые файловые дескрипторы, назначенные этим каналам: `0` для `stdin`, `1` для `stdout` и `2` для `stderr`. Каналы связи также доступны через специальные устройства `/dev/stdin`, `/dev/stdout` и `/dev/stderr`. 

Эти три стандартных канала связи позволяют программистам писать код, который считывает и записывает данные, не беспокоясь о том, с какого носителя они поступают или на которые направляются. Например, если программе требуется набор данных в качестве ввода, она может просто запросить данные из стандартного ввода, и все, что используется в качестве стандартного ввода, предоставит эти данные. Точно так же самый простой метод, который программа может использовать для отображения своего вывода, - это записать его в стандартный вывод. В стандартном сеансе оболочки клавиатура определяется как `stdin`, а экран монитора определяется как `stdout` и `stderr`. 

Оболочка Bash имеет возможность переназначать каналы связи при загрузке программы. Это позволяет, например, переопределить экран как стандартный вывод и использовать файл в локальной файловой системе как стандартный вывод.


# Перенаправления

Перераспределение файлового дескриптора канала в оболочке называется перенаправлением. Перенаправление определяется специальным символом в командной строке. Например, чтобы перенаправить стандартный вывод процесса в файл, в конце команды помещается символ `>`, за которым следует путь к файлу, который получит перенаправленный вывод:
```
$ cat /proc/cpuinfo >/tmp/cpu.txt
```
По умолчанию перенаправляется только контент, поступающий на стандартный вывод. Это происходит потому, что числовое значение дескриптора файла должно быть указано непосредственно перед символом «больше», а если он не указан, Bash перенаправляет стандартный вывод. Следовательно, использование `>` эквивалентно использованию `1>` (значение дескриптора файла `stdout` равно `1`). 

Вместо этого для захвата содержимого `stderr` следует использовать перенаправление `2>`. Большинство программ командной строки отправляют отладочную информацию и сообщения об ошибках в стандартный канал ошибок. Например, можно записать сообщение об ошибке, вызванное попыткой прочитать несуществующий файл:
```
$ cat /proc/cpu_info 2>/tmp/error.txt
$ cat /tmp/error.txt
cat: /proc/cpu_info: No such file or directory
```
И `stdout`, и `stderr` перенаправляются на одну и ту же цель с помощью `&>` или `>&`. Важно не ставить пробелы рядом с амперсандом, иначе Bash воспользуется им как инструкцией для запуска процесса в фоновом режиме, а не для выполнения перенаправления. 

Целью должен быть путь к файлу с возможностью записи, например `/tmp/cpu.txt`, или дескриптор файла с возможностью записи. Целевой дескриптор файла представлен амперсандом, за которым следует числовое значение дескриптора файла. Например, `1>&2` перенаправляет `stdout` на `stderr`. Чтобы сделать наоборот, вместо этого следует использовать stderr to stdout, `2>&1`. 

Хотя это не очень полезно, учитывая, что существует более короткий способ выполнить ту же задачу, можно перенаправить `stderr` на `stdout`, а затем перенаправить его в файл. Например, перенаправление для записи и `stderr`, и `stdout` в файл с именем `log.txt` может быть записано как `>log.txt 2>&1`. Однако основной причиной перенаправления `stderr` на `stdout` являетсяразбор сообщений отладки и ошибок. Можно перенаправить стандартный вывод программы на стандартный ввод другой программы, но невозможно напрямую перенаправить стандартную ошибку на стандартный ввод другой программы. Таким образом, сообщения программы, отправленные на `stderr`, сначала необходимо перенаправить на `stdout`, чтобы их могла прочитать `stdin` другой программы. 

Чтобы просто отказаться от вывода команды, ее содержимое можно перенаправить в специальный файл `/dev/null`. Например, `>log.txt 2>/dev/null` сохраняет содержимое `stdout` в файле `log.txt` и отбрасывает `stderr`. Файл `/dev/null` доступен для записи любому пользователю, но никакие данные из него не могут быть восстановлены, так как нигде не хранятся. 

Сообщение об ошибке отображается, если указанный целевой объект недоступен для записи (если путь указывает на каталог или файл, доступный только для чтения), и в целевой объект не вносятся никакие изменения. Однако перенаправление вывода перезаписывает существующую цель с возможностью записи без какого-либо подтверждения. Файлы перезаписываются перенаправлением вывода, если не включена опция Bash - `noclobber`, что можно сделать для текущего сеанса с помощью команды `set -o noclobber` или `set -C`:
```
$ set -o noclobber
$ cat /proc/cpu_info 2>/tmp/error.txt
-bash: /tmp/error.txt: cannot overwrite existing file
```
Чтобы отключить параметр `noclobber` для текущего сеанса, запустите `set +o noclobber` или `set +C`. Чтобы сделать параметр `noclobber` постоянным, он должен быть включен в профиль пользователя Bash или в общесистемный профиль. 

Даже при включенной опции `noclobber` можно добавлять перенаправленные данные к существующему контенту. Это достигается с помощью перенаправления, написанного двумя символами "больше" - `>>`:
```
$ cat /proc/cpu_info 2>>/tmp/error.txt
$ cat /tmp/error.txt
cat: /proc/cpu_info: No such file or directory
cat: /proc/cpu_info: No such file or directory
```
