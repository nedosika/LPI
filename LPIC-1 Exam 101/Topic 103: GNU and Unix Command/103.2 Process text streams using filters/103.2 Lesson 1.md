# 103.2 Урок 1

| **Сертификат:** | LPIC-1                                    |
|:----------------|:------------------------------------------|
| **Версия:**     | 5.0                                       |
| **Тема:**       | 103 Команды GNU и Unix                    |
| **Цель:**       | 103.2 Обработка текстовых потоков с помощью фильтров |
| **Урок:**       | 1 из 1                                    |


## Введение

Работа с текстом - важная часть работы каждого системного администратора. Дуг Макилрой, член первоначальной группы разработчиков Unix, резюмировал философию Unix и сказал (среди прочего): «Пишите программы для обработки текстовых потоков, потому что это универсальный интерфейс». Linux вдохновлен операционной системой Unix и твердо придерживается ее философии, поэтому администратор должен ожидать наличия множества инструментов для обработки текста в дистрибутиве Linux.


## Краткий обзор перенаправлений и каналов

Также из философии Unix: 
* Пишите программы, которые делают одно дело и делают это хорошо. 
* Напишите программы для совместной работы. 

Один из основных способов заставить программы работать вместе - это *конвейеры* и *перенаправления*. Практически все ваши программы обработки текста будут получать текст из стандартного ввода (*stdin*), выводить его на стандартный вывод (*stdout*) и отправлять возможные ошибки на стандартный вывод ошибок (*stderr*). Если вы не укажете иное, стандартным вводом будет то, что вы вводите на клавиатуре (программа прочитает его после того, как вы нажмете клавишу Enter). Точно так же стандартный вывод и ошибки будут отображаться на экране вашего терминала. Посмотрим, как это работает. 

В терминале введите `cat` и нажмите клавишу Enter. Затем введите произвольный текст.

```console
$ cat
This is a test
This is a test
Hey!
Hey!
It is repeating everything I type!
It is repeating everything I type!
(I will hit ctrl+c so I will stop this nonsense)
(I will hit ctrl+c so I will stop this nonsense)
^C
```

Для получения дополнительной информации о команде `cat` (термин происходит от «конкатенация») обратитесь к страницам руководства.

>Если вы работаете с действительно простой установкой сервера Linux, некоторые команды, такие как `info` и `less`, могут быть недоступны. В этом случае установите эти инструменты, используя соответствующую процедуру в вашей системе, как описано в соответствующих уроках.

Как показано выше, если вы не укажете, откуда `cat` должен читать, он будет читать со стандартного ввода (независимо от того, что вы вводите) и выводить все, что он читает, в окно вашего терминала (его стандартный вывод). 

Теперь попробуйте следующее:

```console
$ cat > mytextfile
This is a test
I hope cat is storing this to mytextfile as I redirected the output
I will hit ctrl+c now and check this
^C

$ cat mytextfile
This is a test
I hope cat is storing this to mytextfile as I redirected the output
I will hit ctrl+c now and check this
```

Символ `>` (больше) указывает `cat` направлять вывод в файл `mytextfile`, а не в стандартный вывод. А теперь попробуйте это:

```console
$ cat mytextfile > mynewtextfile
$ cat mynewtextfile
This is a test
I hope cat is storing this to mytextfile as I redirected the output
I will hit ctrl+c now and check this
```

Это имеет эффект копирования `mytextfile` в `mynewtextfile`. Фактически вы можете проверить, что эти два файла имеют одинаковое содержимое, выполнив сравнение:

```console
$ diff mynewtextfile mytextfile
```

Поскольку нет вывода, файлы равны. Теперь попробуйте добавить оператор перенаправления (`>>`):

```console
$ echo 'This is my new line' >> mynewtextfile
$ diff mynewtextfile mytextfile
4d3
< This is my new line
```

До сих пор мы использовали перенаправления для создания файлов и управления ими. Мы также можем использовать каналы (обозначенные символом `|`) для перенаправления вывода одной программы в другую программу. Найдем строки, в которых встречается слово «это»:

```console
$ cat mytextfile | grep this
I hope cat is storing this to mytextfile as I redirected the output
I will hit ctrl+c now and check this

$ cat mytextfile | grep -i this
This is a test
I hope cat is storing this to mytextfile as I redirected the output
I will hit ctrl+c now and check this
```

Теперь мы передали вывод `cat` другой команде: `grep`. Обратите внимание, когда мы игнорируем регистр (используя параметр `-i`), в результате мы получаем дополнительную строку.


## Обработка текстовых потоков

### Чтение сжатого файла

Мы создадим файл `ftu.txt`, содержащий список следующих команд:

```console
bzcat
cat
cut
head
less
md5sum
nl
od
paste
sed
sha256sum
sha512sum
sort
split
tail
tr
uniq
wc
xzcat
zcat
```

Теперь мы воспользуемся командой `grep`, чтобы распечатать все строки, содержащие строку `cat`:

```console
$ cat ftu.txt | grep cat
bzcat
cat
xzcat
zcat
```

Другой способ получить эту информацию - просто использовать команду `grep` для прямой фильтрации текста без необходимости использовать другое приложение для отправки текстового потока на `stdout`.

```console
$ grep cat ftu.txt
bzcat
cat
xzcat
zcat
```

>Помните, что есть много способов выполнить одну и ту же задачу в Linux.

Существуют и другие команды, которые обрабатывают сжатые файлы (`bzcat` для сжатых файлов `bzip`, `xzcat` для сжатых файлов `xz` и `zcat` для сжатых файлов `gzip`), и каждая из них используется для просмотра содержимого сжатого файла на основе используемого алгоритма сжатия. 

Убедитесь, что только что созданный файл `ftu.txt` является единственным в каталоге, затем создайте версию файла, сжатую с помощью `gzip`:

```console
$ ls ftu*
ftu.txt

$ gzip ftu.txt
$ ls ftu*
ftu.txt.gz
```

Затем используйте команду `zcat`, чтобы просмотреть содержимое сжатого файла, сжатого `gzip`:

```console
$ zcat ftu.txt.gz
bzcat
cat
cut
head
less
md5sum
nl
od
paste
sed
sha256sum
sha512sum
sort
split
tail
tr
uniq
wc
xzcat
zcat
```

Обратите внимание, что `gzip` сжимает `ftu.txt` в `ftu.txt.gz` и удаляет исходный файл. По умолчанию вывод команды `gzip` не отображается. Однако, если вы действительно хотите, чтобы `gzip` сообщал вам, что он делает, используйте параметр `-v` для «подробного» вывода.


### Просмотр файла c пагинацией

Вы знаете, что `cat` объединяет файл со стандартным выводом (когда файл предоставляется после команды). В файле `/var/log/syslog` ваша система Linux хранит все важное, что происходит в вашей системе. Использование команды `sudo` для повышения привилегий, чтобы иметь возможность читать файл `/var/log/syslog`:

```console
$ sudo cat /var/log/syslog
```

…вы увидите, как очень быстро прокручиваются сообщения в окне вашего терминала. Вы можете передавать вывод в программу меньше, чтобы результаты были разбиты на страницы. Используя `less`, вы можете использовать клавиши со стрелками для навигации по выходным данным, а также использовать `vi`-подобные команды для навигации и поиска по тексту. 

Однако вместо того, чтобы передавать команду `cat` в программу разбиения на страницы, более прагматично просто использовать программу разбиения на страницы напрямую:

```console
$ sudo less /var/log/syslog
... (output omitted for clarity)
```


### Получение части текстового файла

Если необходимо проверить только начало или конец файла, доступны другие методы. Команда `head` используется для чтения первых десяти строк файла по умолчанию, а `tail` команды используется для чтения последних десяти строк файла по умолчанию. А теперь попробуйте:

```console
$ sudo head /var/log/syslog
Nov 12 08:04:30 hypatia rsyslogd: [origin software="rsyslogd" swVersion="8.1910.0" x-pid="811" x-info="https://www.rsyslog.com"] rsyslogd was HUPed
Nov 12 08:04:30 hypatia systemd[1]: logrotate.service: Succeeded.
Nov 12 08:04:30 hypatia systemd[1]: Started Rotate log files.
Nov 12 08:04:30 hypatia vdr: [928] video directory scanner thread started (pid=882, tid=928, prio=low)
Nov 12 08:04:30 hypatia vdr: [882] registered source parameters for 'A - ATSC'
Nov 12 08:04:30 hypatia vdr: [882] registered source parameters for 'C - DVB-C'
Nov 12 08:04:30 hypatia vdr: [882] registered source parameters for 'S - DVB-S'
Nov 12 08:04:30 hypatia vdr: [882] registered source parameters for 'T - DVB-T'
Nov 12 08:04:30 hypatia vdr[882]: vdr: no primary device found - using first device!
Nov 12 08:04:30 hypatia vdr: [929] epg data reader thread started (pid=882, tid=929, prio=high)
$ sudo tail /var/log/syslog
Nov 13 10:24:45 hypatia kernel: [ 8001.679238] mce: CPU7: Core temperature/speed normal
Nov 13 10:24:46 hypatia dbus-daemon[2023]: [session uid=1000 pid=2023] Activating via systemd: service name='org.freedesktop.Tracker1.Miner.Extract' unit='tracker-extract.service' requested by ':1.73' (uid=1000 pid=2425 comm="/usr/lib/tracker/tracker-miner-fs ")
Nov 13 10:24:46 hypatia systemd[2004]: Starting Tracker metadata extractor...
Nov 13 10:24:47 hypatia dbus-daemon[2023]: [session uid=1000 pid=2023] Successfully activated service 'org.freedesktop.Tracker1.Miner.Extract'
Nov 13 10:24:47 hypatia systemd[2004]: Started Tracker metadata extractor.
Nov 13 10:24:54 hypatia kernel: [ 8010.462227] mce: CPU0: Core temperature above threshold, cpu clock throttled (total events = 502907)
Nov 13 10:24:54 hypatia kernel: [ 8010.462228] mce: CPU4: Core temperature above threshold, cpu clock throttled (total events = 502911)
Nov 13 10:24:54 hypatia kernel: [ 8010.469221] mce: CPU0: Core temperature/speed normal
Nov 13 10:24:54 hypatia kernel: [ 8010.469222] mce: CPU4: Core temperature/speed normal
Nov 13 10:25:03 hypatia systemd[2004]: tracker-extract.service: Succeeded.
```

Чтобы проиллюстрировать количество отображаемых строк, мы можем передать вывод команды `head` по конвейеру команде `nl`, которая отобразит количество строк текста, переданных в команду:

```console
$ sudo head /var/log/syslog | nl
1	Nov 12 08:04:30 hypatia rsyslogd: [origin software="rsyslogd" swVersion="8.1910.0" x-pid="811" x-info="https://www.rsyslog.com"] rsyslogd was HUPed
2	Nov 12 08:04:30 hypatia systemd[1]: logrotate.service: Succeeded.
3	Nov 12 08:04:30 hypatia systemd[1]: Started Rotate log files.
4	Nov 12 08:04:30 hypatia vdr: [928] video directory scanner thread started (pid=882, tid=928, prio=low)
5	Nov 12 08:04:30 hypatia vdr: [882] registered source parameters for 'A - ATSC'
6	Nov 12 08:04:30 hypatia vdr: [882] registered source parameters for 'C - DVB-C'
7	Nov 12 08:04:30 hypatia vdr: [882] registered source parameters for 'S - DVB-S'
8	Nov 12 08:04:30 hypatia vdr: [882] registered source parameters for 'T - DVB-T'
9	Nov 12 08:04:30 hypatia vdr[882]: vdr: no primary device found - using first device!
10	Nov 12 08:04:30 hypatia vdr: [929] epg data reader thread started (pid=882, tid=929, prio=high)
```

И мы можем сделать то же самое, передав вывод команды `tail` в команду `wc`, которая по умолчанию будет подсчитывать количество слов в документе, и используя переключатель `-l`, чтобы распечатать количество строк текста, которое команда прочитала:

```console
$ sudo tail /var/log/syslog | wc -l
10
```

Если администратору нужно просмотреть больше (или меньше) начала или конца файла, можно использовать параметр `-n` для ограничения вывода команд:

```console
$ sudo tail -n 5 /var/log/syslog
Nov 13 10:37:24 hypatia systemd[2004]: tracker-extract.service: Succeeded.
Nov 13 10:37:42 hypatia dbus-daemon[2023]: [session uid=1000 pid=2023] Activating via systemd: service name='org.freedesktop.Tracker1.Miner.Extract' unit='tracker-extract.service' requested by ':1.73' (uid=1000 pid=2425 comm="/usr/lib/tracker/tracker-miner-fs ")
Nov 13 10:37:42 hypatia systemd[2004]: Starting Tracker metadata extractor...
Nov 13 10:37:43 hypatia dbus-daemon[2023]: [session uid=1000 pid=2023] Successfully activated service 'org.freedesktop.Tracker1.Miner.Extract'
Nov 13 10:37:43 hypatia systemd[2004]: Started Tracker metadata extractor.
$ sudo head -n 12 /var/log/syslog
Nov 12 08:04:30 hypatia rsyslogd: [origin software="rsyslogd" swVersion="8.1910.0" x-pid="811" x-info="https://www.rsyslog.com"] rsyslogd was HUPed
Nov 12 08:04:30 hypatia systemd[1]: logrotate.service: Succeeded.
Nov 12 08:04:30 hypatia systemd[1]: Started Rotate log files.
Nov 12 08:04:30 hypatia vdr: [928] video directory scanner thread started (pid=882, tid=928, prio=low)
Nov 12 08:04:30 hypatia vdr: [882] registered source parameters for 'A - ATSC'
Nov 12 08:04:30 hypatia vdr: [882] registered source parameters for 'C - DVB-C'
Nov 12 08:04:30 hypatia vdr: [882] registered source parameters for 'S - DVB-S'
Nov 12 08:04:30 hypatia vdr: [882] registered source parameters for 'T - DVB-T'
Nov 12 08:04:30 hypatia vdr[882]: vdr: no primary device found - using first device!
Nov 12 08:04:30 hypatia vdr: [929] epg data reader thread started (pid=882, tid=929, prio=high)
Nov 12 08:04:30 hypatia vdr: [882] no DVB device found
Nov 12 08:04:30 hypatia vdr: [882] initializing plugin: vnsiserver (1.8.0): VDR-Network-Streaming-Interface (VNSI) Server
```


## Основы sed, редактор потоков

Давайте посмотрим на другие файлы, термины и утилиты, в именах которых нет `cat`. Мы можем сделать это, передав параметр `-v` команде `grep`, которая указывает команде выводить только строки, не содержащие `cat`:

```console
$ zcat ftu.txt.gz | grep -v cat
cut
head
less
md5sum
nl
od
paste
sed
sha256sum
sha512sum
sort
split
tail
tr
uniq
wc
```

Большую часть того, что мы можем сделать с помощью `grep`, мы также можем сделать с помощью `sed` - редактора потоков для фильтрации и преобразования текста (как указано на странице руководства по `sed`). Сначала мы восстановим наш файл `ftu.txt`, распаковав наш `gzip`-архив файла:

```console
$ gunzip ftu.txt.gz
$ ls ftu*
ftu.txt
```

Теперь мы можем использовать `sed` для вывода списка только строк, содержащих строку `cat`:

```console
$ sed -n /cat/p < ftu.txt
bzcat
cat
xzcat
zcat
```

Мы использовали знак «меньше» `<`, чтобы направить содержимое файла `ftu.txt` в нашу команду `sed`. Слово, заключенное между косой чертой (например, `/cat/`), - это термин, который мы ищем. Параметр `-n` указывает `sed` не выводить данные (кроме тех, которые позже указаны командой `p`). Попробуйте выполнить ту же команду без опции `-n`, чтобы увидеть, что произойдет. Тогда попробуйте это:

```console
$ sed /cat/d < ftu.txt
cut
head
less
md5sum
nl
od
paste
sed
sha256sum
sha512sum
sort
split
tail
tr
uniq
wc
```

Если мы не используем параметр `-n`, `sed` будет печатать все из файла, за исключением того, что `d` указывает `sed` удалить из своего вывода. Обычно `sed` используется для поиска и замены текста в файле. 

Предположим, вы хотите заменить каждое вхождение кошки на собаку. Вы можете использовать `sed` для этого, указав опцию `s` для замены каждого экземпляра первого члена `cat` на второй термин `dog`:

```console
$ sed s/cat/dog/ < ftu.txt
bzdog
dog
cut
head
less
md5sum
nl
od
paste
sed
sha256sum
sha512sum
sort
split
tail
tr
uniq
wc
xzdog
zdog
```

Вместо того, чтобы использовать оператор перенаправления (`<`) для передачи файла `ftu.txt` в нашу команду `sed`, мы можем просто заставить команду `sed` работать с файлом напрямую. Мы попробуем это дальше, одновременно создав резервную копию исходного файла:

```console
$ sed -i.backup s/cat/dog/ ftu.txt
$ ls ftu*
ftu.txt  ftu.txt.backup
```

Параметр `-i` выполнит операцию `sed` на месте с вашим исходным файлом. Если вы не используете `.backup` после параметра `-i`, вы просто переписали бы исходный файл. Все, что вы используете в качестве текста после параметра `-i`, будет именем, под которым будет сохранен исходный файл до изменений, которые вы просили выполнить `sed`.


## Обеспечение целостности данных

Мы продемонстрировали, насколько легко управлять файлами в Linux. Бывают случаи, когда вы можете захотеть передать файл кому-то другому, и вы хотите быть уверены, что получатель получит истинную копию исходного файла. Очень часто этот метод используется, когда на серверах распространения Linux размещаются загружаемые образы CD или DVD своего программного обеспечения вместе с файлами, которые содержат вычисленные значения контрольной суммы этих образов дисков. Вот пример листинга с зеркала загрузки Debian:

```console
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[PARENTDIR] Parent Directory                                      -
[SUM]       MD5SUMS                              2019-09-08 17:46 274
[CRT]       MD5SUMS.sign                         2019-09-08 17:52 833
[SUM]       SHA1SUMS                             2019-09-08 17:46 306
[CRT]       SHA1SUMS.sign                        2019-09-08 17:52 833
[SUM]       SHA256SUMS                           2019-09-08 17:46 402
[CRT]       SHA256SUMS.sign                      2019-09-08 17:52 833
[SUM]       SHA512SUMS                           2019-09-08 17:46 658
[CRT]       SHA512SUMS.sign                      2019-09-08 17:52 833
[ISO]       debian-10.1.0-amd64-netinst.iso      2019-09-08 04:37 335M
[ISO]       debian-10.1.0-amd64-xfce-CD-1.iso    2019-09-08 04:38 641M
[ISO]       debian-edu-10.1.0-amd64-netinst.iso  2019-09-08 04:38 405M
[ISO]       debian-mac-10.1.0-amd64-netinst.iso  2019-09-08 04:38 334M
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

В приведенном выше листинге файлы образов установщика Debian сопровождаются текстовыми файлами, которые содержат контрольные суммы файлов из различных алгоритмов (MD5, SHA1, SHA256 и SHA512).

>Контрольная сумма - это значение, полученное в результате математического вычисления, основанного на криптографической хеш-функции, для файла. Существуют различные типы криптографических хеш-функций, которые различаются по силе. Экзамен предполагает, что вы знакомы с использованием `md5sum`, `sha256sum` и `sha512sum`.

После того, как вы загрузите файл (например, образ `debian-10.1.0-amd64-netinst.iso`), вы затем сравните контрольную сумму загруженного файла с предоставленным вам значением контрольной суммы. 

Вот пример, чтобы проиллюстрировать эту мысль. Мы рассчитаем значение SHA256 для файла `ftu.txt` с помощью команды `sha256sum`:

```console
$ sha256sum ftu.txt
345452304fc26999a715652543c352e5fc7ee0c1b9deac6f57542ec91daf261c  ftu.txt
```

Длинная строка символов, предшествующая имени файла, является значением контрольной суммы SHA256 этого текстового файла. Давайте создадим файл, содержащий это значение, чтобы мы могли использовать его для проверки целостности нашего исходного текстового файла. Мы можем сделать это с помощью той же команды `sha256sum` и перенаправить вывод в файл:

```console
$ sha256sum ftu.txt > sha256.txt
```

Теперь, чтобы проверить файл `ftu.txt`, мы просто используем ту же команду и предоставим имя файла, которое содержит значение нашей контрольной суммы, вместе с переключателем `-c`:

```console
$ sha256sum -c sha256.txt
ftu.txt: OK
```

Значение, содержащееся в файле, соответствует вычисленной контрольной сумме SHA256 для нашего файла `ftu.txt`, как и следовало ожидать. Однако, если исходный файл был изменен (например, несколько байтов были потеряны во время загрузки файла или кто-то намеренно подделал его), проверка значения завершится неудачно. В таких случаях мы знаем, что наш файл плохой или поврежденный, и не можем доверять целостности его содержимого. Чтобы доказать это, мы добавим текст в конец файла:

```console
$ echo "new entry" >> ftu.txt
```

Теперь попробуем проверить целостность файла:

```console
$ sha256sum -c sha256.txt
ftu.txt: FAILED
sha256sum: WARNING: 1 computed checksum did NOT match
```

И мы видим, что контрольная сумма не соответствует ожидаемой для файла. Следовательно, мы не могли доверять целостности этого файла. Мы можем попытаться загрузить новую копию файла, сообщить об ошибке контрольной суммы отправителю файла или сообщить об этом группе безопасности центра обработки данных в зависимости от важности файла.


## Более глубокий взгляд на файлы

Команда восьмеричного дампа (`od`) часто используется для отладки приложений и различных файлов. Сама по себе команда `od` просто выведет список содержимого файла в восьмеричном формате. Мы можем использовать наш файл `ftu.txt` ранее, чтобы попрактиковаться с этой командой:

```console
$ od ftu.txt
0000000 075142 060543 005164 060543 005164 072543 005164 062550
0000020 062141 066012 071545 005163 062155 071465 066565 067012
0000040 005154 062157 070012 071541 062564 071412 062145 071412
0000060 060550 032462 071466 066565 071412 060550 030465 071462
0000100 066565 071412 071157 005164 070163 064554 005164 060564
0000120 066151 072012 005162 067165 070551 073412 005143 075170
0000140 060543 005164 061572 072141 000012
0000151
```

Первый столбец вывода - это байтовое *смещение* для каждой строки вывода. Поскольку `od` по умолчанию выводит информацию в восьмеричном формате, каждая строка начинается с байтового смещения в восемь бит, за которым следуют восемь столбцов, каждый из которых содержит восьмеричное значение данных в этом столбце.

>Напомним, что длина байта составляет 8 бит.

Если вам нужно просмотреть содержимое файла в шестнадцатеричном формате, используйте параметр `-x`:

```console
$ od -x ftu.txt
0000000 7a62 6163 0a74 6163 0a74 7563 0a74 6568
0000020 6461 6c0a 7365 0a73 646d 7335 6d75 6e0a
0000040 0a6c 646f 700a 7361 6574 730a 6465 730a
0000060 6168 3532 7336 6d75 730a 6168 3135 7332
0000100 6d75 730a 726f 0a74 7073 696c 0a74 6174
0000120 6c69 740a 0a72 6e75 7169 770a 0a63 7a78
0000140 6163 0a74 637a 7461 000a
0000151
```

Теперь каждый из восьми столбцов после байтового смещения представлен их шестнадцатеричными эквивалентами. Команду `od` удобно использовать для отладки скриптов. Например, команда `od` может показать нам символы, которые обычно не видны в файле, такие как записи новой строки. Мы можем сделать это с помощью параметра `-c`, чтобы вместо отображения числового обозначения для каждого байта эти записи столбца вместо этого отображались как их символьные эквиваленты:

```console
$ od -c ftu.txt
0000000   b   z   c   a   t  \n   c   a   t  \n   c   u   t  \n   h   e
0000020   a   d  \n   l   e   s   s  \n   m   d   5   s   u   m  \n   n
0000040   l  \n   o   d  \n   p   a   s   t   e  \n   s   e   d  \n   s
0000060   h   a   2   5   6   s   u   m  \n   s   h   a   5   1   2   s
0000100   u   m  \n   s   o   r   t  \n   s   p   l   i   t  \n   t   a
0000120   i   l  \n   t   r  \n   u   n   i   q  \n   w   c  \n   x   z
0000140   c   a   t  \n   z   c   a   t  \n
0000151
```

Все записи новой строки в файле представлены скрытыми символами `\n`. Если вы просто хотите просмотреть все символы в файле и не хотите видеть информацию о смещении байтов, столбец смещения байтов можно удалить из вывода следующим образом:

```console
$ od -An -c ftu.txt
   b   z   c   a   t  \n   c   a   t  \n   c   u   t  \n   h   e
   a   d  \n   l   e   s   s  \n   m   d   5   s   u   m  \n   n
   l  \n   o   d  \n   p   a   s   t   e  \n   s   e   d  \n   s
   h   a   2   5   6   s   u   m  \n   s   h   a   5   1   2   s
   u   m  \n   s   o   r   t  \n   s   p   l   i   t  \n   t   a
   i   l  \n   t   r  \n   u   n   i   q  \n   w   c  \n   x   z
   c   a   t  \n   z   c   a   t  \n
```


## Упражнения для закрепления

1. Кто-то только что подарил вашей школе ноутбук, и теперь вы хотите установить на него Linux. Здесь нет руководства, и вы были вынуждены загрузить его с флэш-накопителя USB без какой-либо графики. У вас есть терминал оболочки, и вы знаете, что для каждого процессора в файле `/proc/cpuinfo` будет строка для него:

```console
processor	: 0
vendor_id	: GenuineIntel
cpu family	: 6
model		: 158

(lines skipped)

processor	: 1
vendor_id	: GenuineIntel
cpu family	: 6
model		: 158

(more lines skipped)
```

* Использование команд `grep` и `wc` покажет, сколько у вас процессоров. 
* Сделайте то же самое с `sed` вместо `grep`.

2. Изучите свой локальный файл `/etc/passwd` с помощью команд `grep`, `sed`, `head` и `tail` для выполнения следующих задач: 
* Какие пользователи имеют доступ к оболочке Bash? 
* В вашей системе есть разные пользователи, которые работают с определенными программами или в административных целях. У них нет доступа к оболочке. Сколько из них существует в вашей системе? 
* Сколько пользователей и групп существует в вашей системе (помните: используйте только файл `/etc/passwd`)? 
* Укажите только первую, последнюю и десятую строки вашего файла `/etc/passwd`.

3. Рассмотрим этот пример файла `/etc/passwd`. Скопируйте приведенные ниже строки в локальный файл с именем mypasswd для этого упражнения.

```console
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
nvidia-persistenced:x:121:128:NVIDIA Persistence Daemon,,,:/nonexistent:/sbin/nologin
libvirt-qemu:x:64055:130:Libvirt Qemu,,,:/var/lib/libvirt:/usr/sbin/nologin
libvirt-dnsmasq:x:122:133:Libvirt Dnsmasq,,,:/var/lib/libvirt/dnsmasq:/usr/sbin/nologin
carol:x:1000:2000:Carol Smith,Finance,,,Main Office:/home/carol:/bin/bash
dave:x:1001:1000:Dave Edwards,Finance,,,Main Office:/home/dave:/bin/ksh
emma:x:1002:1000:Emma Jones,Finance,,,Main Office:/home/emma:/bin/bash
frank:x:1003:1000:Frank Cassidy,Finance,,,Main Office:/home/frank:/bin/bash
grace:x:1004:1000:Grace Kearns,Engineering,,,Main Office:/home/grace:/bin/ksh
henry:x:1005:1000:Henry Adams,Sales,,,Main Office:/home/henry:/bin/bash
john:x:1006:1000:John Chapel,Sales,,,Main Office:/home/john:/bin/bash
```

* Перечислите всех пользователей в группе `1000` (используйте `sed`, чтобы выбрать только соответствующее поле) из вашего файла `mypasswd`. 
* Укажите только полные имена всех пользователей этой группы (используйте `sed` и `cut`).


## Упражнения на размышления

1. Еще раз используя файл `mypasswd` из предыдущих упражнений, придумайте команду Bash, которая выберет одного человека из главного офиса, чтобы выиграть розыгрыш розыгрыша. Используйте команду `sed`, чтобы распечатать только строки для главного офиса, а затем последовательность команд `cut`, чтобы получить имя каждого пользователя из этих строк. Затем вы захотите отсортировать эти имена случайным образом и распечатать только первое имя из списка. 

2. Сколько человек работает в отделах финансов, инжиниринга и продаж? (Рассмотрите возможность изучения команды `uniq`). 

3. Теперь вы хотите подготовить файл CSV (значения, разделенные запятыми), чтобы можно было легко импортировать из файла `mypasswd` в предыдущем примере файл `names.csv` в LibreOffice. Содержимое файла будет иметь следующий формат:

```console
First Name,Last Name,Position
Carol,Smith,Finance
...
John,Chapel,Sales
```

Совет: используйте команды `sed`, `cut` и `paste` для достижения желаемых результатов. Обратите внимание, что запятая (`,`) будет разделителем для этого файла.

4. Предположим, что электронная таблица `names.csv`, созданная в предыдущем упражнении, является важным файлом, и мы хотим убедиться, что никто не будет вмешиваться в него с момента отправки кому-то и момента, когда получатель получит его. Как мы можем гарантировать целостность этого файла с помощью `md5sum`? 

5. Вы пообещали себе, что будете читать классическую книгу по 100 строк в день, и решили начать с *Mariner and Mystic* Германа Мелвилла. Придумайте команду с помощью `split`, которая разделит эту книгу на разделы по 100 строк в каждом. Чтобы получить книгу в текстовом формате, найдите ее на https://www.gutenberg.org. 

6. Какой список вы получите, используя команду `ls -l` в каталоге `/etc`? Используя команду `cut` на выходе данной команды `ls`, как бы вы отобразили только имена файлов? А как насчет имени файла и владельца файлов? Наряду с командами `ls -l` и `cut` используйте команду `tr`, чтобы сжать несколько экземпляров пробела в один пробел, чтобы облегчить форматирование вывода с помощью команды `cut`. 

7. В этом упражнении предполагается, что вы находитесь на реальной машине (а не на виртуальной). У вас также должен быть USB-накопитель. Просмотрите страницы руководства по команде `tail` и узнайте, как следить за файлом, когда к нему добавляется текст. Наблюдая за выводом команды `tail` в файле `/var/log/syslog`, вставьте USB-накопитель. Запишите полную команду, которую вы бы использовали для получения продукта, производителя и общего объема памяти вашего USB-накопителя.


## Резюме

Работа с текстовыми потоками имеет большое значение при администрировании любой системы Linux. Текстовые потоки можно обрабатывать с помощью сценариев для автоматизации повседневных задач или поиска соответствующей отладочной информации в файлах журналов. Вот краткое изложение команд, рассмотренных в этом уроке: 

`cat`  
Используется для объединения или чтения текстовых файлов. 

`bzcat`  
Позволяет обрабатывать или читать файлы, сжатые с помощью метода `bzip2`. 

`xzcat`  
Позволяет обрабатывать или читать файлы, сжатые с использованием метода `xz`. 

`zcat`  
Позволяет обрабатывать или читать файлы, сжатые с помощью метода `gzip`. 

`less`  
Эта команда разбивает содержимое файла на страницы и обеспечивает функции навигации и поиска. 

`head`  
Эта команда по умолчанию отображает первые 10 строк файла. С помощью переключателя `-n` можно отобразить меньше или больше строк. 

`tail`  
Эта команда по умолчанию отображает последние 10 строк файла. С помощью параметра `-n` можно отобразить меньше или больше строк. Параметр `-f` используется для отслеживания вывода текстового файла, в который записываются новые данные. 

`wc`  
Сокращение от количество слов, но в зависимости от используемых вами параметров он будет подсчитывать символы, слова и строки. 

`sort`  
Используется для организации вывода списка в алфавитном порядке, в обратном алфавитном порядке или в случайном порядке. 

`uniq`  
Используется для перечисления (и подсчета) совпадающих строк. 

`od`  
Команда «восьмеричный дамп» используется для отображения двоичного файла в восьмеричной, десятичной или шестнадцатеричной системе счисления. 

`nl`  
Команда «числовая строка» отобразит количество строк в файле, а также воссоздает файл с каждой строкой, к которой добавляется номер строки. 

`sed`  
Редактор потока можно использовать для поиска совпадающих вхождений строк с помощью регулярных выражений, а также для редактирования файлов с использованием заранее определенных шаблонов. 

`tr`  
Команда преобразовать может заменять символы, а также удалять и сжимать повторяющиеся символы. 

`cut`  
Эта команда может печатать столбцы текстовых файлов как поля на основе разделителя символов файла. 

`paste`  
Объединяет файлы в столбцы на основе использования разделителей полей. 

`split`  
Эта команда может разбивать файлы большего размера на более мелкие в зависимости от критериев, установленных параметрами команды. 

`md5sum`  
Используется для вычисления хеш-значения MD5 файла. Также используется для проверки файла на соответствие существующему хеш-значению, чтобы гарантировать целостность файла. 

`sha256sum`  
Используется для вычисления хэш-значения SHA256 файла. Также используется для проверки файла на соответствие существующему хеш-значению, чтобы гарантировать целостность файла. 

`sha512sum`  
Используется для вычисления хэш-значения SHA512 файла. Также используется для проверки файла на соответствие существующему хеш-значению, чтобы гарантировать целостность файла.


## Ответы на упражнения для закрепления

**1. Кто-то только что подарил вашей школе ноутбук, и теперь вы хотите установить на него Linux. Здесь нет руководства, и вы были вынуждены загрузить его с флэш-накопителя USB без какой-либо графики. У вас есть терминал оболочки, и вы знаете, что для каждого процессора в файле `/proc/cpuinfo` будет строка для него:**

```console
processor	: 0
vendor_id	: GenuineIntel
cpu family	: 6
model		: 158

(lines skipped)

processor	: 1
vendor_id	: GenuineIntel
cpu family	: 6
model		: 158

(more lines skipped)
```

* Использование команд `grep` и `wc` покажет, сколько у вас процессоров. 

Вот два варианта:

```console
$ cat /proc/cpuinfo | grep processor | wc -l
$ grep processor /proc/cpuinfo | wc -l
```

Теперь, когда вы знаете, что есть несколько способов сделать то же самое, когда вы должны использовать тот или другой? Это действительно зависит от нескольких факторов, два из которых наиболее важны - это производительность и удобочитаемость. В большинстве случаев вы будете использовать команды оболочки внутри сценариев оболочки для автоматизации ваших задач, и чем больше и сложнее становятся ваши сценарии, тем больше вам нужно беспокоиться о том, чтобы они оставались быстрыми.

* Сделайте то же самое с `sed` вместо `grep`.

Теперь вместо `grep` мы попробуем это с помощью `sed`:

```console
$ sed -n /processor/p /proc/cpuinfo | wc -l
```

Здесь мы использовали `sed` с параметром `-n`, поэтому `sed` не будет печатать ничего, кроме того, что соответствует процессору выражений, как указано командой `p`. Как мы делали в решениях `grep`, `wc -l` подсчитает количество строк, то есть количество процессоров, которые у нас есть. 

Изучите следующий пример:

```console
$ sed -n /processor/p /proc/cpuinfo | sed -n '$='
```

Эта последовательность команд обеспечивает те же результаты, что и в предыдущем примере, где вывод `sed` был передан в команду `wc`. Разница здесь в том, что вместо использования `wc -l` для подсчета количества строк снова вызывается `sed` для обеспечения эквивалентной функциональности. И снова мы подавляем вывод `sed` с помощью опции `-n`, за исключением выражения, которое мы явно вызываем, а именно `'$ ='`. Это выражение указывает `sed` сопоставить последнюю строку (`$`), а затем распечатать этот номер строки (`=`).


**2. Изучите свой локальный файл `/etc/passwd` с помощью команд `grep`, `sed`, `head` и `tail` для выполнения следующих задач:**
* Какие пользователи имеют доступ к оболочке Bash? 
* В вашей системе есть разные пользователи, которые работают с определенными программами или в административных целях. У них нет доступа к оболочке. Сколько из них существует в вашей системе? 
* Сколько пользователей и групп существует в вашей системе (помните: используйте только файл `/etc/passwd`)? 
* Укажите только первую, последнюю и десятую строки вашего файла `/etc/passwd`.

**3. Рассмотрим этот пример файла `/etc/passwd`. Скопируйте приведенные ниже строки в локальный файл с именем mypasswd для этого упражнения.**

```console
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
nvidia-persistenced:x:121:128:NVIDIA Persistence Daemon,,,:/nonexistent:/sbin/nologin
libvirt-qemu:x:64055:130:Libvirt Qemu,,,:/var/lib/libvirt:/usr/sbin/nologin
libvirt-dnsmasq:x:122:133:Libvirt Dnsmasq,,,:/var/lib/libvirt/dnsmasq:/usr/sbin/nologin
carol:x:1000:2000:Carol Smith,Finance,,,Main Office:/home/carol:/bin/bash
dave:x:1001:1000:Dave Edwards,Finance,,,Main Office:/home/dave:/bin/ksh
emma:x:1002:1000:Emma Jones,Finance,,,Main Office:/home/emma:/bin/bash
frank:x:1003:1000:Frank Cassidy,Finance,,,Main Office:/home/frank:/bin/bash
grace:x:1004:1000:Grace Kearns,Engineering,,,Main Office:/home/grace:/bin/ksh
henry:x:1005:1000:Henry Adams,Sales,,,Main Office:/home/henry:/bin/bash
john:x:1006:1000:John Chapel,Sales,,,Main Office:/home/john:/bin/bash
```

* Перечислите всех пользователей в группе `1000` (используйте `sed`, чтобы выбрать только соответствующее поле) из вашего файла `mypasswd`. 
* Укажите только полные имена всех пользователей этой группы (используйте `sed` и `cut`).


## Ответы на упражнения для размышления

1. Еще раз используя файл `mypasswd` из предыдущих упражнений, придумайте команду Bash, которая выберет одного человека из главного офиса, чтобы выиграть розыгрыш розыгрыша. Используйте команду `sed`, чтобы распечатать только строки для главного офиса, а затем последовательность команд `cut`, чтобы получить имя каждого пользователя из этих строк. Затем вы захотите отсортировать эти имена случайным образом и распечатать только первое имя из списка. 

2. Сколько человек работает в отделах финансов, инжиниринга и продаж? (Рассмотрите возможность изучения команды `uniq`). 

3. Теперь вы хотите подготовить файл CSV (значения, разделенные запятыми), чтобы можно было легко импортировать из файла `mypasswd` в предыдущем примере файл `names.csv` в LibreOffice. Содержимое файла будет иметь следующий формат:

```console
First Name,Last Name,Position
Carol,Smith,Finance
...
John,Chapel,Sales
```

Совет: используйте команды `sed`, `cut` и `paste` для достижения желаемых результатов. Обратите внимание, что запятая (`,`) будет разделителем для этого файла.

4. Предположим, что электронная таблица `names.csv`, созданная в предыдущем упражнении, является важным файлом, и мы хотим убедиться, что никто не будет вмешиваться в него с момента отправки кому-то и момента, когда получатель получит его. Как мы можем гарантировать целостность этого файла с помощью `md5sum`? 

5. Вы пообещали себе, что будете читать классическую книгу по 100 строк в день, и решили начать с *Mariner and Mystic* Германа Мелвилла. Придумайте команду с помощью `split`, которая разделит эту книгу на разделы по 100 строк в каждом. Чтобы получить книгу в текстовом формате, найдите ее на https://www.gutenberg.org. 

6. Какой список вы получите, используя команду `ls -l` в каталоге `/etc`? Используя команду `cut` на выходе данной команды `ls`, как бы вы отобразили только имена файлов? А как насчет имени файла и владельца файлов? Наряду с командами `ls -l` и `cut` используйте команду `tr`, чтобы сжать несколько экземпляров пробела в один пробел, чтобы облегчить форматирование вывода с помощью команды `cut`. 

7. В этом упражнении предполагается, что вы находитесь на реальной машине (а не на виртуальной). У вас также должен быть USB-накопитель. Просмотрите страницы руководства по команде `tail` и узнайте, как следить за файлом, когда к нему добавляется текст. Наблюдая за выводом команды `tail` в файле `/var/log/syslog`, вставьте USB-накопитель. Запишите полную команду, которую вы бы использовали для получения продукта, производителя и общего объема памяти вашего USB-накопителя.
