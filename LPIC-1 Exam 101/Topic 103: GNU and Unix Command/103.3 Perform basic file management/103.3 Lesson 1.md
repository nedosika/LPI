# 103.3 Урок 1

| **Сертификат:** | LPIC-1                                    |
|:----------------|:------------------------------------------|
| **Версия:**     | 5.0                                       |
| **Тема:**       | 103 Команды GNU и Unix                    |
| **Задача:**     | 103.3 Выполнить базовое управление файлами |
| **Урок:**       | 1 из 2                                    |


## Введение

Все в Linux - это файлы, поэтому очень важно знать, как ими управлять. В этом уроке мы рассмотрим основные операции с файлами.

Как правило, вы, как пользователь Linux, должны будете перемещаться по файловой системе, копировать файлы из одного места в другое и удалять файлы. Мы также рассмотрим команды, связанные с управлением файлами. 

Файл - это объект, в котором хранятся данные и программы. Он состоит из содержимого и метаданных (размер файла, владелец, дата создания, права доступа). Файлы организованы в каталоги. Каталог - это файл, в котором хранятся другие файлы. 

К различным типам файлов относятся: 

Обычные файлы  
в которых хранятся данные и программы. 

Справочники  
которые содержат другие файлы. 

Специальные файлы  
которые используются для ввода и вывода. 

Конечно, существуют и другие типы файлов, но они выходят за рамки этого урока. Позже мы обсудим, как идентифицировать эти разные типы файлов.


## Управление файлами

### Использование `ls` для вывода списка файлов

Команда `ls` - один из самых важных инструментов командной строки, который вам следует изучить для навигации по файловой системе. 

В своей базовой форме `ls` перечислит *только* имена файлов и каталогов:

```console
$ ls
Desktop Downloads   emp_salary  file1   Music   Public  Videos
Documents   emp_name    examples.desktop    file2   Pictures    Templates
```

При использовании с `-l`, называемом форматом «длинный список», он показывает права доступа к файлу или каталогу, владельца, размер, дату изменения, время и имя:

```console
$ ls -l
total 60
drwxr-xr-x  2   frank   frank   4096    Apr 1   2018    Desktop
drwxr-xr-x  2   frank   frank   4096    Apr 1   2018    Documents
drwxr-xr-x  2   frank   frank   4096    Apr 1   2018    Downloads
-rw-r--r--  1   frank   frank     21    Sep 7   12:59   emp_name
-rw-r--r--  1   frank   frank     20    Sep 7   13:03   emp_salary
-rw-r--r--  1   frank   frank   8980    Apr 1   2018    examples.desktop
-rw-r--r--  1   frank   frank     10    Sep 1   2018    file1
-rw-r--r--  1   frank   frank     10    Sep 1   2018    file2
drwxr-xr-x  2   frank   frank   4096    Apr 1   2018    Music
drwxr-xr-x  2   frank   frank   4096    Apr 1   2018    Pictures
drwxr-xr-x  2   frank   frank   4096    Apr 1   2018    Public
drwxr-xr-x  2   frank   frank   4096    Apr 1   2018    Templates
drwxr-xr-x  2   frank   frank   4096    Apr 1   2018    Videos
```

Первый символ в выводе указывает тип файла: 

`-`  
для обычного файла.  

`d`  
для справочника. 

`c`  
для специального файла. 

Чтобы показать размеры файлов в удобочитаемом формате, добавьте параметр `-h`:

```console
$ ls -lh
total 60K
drwxr-xr-x  2   frank   frank   4.0K    Apr 1   2018    Desktop
drwxr-xr-x  2   frank   frank   4.0K    Apr 1   2018    Documents
drwxr-xr-x  2   frank   frank   4.0K    Apr 1   2018    Downloads
-rw-r--r--  1   frank   frank     21    Sep 7   12:59   emp_name
-rw-r--r--  1   frank   frank     20    Sep 7   13:03   emp_salary
-rw-r--r--  1   frank   frank   8.8K    Apr 1   2018    examples.desktop
-rw-r--r--  1   frank   frank     10    Sep 1   2018    file1
-rw-r--r--  1   frank   frank     10    Sep 1   2018    file2
drwxr-xr-x  2   frank   frank   4.0K    Apr 1   2018    Music
drwxr-xr-x  2   frank   frank   4.0K    Apr 1   2018    Pictures
drwxr-xr-x  2   frank   frank   4.0K    Apr 1   2018    Public
drwxr-xr-x  2   frank   frank   4.0K    Apr 1   2018    Templates
drwxr-xr-x  2   frank   frank   4.0K    Apr 1   2018    Videos
```

Чтобы вывести список всех файлов, включая скрытые (начинающиеся с `.`), Используйте параметр `-a`:

```console
$ ls -a
.               .dbus   file1   .profile
..              Desktop file2   Public
.bash_history   .dmrc  .gconf  .sudo_as_admin_successful
```

Файлы конфигурации, такие как `.bash_history`, которые по умолчанию скрыты, теперь видны. Как правило, синтаксис команды `ls` имеет следующий вид:

```console
ls OPTIONS FILE
```

Где `OPTIONS` - это любая из опций, показанных ранее (чтобы просмотреть все возможные опции, запустите `man ls`), а `FILE` - это имя файла или сведения о каталоге, которые вы хотите перечислить.

>Если `FILE` не указан, подразумевается текущий каталог.

### Создание, копирование, перемещение и удаление файлов

#### Создание файлов при помощи `touch`

Команда `touch` - это самый простой способ создавать новые пустые файлы. Вы также можете использовать его для изменения отметок времени (т.е. времени модификации) существующих файлов и каталогов. Синтаксис использования `touch`:

```console
touch OPTIONS FILE_NAME(S)
```

Без каких-либо параметров `touch` создаст новые файлы для любых имен файлов, которые указаны в качестве аргументов, при условии, что файлы с такими именами еще не существуют. `touch` может одновременно создавать любое количество файлов:

```console
$ touch file1 file2 file3
```

Это создаст три новых пустых файла с именами `file1`, `file2` и `file3`. 

Несколько опций `touch` специально разработаны, чтобы позволить пользователю изменять временные метки для файлов. Например, опция `-a` изменяет только время доступа, а опция `-m` изменяет только время модификации. Использование обеих опций вместе изменяет время доступа, а также время модификации на текущее время:

```console
$ touch -am file3
```


#### Копирование файлов с помощью `cp`

Как пользователь Linux вы часто будете копировать файлы из одного места в другое. Будь то перемещение музыкального файла из одного каталога в другой или системного файла, используйте `cp` для всех задач копирования:

```console
$ cp file1 dir2
```

Эту команду можно буквально интерпретировать как копирование `file1` в каталог `dir2`. Результат - наличие `file1` внутри `dir2`. Для успешного выполнения этой команды файл `file1` должен существовать в текущем каталоге пользователя. В противном случае система сообщает об ошибке с сообщением `No such file or directory`.

```console
$ cp dir1/file1 dir2
```

В этом случае обратите внимание, что путь к файлу `file1` более явный. Исходный путь может быть выражен как *относительный* или *абсолютный путь*. Относительные пути даются со ссылкой на конкретный каталог, а абсолютные пути не даются со ссылкой. Ниже мы уточним это понятие. 

На данный момент просто обратите внимание, что эта команда копирует `file1` в каталог `dir2`. Путь к файлу `file1` указан более подробно, поскольку пользователь в настоящее время не находится в каталоге `dir1`.

```console
$ cp /home/frank/Documents/file2 /home/frank/Documents/Backup
```

В этом третьем случае файл `file2`, расположенный в `/home/frank/Documents`, копируется в каталог `/home/frank/Documents/Backup`. Указанный здесь исходный путь является *абсолютным*. В двух приведенных выше примерах исходные пути *относительны*. Когда путь начинается с символа `/`, это абсолютный путь, в противном случае - относительный путь. 

Общий синтаксис `cp`:

```console
cp OPTIONS SOURCE DESTINATION
```

`SOURCE` - это путь к файлу, который нужно скопировать, а `DESTINATION` - это путь к каталогу, в который будет скопирован файл. `SOURCE` и `DESTINATION` могут быть указаны в абсолютном или относительном виде.


#### Перемещение файлов с помощью `mv`

Как и `cp` для копирования, Linux предоставляет команду для перемещения и переименования файлов. Она называется `mv`. 

Операция перемещения аналогична операции вырезания и вставки, которую вы обычно выполняете через графический интерфейс пользователя (GUI). 

Если вы хотите переместить файл в новое место, используйте `mv` следующим образом:

```console
mv FILENAME DESTINATION_DIRECTORY
```

Вот пример:

```console
$ mv myfile.txt /home/frank/Documents
```

В результате `myfile.txt` перемещается в папку назначения `/home/frank/Documents`. 

Чтобы переименовать файл, `mv` используется следующим образом:

```console
$ mv old_file_name new_file_name
```

Это изменяет имя файла с `old_file_name` на `new_file_name`. 

По умолчанию `mv` не будет cпрашивать ваше подтверждение, если вы хотите перезаписать (переименовать) существующий файл. Однако вы можете разрешить системе запрашивать, используя параметр `-i`:

```console
$ mv -i old_file_name new_file_name
mv: overwrite 'new_file_name'?
```

Эта команда запрашивает разрешение пользователя перед перезаписью `old_file_name` на `new_file_name`. И наоборот, используя `-f`:

```console
$ mv -f old_file_name new_file_name
```

принудительно перезапишет файл, не спрашивая разрешения.


#### Удаление файлов с помощью `rm`

`rm` используется для удаления файлов. Думайте об этом как об сокращенной форме слова «удалить». Обратите внимание, что действие по удалению файла обычно необратимо, поэтому эту команду следует использовать с осторожностью.

```console
$ rm file1
```

Эта команда удалит `file1`.

```console
$ rm -i file1
rm: remove regular file 'file1'?
```

Эта команда будет запрашивать у пользователя подтверждение перед удалением `file1`. Помните, мы видели опцию `-i` при использовании `mv` ранее.

```console
$ rm -f file1
```

Эта команда принудительно удаляет `file1` без вашего подтверждения. 

Одновременно можно удалить несколько файлов:

```console
$ rm file1 file2 file3
```

В этом примере `file1`, `file2` и `file3` удаляются одновременно. 

Синтаксис для `rm` обычно имеет следующий вид:

```console
rm OPTIONS FILE
```

## Создание и удаление каталогов

### Создание каталогов с помощью `mkdir`

Создание каталогов имеет решающее значение для организации ваших файлов и папок. Файлы можно логически сгруппировать, храня их в каталоге. Чтобы создать каталог, используйте `mkdir`:

```console
mkdir OPTIONS DIRECTORY_NAME
```

где `DIRECTORY_NAME` - имя создаваемого каталога. Одновременно можно создать любое количество каталогов:

```console
$ mkdir dir1
```

создаст каталог `dir1` в текущем каталоге пользователя.

```console
$ mkdir dir1 dir2 dir3
```

Предыдущая команда создаст три каталога `dir1`, `dir2` и `dir3` одновременно. 

Чтобы создать каталог вместе с его подкаталогами, используйте параметр `-p` («родители»):

```console
$ mkdir -p parents/children
```

Эта команда создаст структуру каталогов `parents/children`, т.е. она создаст каталоги `parents` и `children`. `children` будет находиться внутри `parents`.


### Удаление каталогов с помощью `rmdir`

`rmdir` удаляет каталог, *если он пуст*. Его синтаксис определяется следующим образом:

```console
rmdir OPTIONS DIRECTORY
```

где `DIRECTORY` может быть одним аргументом или списком аргументов.

```console
$ rmdir dir1
```

Эта команда удалит `dir1`.

```console
$ rmdir dir1 dir2
```

Эта команда одновременно удалит каталоги `dir1` и `dir2`. 

Вы можете удалить каталог с его подкаталогом:

```console
$ rmdir -p parents/children
```

Это удалит структуру каталогов `parents/children`. Обратите внимание, что если какой-либо из каталогов не пуст, они не будут удалены.


### Рекурсивное манипулирование файлами и каталогами

Чтобы управлять каталогом и его содержимым, вам необходимо применить *рекурсию*. Рекурсия означает выполнение действия и повторение этого действия по всему дереву каталогов. В Linux параметры `-r` или `-R` или `--recursive` обычно связаны с рекурсией. 

Следующий сценарий поможет вам лучше понять рекурсию: 

Вы перечисляете содержимое каталога `student`, который содержит два подкаталога `level 1` и `level 2` и файл с именем `frank`. Применяя рекурсию, команда `ls` выводит список студентов, то есть `level 1`, `level 2` и `frank`, но на этом не заканчивается. Он в равной степени войдет в подкаталоги `level 1` и `level 2`, перечислит их содержимое и так далее по дереву каталогов.


### Рекурсивный листинг с `ls -R`

`ls -R` используется для вывода списка содержимого каталога вместе с его подкаталогами и файлами.

```console
$ ls -R mydirectory
mydirectory/:
file1   newdirectory

mydirectory/newdirectory:
```

В приведенном выше листинге отображена директория `mydirectory`, включая все ее содержимое. Вы можете заметить, что `mydirectory` содержит подкаталог `newdirectory` и файл `file1`. `newdirectory` пуст, поэтому содержимое не отображается. В общем, чтобы перечислить содержимое каталога, включая его подкаталоги, используйте:

```console
ls -R DIRECTORY_NAME
```

Добавление косой черты в `DIRECTORY_NAME` ни на что не влияет:

```console
$ ls -R animal
```

похоже на

```console
$ ls -R animal/
```


### Рекурсивное копирование с помощью `cp -r`

`cp -r` (или `-R` или `--recursive`) позволяет копировать каталог вместе со всеми его подкаталогами и файлами.

```console
$ tree mydir
mydir
|_file1
|_newdir
    |_file2
    |_insidenew
        |_lastdir


3 directories, 2 files
$ mkdir newcopy
$ cp mydir newcopy
cp: omitting directory 'mydir'
$ cp -r mydir newcopy
* tree newcopy
newcopy
|_mydir
    |_file1
    |_newdir
        |_file2
        |_insidenew
            |_lastdir

4 directories, 2 files
```

В листинге выше мы видим, что при попытке скопировать `mydir` в `newcopy`, используя `cp` без `-r`, система отображает сообщение `cp`: пропуская каталог `mydir`. Однако при добавлении опции `-r` все содержимое `mydir`, включая его самого, копируется в `newcopy`. 

Для копирования каталогов и подкаталогов используйте:

```console
cp -r SOURCE DESTINATION
```


### Рекурсивное удаление с помощью `rm -r`

`rm -r` удалит каталог и все его содержимое (подкаталоги и файлы).

>Будьте очень осторожны с параметром `-r` или комбинацией опций `-rf` при использовании с командой `rm`. Рекурсивная команда удаления в важном системном каталоге может сделать систему непригодной для использования. Используйте рекурсивную команду удаления только в том случае, если абсолютно уверены, что содержимое каталога безопасно удалить с компьютера.

При попытке удалить каталог без использования `-r` система сообщит об ошибке:

```console
$ rm newcopy/
rm: cannot remove 'newcopy/': Is a directory
$ rm -r newcopy/
```

Вы должны добавить `-r`, как во второй команде, чтобы удаление вступило в силу.

>Вам может быть интересно, почему мы не используем `rmdir` в этом случае. Между двумя командами есть небольшая разница. `rmdir` удастся удалить, только если данный каталог пуст, тогда как `rm -r` можно использовать независимо от того, пуст этот каталог или нет.

Добавьте параметр `-i` для поиска подтверждения перед удалением файла:

```console
$ rm -ri mydir/
rm: remove directory 'mydir/'?
```

Система запрашивает перед попыткой удалить `mydir`.


### Подстановка файлов и подстановочные знаки

*Подстановка файлов* - это функция, предоставляемая оболочкой Unix/Linux для представления нескольких имен файлов с помощью специальных символов, называемых *подстановочными знаками*. Подстановочные знаки - это, по сути, символы, которые могут использоваться для замены одного или нескольких символов. Они позволяют, например, показать все файлы, начинающиеся с буквы `A`, или все файлы, заканчивающиеся на буквы `.conf`. 

Подстановочные знаки очень полезны, поскольку их можно использовать с такими командами, как `cp`, `ls` или `rm`. 

Ниже приведены некоторые примеры подстановки файлов: 

`rm *`  
Удалить все файлы в текущем рабочем каталоге. 

`ls l?st`  
Перечислите все файлы, имена которых начинаются с `l`, за которым следует любой одиночный символ и заканчиваются `st`. 

`rmdir [а-я]*`  
Удалите все каталоги, название которых начинается с буквы.


### Типы подстановочных знаков

В Linux в качестве подстановочных знаков можно использовать три символа: 

`*` (звездочка)  
что представляет собой ноль, одно или несколько вхождений любого символа. 

`?` (вопросительный знак)  
который представляет собой единственное вхождение любого символа. 

`[]` (символы в квадратных скобках)  
который представляет любое вхождение символа(ов), заключенного в квадратные скобки. Можно использовать разные типы символов, будь то цифры, буквы и другие специальные символы. Например, выражение `[0-9]` соответствует всем цифрам.


### Звездочка

Звездочка (`*`) соответствует нулю, одному или нескольким вхождениям любого символа. 

Например:

```console
$ find /home -name *.png
```

В результате будут найдены все файлы с расширением `.png`, например `photo.png`, `cat.png`, `frank.png`. Команда `find` будет подробнее рассмотрена в следующем уроке. 

По аналогии:

```console
$ ls lpic-*.txt
```

перечислит все текстовые файлы, которые начинаются с символов `lpic-`, за которыми следует любое количество символов и заканчиваются на `.txt`, например `lpic-1.txt` и `lpic-2.txt`. 

Подстановочный знак звездочки можно использовать для управления (копирования, удаления или перемещения) всего содержимого каталога:

```console
$ cp -r animal/* forest
```

В этом примере все содержимое `animal` копируется в `forest`. 

Обычно для копирования всего содержимого каталога мы используем:

```console
cp -r SOURCE_PATH/* DEST_PATH
```

где `SOURCE_PATH` можно не указывать, если мы уже находимся в требуемом каталоге. 

Звездочка, как и любой другой подстановочный знак, может многократно использоваться в одной команде и в любой позиции:

```console
$ rm *ate*
```

Имена файлов с префиксом нуля, одно или несколько вхождений любого символа, за которыми следуют буквы `ate` и заканчивающиеся нулем, одно или несколько вхождений любого символа будут удалены.


### Знак вопроса

Вопросительный знак (`?`) cоответствует *единственному* появлению символа. 

Рассмотрим листинг:

```console
$ ls
last.txt    lest.txt    list.txt    third.txt   past.txt
```

Чтобы вернуть только файлы, которые начинаются с `l`, за которым следует любой одиночный символ и символы `st.txt`, мы используем подстановочный знак вопросительного знака (`?`):

```console
$ ls l?st.txt
last.txt    lest.txt    list.txt
```

Отображаются только файлы `last.txt`, `lest.txt` и `list.txt`, соответствующие заданным критериям. 

По аналогии,

```console
$ ls ??st.txt
last.txt    lest.txt    list.txt    past.txt
```

выходные файлы с префиксом из двух любых символов, за которым следует текст `st.txt`.


### Заключенные в скобки персонажи

Подстановочные знаки в квадратных скобках соответствуют любому появлению символа(ов), заключенного в квадратные скобки:

```console
$ ls l[aef]st.txt
last.txt    lest.txt
```

Эта команда перечислит все файлы, начинающиеся с `l`, за которым следует *любой* из символов набора `aef` и заканчивающиеся `st.txt`. 

Квадратные скобки также могут принимать диапазоны:

```console
$ ls l[a-z]st.txt
last.txt    lest.txt    list.txt
```

Это выводит все файлы с именами, начинающимися с `l`, за которой следует любая строчная буква в диапазоне от `a` до `z` и заканчивающаяся `st.txt`. 

В квадратных скобках также можно указать несколько диапазонов:

```console
$ ls
student-1A.txt  student-2A.txt  student-3.txt
$ ls student-[0-9][A-Z].txt
student-1A.text student-2A.txt
```

В списке отображается школьный каталог со списком зарегистрированных учеников. Перечислить только тех студентов, регистрационные номера которых соответствуют следующим критериям:
* начать со `student-` 
* за которым следует число и символ верхнего регистра 
* и закончить на `.txt`


### Комбинирование подстановочных знаков

Подстановочные знаки можно комбинировать следующим образом:

```console
$ ls
last.txt    lest.txt    list.txt    third.txt   past.txt
$ ls [plf]?st* 
list.txt    last.txt    past.txt
```

Первый компонент подстановочного знака (`[plf]`) соответствует любому из символов `p`, `l` или `f`. Второй компонент подстановочного знака (`?`) Соответствует любому одиночному символу. Третий компонент подстановочного знака (`*`) соответствует нулю, одному или нескольким вхождениям любого символа. 

Существуют и другие подстановочные знаки, такие как подстановочный знак плюс (`+`), который используется для представления символа(ов), который встречается один или несколько раз:

```console
$ ls
file1.txt file.txt file23.txt fisher.txt fom23.txt
$ ls f*[0-9]+.txt
file1.txt file23.txt fom23.txt
```

Предыдущая команда отображает все файлы, которые начинаются с буквы `f`, за которой следует любой набор букв, по крайней мере, одно вхождение цифры и заканчивается на `.txt`. Обратите внимание, что файл `file.txt` не отображается, поскольку он не соответствует этому критерию.


## Упражнения для закрепления



## Упражнения на размышление



## Резюме




## Ответы на упражнения для закрепления


## Ответы на упражнения для размышления
