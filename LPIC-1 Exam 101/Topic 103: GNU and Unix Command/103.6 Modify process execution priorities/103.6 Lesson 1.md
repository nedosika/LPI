# 103.6 Урок 1

| Сертификат:   | LPIC-1                                      |
|:--------------|:--------------------------------------------|
| Версия:       | 5.0                                         |
| Тема:         | 103 GNU и Unix комманды                     |                           
| Цель:         | 103.6 Изменение приоритета выполнения процессов |
| Урок:         | 1 из 1                                      |


# Введение

Операционные системы, способные запускать более одного процесса одновременно, называются многозадачными или мультипроцессными системами. Хотя настоящая многозадачность возникает только тогда, когда доступно более одного процессора, даже однопроцессорные системы могут имитировать многозадачность, очень быстро переключаясь между процессами. Этот метод также используется в системах с множеством эквивалентных процессоров или *симметричных многопроцессорных (SMP)* системах, учитывая, что количество потенциальных параллельных процессов значительно превышает количество доступных процессоров.

Фактически, только один процесс одновременно может управлять процессором. Однако большинство действий процесса являются системными вызовами, то есть выполняющийся процесс передает управление процессором процессу операционной системы, поэтому он выполняет запрошенную операцию. Системные вызовы отвечают за всю связь между устройствами, такую как распределение памяти, чтение и запись в файловых системах, печать текста на экране, взаимодействие с пользователем, сетевые передачи и т. д. Передача управления процессором во время системного вызова позволяет операционной системе решать, следует ли вернуть управление процессором предыдущему процессу или передать его другому процессу. Поскольку современные ЦП могут выполнять инструкции намного быстрее, чем большинство внешних устройств взаимодействуют друг с другом, новый процесс может занять большую часть процессорного времени, пока предыдущие запрошенные аппаратные ресурсы не освободятся. Чтобы обеспечить максимальное использование ЦП, многозадачные операционные системы поддерживают динамическую очередь активных процессов, ожидающих процессорное время.

Хотя они позволяют значительно улучшить использование процессорного времени, полагаться только на системные вызовы для переключения между процессами недостаточно для достижения удовлетворительной производительности многозадачности. Процесс, не выполняющий системных вызовов, может бесконечно управлять процессором. Вот почему современные операционные системы также являются вытесняющими, то есть выполняемый процесс может быть снова помещен в очередь, чтобы более важный процесс мог управлять ЦП, даже если выполняющийся процесс не сделал системного вызова.


# Планировщик Linux

Linux, как операционная система с вытеснительной многопроцессорной обработкой, реализует планировщик организующий очередь процессов. Точнее, планировщик также решает, какой *поток* в очереди будет выполняться - процесс может разветвляться на множество независимых потоков, но процесс и поток в этом контексте являются взаимозаменяемыми терминами. У каждого процесса есть два свойства, которые влияют на его планирование: *политика планирования* и *приоритет планирования*.

Существует два основных типа политик планирования: *политики реального времени* и *обычные политики*. Процессы в рамках политики реального времени планируются напрямую по их значениям приоритета. Если более важный процесс становится готовым к запуску, менее важный выполняемый процесс вытесняется, и процесс с более высоким приоритетом берет на себя управление ЦП. Процесс с более низким приоритетом получит управление ЦП, только если процессы с более высоким приоритетом простаивают или ждут ответа оборудования.

Любой процесс реального-времени имеет более высокий приоритет, чем обычный процесс. Как операционная система общего назначения Linux выполняет всего несколько процессов в реальном времени. Большинство процессов, включая системные и пользовательские программы, выполняются в соответствии с обычными политиками планирования. Нормальные процессы обычно имеют одинаковое значение приоритета, но нормальные политики могут определять правила приоритета выполнения, используя другой предикат процесса: *nice value*. Чтобы избежать путаницы с динамическими приоритетами, полученными из *nice value*, приоритеты планирования обычно называются приоритетами *статического* планирования.

Планировщик Linux можно настроить по-разному, и существуют даже более сложные способы установки приоритетов, но эти общие концепции применимы всегда. При проверке и настройке планирования процессов важно помнить, что это повлияет только на процессы, выполняемые в рамках обычной политики планирования.

## Просмотр приоритетов

Linux резервирует статические приоритеты в диапазоне от 0 до 99 для процессов реального времени, а нормальным процессам присваиваются статические приоритеты в диапазоне от 100 до 139, что означает, что для обычных процессов существует 39 различных уровней приоритета. Меньшие значения означают более высокий приоритет. Статический приоритет активного процесса можно найти в `sched` файле, расположенном в соответствующем каталоге внутри файловой системы `/proc`:
```
$ grep ^prio /proc/1/sched
prio                   :       120
```

Как показано в примере, строка, начинающаяся с `prio`, дает значение приоритета процесса (процесс `PID 1` - это процесс *init* или *systemd*, первый процесс, который ядро запускает во время инициализации системы). Стандартный приоритет для обычных процессов - `120`, поэтому его можно уменьшить до `100` или увеличить до `139`. Приоритеты всех запущенных процессов можно проверить с помощью команды `ps -Al` или `ps -el`:
```console
$ ps -el
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0     1     0  0  80   0 -  9292 -      ?        00:00:00 systemd
4 S     0    19     1  0  80   0 -  8817 -      ?        00:00:00 systemd-journal
4 S   104    61     1  0  80   0 - 64097 -      ?        00:00:00 rsyslogd
4 S     0    63     1  0  80   0 -  7244 -      ?        00:00:00 cron
1 S     0   126     1  0  80   0 -  4031 -      ?        00:00:00 dhclient
4 S     0   154     1  0  80   0 -  3937 -      pts/0    00:00:00 agetty
4 S     0   155     1  0  80   0 -  3937 -      pts/1    00:00:00 agetty
4 S     0   156     1  0  80   0 -  3937 -      pts/2    00:00:00 agetty
4 S     0   157     1  0  80   0 -  3937 -      pts/3    00:00:00 agetty
4 S     0   158     1  0  80   0 -  3937 -      console  00:00:00 agetty
4 S     0   160     1  0  80   0 - 16377 -      ?        00:00:00 sshd
4 S     0   280     0  0  80   0 -  5301 -      ?        00:00:00 bash
0 R     0   392   280  0  80   0 -  7221 -      ?        00:00:00 ps
```

Столбец `PRI` указывает статический приоритет, назначенный ядром. Однако обратите внимание, что значение приоритета, отображаемое `ps`, отличается от значения, полученного в предыдущем примере. По историческим причинам, приоритеты, отображаемые `ps`, по умолчанию находятся в диапазоне от `-40` до `99`, поэтому фактический приоритет получается добавлением к нему `40`(в частности, 80 + 40 = 120).

Также можно постоянно отслеживать процессы, которыми в настоящее время управляет ядро Linux, с помощью программы `top`. Как и в случае с `ps`, `top` также по-другому отображает значение приоритета. Чтобы упростить идентификацию процессов в реальном времени, `top` уменьшает значение приоритета на 100, тем самым делая все приоритеты в реальном времени отрицательными, а их идентифицирует отрицательное число или `rt`. Таким образом, обычные приоритеты отображаются верхним диапазоном от 0 до 39.

> Чтобы получить более подробную информацию о команде `ps`, можно использовать дополнительные параметры. Сравните вывод этой команды с выводом из нашего предыдущего примера:  
```console 
$ ps -e -o user,uid,comm,tty,pid,ppid,pri,pmem,pcpu --sort=-pcpu | head
```
