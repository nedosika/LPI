# 103.6 Урок 1

| Сертификат:   | LPIC-1                                      |
|:--------------|:--------------------------------------------|
| Версия:       | 5.0                                         |
| Тема:         | 103 GNU и Unix комманды                     |                           
| Цель:         | 103.6 Изменение приоритета выполнения процессов |
| Урок:         | 1 из 1                                      |


# Введение

Операционные системы, способные запускать более одного процесса одновременно, называются многозадачными или многопроцессорными системами. Хотя настоящая многозадачность возникает только тогда, когда доступно более одного процессора, даже однопроцессорные системы могут имитировать многозадачность, очень быстро переключаясь между процессами. Учитывая, что потенциально возможное количество параллельных процессов значительно превышает количество доступных процессоров, то этот метод также используется и в системах с несколькими процессорами или *симметричных многопроцессорных системах(SMP)*.

Фактически, только один процесс одновременно может управлять процессором. Однако, большинство действий процесса являются *системными вызовами*, то есть выполняющийся процесс передает управление CPU процессу операционной системы, поэтому он выполняет запрошенную операцию. Системные вызовы отвечают за всю связь между устройствами, такую как распределение памяти, чтение и запись в файловых системах, выаод текста на экране, взаимодействие с пользователем, передча информации по сети и т. д. Передача управления процессором во время системного вызова позволяет операционной системе решать, следует ли вернуть управление процессором предыдущему процессу или передать управление другому процессу. Поскольку современные CPU могут выполнять инструкции намного быстрее, чем большинство внешних устройств взаимодействуют друг с другом, новый процесс может занять большую часть процессорного времени, пока предыдущие запрошенные аппаратные ресурсы не освободятся. Чтобы обеспечить максимальное использование CPU, многозадачные операционные системы поддерживают динамическую очередь активных процессов, ожидающих процессорное время.

Хотя системные вызовы и позволяют значительно улучшить использование процессорного времени, полагаться только на них для переключения между процессами недостаточно для достижения достаточной производительности многопоточности. Процесс, не выполняющий системных вызовов, может бесконечно управлять процессором. Вот почему современные операционные системы, также называемые *вытесняющими*, то есть даже если выполняющийся процесс не делал системного вызова, он может быть снова помещен в очередь, чтобы более важный процесс мог управлять CPU.


# Планировщик Linux

Linux, как операционная система с вытеснительной многопроцессорной обработкой, реализует планировщик, который организует очередь процессов. Точнее, планировщик также решает, какой *поток* в очереди будет выполняться - процесс может разветвляться на множество независимых потоков, но процесс и поток в этом контексте являются взаимозаменяемыми терминами. У каждого процесса есть две характеристики, которые влияют на его планирование: *политика планирования* и *приоритет планирования*.

Существует два основных типа политик планирования: *политики реального времени* и *стандартные политики*. Процессы в рамках политики реального времени управляются планировщиком напрямую по их значениям приоритета. Если более приоритетный процесс становится готовым к запуску, менее приоритетный процесс вытесняется, и процесс с более высоким приоритетом берет на себя управление CPU. Процесс с более низким приоритетом получит управление CPU, только если процессы с более высоким приоритетом простаивают или ждут ответа оборудования.

Любой процесс реального-времени имеет более высокий приоритет, чем обычный процесс. Как операционная система общего назначения Linux выполняет всего несколько процессов в реальном времени. Большинство процессов, включая системные и пользовательские программы, выполняются в соответствии со стандартными политиками планирования. Обычные процессы восновном обладают одинаковым значением приоритета, но стандартные политики могут устанавливать правила приоритета выполнения, используя другую характеристику процесса: *фактор уступчивости*. Чтобы избежать путаницы с динамическими приоритетами, полученными от фактора уступчивости, приоритеты планирования обычно называются *статическими* приоритетами планирования.

Планировщик Linux можно настроить по-разному и существут даже еще более сложные методы настройки приоритетов, но общие концепции применимы всегда. При проверке и настройке планирования процессов важно помнить, что это повлияет только на процессы, выполняемые в рамках стандартной политики планирования.

## Просмотр приоритетов

В Linux для процессов реального времени зарезервированы статические приоритеты в диапазоне от 0 до 99, а нормальным процессам присваиваются статические приоритеты в диапазоне от 100 до 139, это означает, что для обычных процессов существует 39 различных уровней приоритета. Чем меньше значение тем более высокий приоритет. Статический приоритет активного процесса можно найти в `sched` файле, расположенном в соответствующем каталоге внутри файловой системы `/proc`:
```
$ grep ^prio /proc/1/sched
prio                   :       120
```

Как показано в примере, строка, начинающаяся с `prio`, дает значение приоритета процесса(процесс `PID 1` - это процесс *init* или *systemd*, первый процесс, который ядро запускает во время инициализации системы). Стандартный приоритет для обычных процессов - `120`, поэтому его можно уменьшить до `100` или увеличить до `139`. Приоритеты всех запущенных процессов можно проверить с помощью команды `ps -Al` или `ps -el`:
```console
$ ps -el
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0     1     0  0  80   0 -  9292 -      ?        00:00:00 systemd
4 S     0    19     1  0  80   0 -  8817 -      ?        00:00:00 systemd-journal
4 S   104    61     1  0  80   0 - 64097 -      ?        00:00:00 rsyslogd
4 S     0    63     1  0  80   0 -  7244 -      ?        00:00:00 cron
1 S     0   126     1  0  80   0 -  4031 -      ?        00:00:00 dhclient
4 S     0   154     1  0  80   0 -  3937 -      pts/0    00:00:00 agetty
4 S     0   155     1  0  80   0 -  3937 -      pts/1    00:00:00 agetty
4 S     0   156     1  0  80   0 -  3937 -      pts/2    00:00:00 agetty
4 S     0   157     1  0  80   0 -  3937 -      pts/3    00:00:00 agetty
4 S     0   158     1  0  80   0 -  3937 -      console  00:00:00 agetty
4 S     0   160     1  0  80   0 - 16377 -      ?        00:00:00 sshd
4 S     0   280     0  0  80   0 -  5301 -      ?        00:00:00 bash
0 R     0   392   280  0  80   0 -  7221 -      ?        00:00:00 ps
```

Столбец `PRI` указывает статический приоритет, назначенный ядром. Однако обратите внимание, что значение приоритета, отображаемое `ps`, отличается от значения, полученного в предыдущем примере. По историческим причинам, приоритеты, отображаемые `ps`, по умолчанию находятся в диапазоне от -40 до 99, поэтому фактический приоритет получается добавлением к нему 40(в частности, 80 + 40 = 120).

Также можно постоянно отслеживать процессы, которыми в настоящее время управляет ядро Linux, с помощью программы `top`. Как и в случае с `ps`, `top` также по-другому отображает значение приоритета. Чтобы упростить идентификацию процессов в реальном времени, `top` уменьшает значение приоритета на 100, тем самым делая все приоритеты в реальном времени отрицательными, связывая их с отрицательным числом или `rt`. Таким образом, обычные приоритеты отображаются `top` в диапазоне от 0 до 39.

> Для получения более подробной информации от команды `ps`, можно использовать дополнительные параметры. Сравните вывод этой команды с выводом из нашего предыдущего примера:  
> ```console
> $ ps -e -o user,uid,comm,tty,pid,ppid,pri,pmem,pcpu --sort=-pcpu | head
> ```
