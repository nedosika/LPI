# 103.6 Урок 1

| Сертификат:   | LPIC-1                                      |
|:--------------|:--------------------------------------------|
| Версия:       | 5.0                                         |
| Тема:         | 103 GNU и Unix комманды                     |                           
| Цель:         | 103.6 Изменение приоритета выполнения процессов |
| Урок:         | 1 из 1                                      |


# Введение

Операционные системы, способные запускать более одного процесса одновременно, называются многозадачными или многопроцессорными системами. Хотя настоящая многозадачность возникает только тогда, когда доступно более одного процессора, даже однопроцессорные системы могут имитировать многозадачность, очень быстро переключаясь между процессами. Учитывая, что потенциально возможное количество параллельных процессов значительно превышает количество доступных процессоров, то этот метод также используется и в системах с несколькими процессорами или *симметричных многопроцессорных системах(SMP)*.

Фактически, только один процесс одновременно может управлять процессором. Однако, большинство действий процесса являются *системными вызовами*, то есть выполняющийся процесс передает управление CPU процессу операционной системы, поэтому он выполняет запрошенную операцию. Системные вызовы отвечают за всю связь между устройствами, такую как распределение памяти, чтение и запись в файловых системах, выаод текста на экране, взаимодействие с пользователем, передча информации по сети и т. д. Передача управления процессором во время системного вызова позволяет операционной системе решать, следует ли вернуть управление процессором предыдущему процессу или передать управление другому процессу. Поскольку современные CPU могут выполнять инструкции намного быстрее, чем большинство внешних устройств взаимодействуют друг с другом, новый процесс может занять большую часть процессорного времени, пока предыдущие запрошенные аппаратные ресурсы не освободятся. Чтобы обеспечить максимальное использование CPU, многозадачные операционные системы поддерживают динамическую очередь активных процессов, ожидающих процессорное время.

Хотя системные вызовы и позволяют значительно улучшить использование процессорного времени, полагаться только на них для переключения между процессами недостаточно для достижения достаточной производительности многопоточности. Процесс, не выполняющий системных вызовов, может бесконечно управлять процессором. Вот почему современные операционные системы, также называемые *вытесняющими*, то есть даже если выполняющийся процесс не делал системного вызова, он может быть снова помещен в очередь, чтобы более важный процесс мог управлять CPU.


# Планировщик Linux

Linux, как операционная система с вытеснительной многопроцессорной обработкой, реализует планировщик, который организует очередь процессов. Точнее, планировщик также решает, какой *поток* в очереди будет выполняться - процесс может разветвляться на множество независимых потоков, но процесс и поток в этом контексте являются взаимозаменяемыми терминами. У каждого процесса есть две характеристики, которые влияют на его планирование: *политика планирования* и *приоритет планирования*.

Существует два основных типа политик планирования: *политики реального времени* и *стандартные политики*. Процессы в рамках политики реального времени управляются планировщиком напрямую по их значениям приоритета. Если более приоритетный процесс становится готовым к запуску, менее приоритетный процесс вытесняется, и процесс с более высоким приоритетом берет на себя управление CPU. Процесс с более низким приоритетом получит управление CPU, только если процессы с более высоким приоритетом простаивают или ждут ответа оборудования.

Любой процесс реального-времени имеет более высокий приоритет, чем обычный процесс. Как операционная система общего назначения Linux выполняет всего несколько процессов в реальном времени. Большинство процессов, включая системные и пользовательские программы, выполняются в соответствии со стандартными политиками планирования. Обычные процессы восновном обладают одинаковым значением приоритета, но стандартные политики могут устанавливать правила приоритета выполнения, используя другую характеристику процесса: *фактор уступчивости*. Чтобы избежать путаницы с динамическими приоритетами, полученными от фактора уступчивости, приоритеты планирования обычно называются *статическими* приоритетами планирования.

Планировщик Linux можно настроить по-разному и существут даже еще более сложные методы настройки приоритетов, но общие концепции применимы всегда. При проверке и настройке планирования процессов важно помнить, что это повлияет только на процессы, выполняемые в рамках стандартной политики планирования.

## Просмотр приоритетов

В Linux для процессов реального времени зарезервированы статические приоритеты в диапазоне от 0 до 99, а нормальным процессам присваиваются статические приоритеты в диапазоне от 100 до 139, это означает, что для обычных процессов существует 39 различных уровней приоритета. Чем меньше значение тем более высокий приоритет. Статический приоритет активного процесса можно найти в `sched` файле, расположенном в соответствующем каталоге внутри файловой системы `/proc`:
```
$ grep ^prio /proc/1/sched
prio                   :       120
```

Как показано в примере, строка, начинающаяся с `prio`, дает значение приоритета процесса(процесс `PID 1` - это процесс *init* или *systemd*, первый процесс, который ядро запускает во время инициализации системы). Стандартный приоритет для обычных процессов - `120`, поэтому его можно уменьшить до `100` или увеличить до `139`. Приоритеты всех запущенных процессов можно проверить с помощью команды `ps -Al` или `ps -el`:
```console
$ ps -el
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0     1     0  0  80   0 -  9292 -      ?        00:00:00 systemd
4 S     0    19     1  0  80   0 -  8817 -      ?        00:00:00 systemd-journal
4 S   104    61     1  0  80   0 - 64097 -      ?        00:00:00 rsyslogd
4 S     0    63     1  0  80   0 -  7244 -      ?        00:00:00 cron
1 S     0   126     1  0  80   0 -  4031 -      ?        00:00:00 dhclient
4 S     0   154     1  0  80   0 -  3937 -      pts/0    00:00:00 agetty
4 S     0   155     1  0  80   0 -  3937 -      pts/1    00:00:00 agetty
4 S     0   156     1  0  80   0 -  3937 -      pts/2    00:00:00 agetty
4 S     0   157     1  0  80   0 -  3937 -      pts/3    00:00:00 agetty
4 S     0   158     1  0  80   0 -  3937 -      console  00:00:00 agetty
4 S     0   160     1  0  80   0 - 16377 -      ?        00:00:00 sshd
4 S     0   280     0  0  80   0 -  5301 -      ?        00:00:00 bash
0 R     0   392   280  0  80   0 -  7221 -      ?        00:00:00 ps
```

Столбец `PRI` указывает статический приоритет, назначенный ядром. Однако обратите внимание, что значение приоритета, отображаемое `ps`, отличается от значения, полученного в предыдущем примере. По историческим причинам, приоритеты, отображаемые `ps`, по умолчанию находятся в диапазоне от -40 до 99, поэтому фактический приоритет получается добавлением к нему 40(в частности, 80 + 40 = 120).

Также можно постоянно отслеживать процессы, которыми в настоящее время управляет ядро Linux, с помощью программы `top`. Как и в случае с `ps`, `top` также по-другому отображает значение приоритета. Чтобы упростить идентификацию процессов в реальном времени, `top` уменьшает значение приоритета на 100, тем самым делая все приоритеты в реальном времени отрицательными, связывая их с отрицательным числом или `rt`. Таким образом, обычные приоритеты отображаются `top` в диапазоне от 0 до 39.

> Для получения более подробной информации от команды `ps`, можно использовать дополнительные параметры. Сравните вывод этой команды с выводом из нашего предыдущего примера:  
> ```console
> $ ps -e -o user,uid,comm,tty,pid,ppid,pri,pmem,pcpu --sort=-pcpu | head
> ```

## Изменение приоритета(фактора уступчивости) процессов

Каждый нормальный процесс начинается со значения фактора уступчивости по умолчанию, равного 0(приоритет 120). Название `nice` происходит от идеи, что более уступчивые процессы позволяют другим процессам запускаться перед ними в определенной очереди выполнения. Фактор уступчивости варьируется от -20 (менее уступчивый, высокий приоритет) до 19 (более "уступчивый, низкий приоритет). Linux также позволяет назначать разные значения фактора уступчивости потокам в рамках одного процесса. Столбец `NI` в выводе `ps` указывает на `фактор уступчивости`. 

Только пользователь root может снизить фактор уступчивости процесса ниже нуля. Можно запустить процесс с нестандартным приоритетом с помощью команды `nice`. По умолчанию `nice` меняет фактор уступчивости на 10, но его можно и указать с помощью параметра `-n`:
```console
$ nice -n 15 tar czf home_backup.tar.gz /home
```
В этом примере команда `tar` выполняется со значением фактора уступчивости равным 15. Команда `renice` может использоваться для изменения приоритета запущенного процесса. Параметр `-p` указывает значение PID целевого процесса. Например:
```console
# renice -10 -p 2164
2164 (process ID) old priority 0, new priority -10
```
Параметры `-g` и `-u` используются для изменения всех процессов определенной группы или пользователя соответственно. С помощью `renice +5 -g users` приоритет процессов, принадлежащих пользователям группы `users`, будет увеличено на пять. Помимо `renice`, приоритет процессов может быть изменен другими программами, например, программой `top`. На главном экране `top` можно изменить приоритет процесса, нажав `r`, а затем указать значение PID процесса:
```console
top - 11:55:21 up 23:38,  1 user,  load average: 0,10, 0,04, 0,05
Tasks:  20 total,   1 running,  19 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0,5 us,  0,3 sy,  0,0 ni, 99,0 id,  0,0 wa,  0,2 hi,  0,0 si,  0,0 st
KiB Mem :  4035808 total,   774700 free,  1612600 used,  1648508 buff/cache
KiB Swap:  7999828 total,  7738780 free,   261048 used.  2006688 avail Mem
PID to renice [default pid = 1]
  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
    1 root      20   0   74232   7904   6416 S 0,000 0,196   0:00.12 systemd
   15 root      20   0   67436   6144   5568 S 0,000 0,152   0:00.03 systemd-journal
   21 root      20   0   61552   5628   5000 S 0,000 0,139   0:00.01 systemd-logind
   22 message+  20   0   43540   4072   3620 S 0,000 0,101   0:00.03 dbus-daemon
   23 root      20   0   45652   6204   4992 S 0,000 0,154   0:00.06 wickedd-dhcp4
   24 root      20   0   45648   6276   5068 S 0,000 0,156   0:00.06 wickedd-auto4
   25 root      20   0   45648   6272   5060 S 0,000 0,155   0:00.06 wickedd-dhcp6
```
Появляется сообщение `PID to renice [default pid = 1]` с выбранным по умолчанию первым процессом из списка. Чтобы изменить приоритет другого процесса, введите его PID и нажмите Enter. Затем появится сообщение `Renice PID 1 to value` (с запрошенным номером PID), и можно будет присвоить новое значение nice.


# Упражнения для закрепления

1. Что происходит в многозадачной системе с вытеснением, когда процесс с более низким приоритетом занимает процессор, а процесс с более высоким приоритетом ставится в очередь на выполнение?
2. Рассмотрим следующий экран `top`:
```console
top - 08:43:14 up 23 days, 12:29,  5 users,  load average: 0,13, 0,18, 0,21
Tasks: 240 total,   2 running, 238 sleeping,   0 stopped,   0 zombie
%Cpu(s):  1,4 us,  0,4 sy,  0,0 ni, 98,1 id,  0,0 wa,  0,0 hi,  0,0 si,  0,0 st
MiB Mem :   7726,4 total,    590,9 free,   1600,8 used,   5534,7 buff/cache
MiB Swap:  30517,0 total,  30462,5 free,     54,5 used.   5769,4 avail Mem

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
    1 root      20   0  171420  10668   7612 S   0,0   0,1   9:59.15 systemd
    2 root      20   0       0      0      0 S   0,0   0,0   0:02.76 kthreadd
    3 root       0 -20       0      0      0 I   0,0   0,0   0:00.00 rcu_gp
    4 root       0 -20       0      0      0 I   0,0   0,0   0:00.00 rcu_par_gp
    8 root       0 -20       0      0      0 I   0,0   0,0   0:00.00 mm_percpu_wq
    9 root      20   0       0      0      0 S   0,0   0,0   0:49.06 ksoftirqd/0
   10 root      20   0       0      0      0 I   0,0   0,0  18:24.20 rcu_sched
   11 root      20   0       0      0      0 I   0,0   0,0   0:00.00 rcu_bh
   12 root      rt   0       0      0      0 S   0,0   0,0   0:08.17 migration/0
   14 root      20   0       0      0      0 S   0,0   0,0   0:00.00 cpuhp/0
   15 root      20   0       0      0      0 S   0,0   0,0   0:00.00 cpuhp/1
   16 root      rt   0       0      0      0 S   0,0   0,0   0:11.79 migration/1
   17 root      20   0       0      0      0 S   0,0   0,0   0:26.01 ksoftirqd/1
```
Какие PID имеют приоритеты в реальном времени?
3. Рассмотрим следующий листинг `ps -el`:
```console
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0     1     0  0  80   0 - 42855 -      ?        00:09:59 systemd
1 S     0     2     0  0  80   0 -     0 -      ?        00:00:02 kthreadd
1 I     0     3     2  0  60 -20 -     0 -      ?        00:00:00 rcu_gp
1 S     0     9     2  0  80   0 -     0 -      ?        00:00:49 ksoftirqd/0
1 I     0    10     2  0  80   0 -     0 -      ?        00:18:26 rcu_sched
1 I     0    11     2  0  80   0 -     0 -      ?        00:00:00 rcu_bh
1 S     0    12     2  0 -40   - -     0 -      ?        00:00:08 migration/0
1 S     0    14     2  0  80   0 -     0 -      ?        00:00:00 cpuhp/0
5 S     0    15     2  0  80   0 -     0 -      ?        00:00:00 cpuhp/1
```
Какой PID имеет более высокий приоритет?
4. После попытки переименовать процесс с помощью renice возникает следующая ошибка:
```console
$ renice -10 21704
renice: failed to set priority for 21704 (process ID): Permission denied
```
Какова вероятная причина ошибки?


# Упражнения на размышление




# Резюме




# Ответы на упражнения для закрепления


# Ответы на упражнения для размышления
