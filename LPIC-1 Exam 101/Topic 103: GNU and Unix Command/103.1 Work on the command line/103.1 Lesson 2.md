# 103.1 Урок 1

| **Сертификат:** | LPIC-1                                    |
|:----------------|:------------------------------------------|
| **Версия:**     | 5.0                                       |
| **Тема:**       | 103 Команды GNU и Unix                    |
| **Цель:**       | 103.1 Работа в командной строке           |
| **Урок:**       | 2 из 2                                    |


## Введение

Среда операционной системы включает в себя основные инструменты, такие как оболочки командной строки и иногда графический интерфейс, которые вам понадобятся для выполнения работы. Но ваша среда также будет поставляться с каталогом ярлыков и предустановленных значений. Здесь мы узнаем, как составлять список, вызывать и управлять этими значениями.


## Поиск переменных среды

Так как же нам определить текущие значения всех переменных среды? Один из способов - использовать команду `env`:

```console
$ env
DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus
XDG_RUNTIME_DIR=/run/user/1000
XAUTHORITY=/run/user/1000/gdm/Xauthority
XDG_CONFIG_DIRS=/etc/xdg/xdg-ubuntu:/etc/xdg
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
GJS_DEBUG_TOPICS=JS ERROR;JS LOG
[...]
```

Вы получите много результатов - намного больше, чем то, что включено в приведенный выше отрывок. Но пока обратите внимание на запись `PATH`, которая содержит каталоги, в которых ваша оболочка (и другие программы) будет искать другие программы без необходимости указывать полный путь. С этим набором вы можете запустить двоичную программу, которая находится, скажем, в `/usr/local/bin` из вашего домашнего каталога, и она будет работать так же, как если бы файл был локальным. 

Давайте ненадолго сменим тему. Команда `echo` выведет на экран все, что вы ей скажете. Вы не поверите, но будет много раз, когда `echo`, буквально повтори что-то, будет вам очень полезна.

```console
$ echo "Hi. How are you?"
Hi. How are you?
```

Но есть еще кое-что, что вы можете сделать с `echo`. Когда вы вводите в него имя переменной окружения и сообщаете ему, что это переменная, добавляя к имени переменной префикс `$`, то вместо того, чтобы просто печатать имя переменной, оболочка расширяет его, давая вам значение. Не уверены, находится ли ваш любимый каталог в пути? Вы можете быстро проверить, запустив его через `echo`:

```console
$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
```


## Создание новых переменных среды

Вы можете добавить свои собственные пользовательские переменные в свою среду. Самый простой способ - использовать символ `=`. Строка слева будет именем вашей новой переменной, а строка справа будет ее значением. Теперь вы можете передать имя переменной в `echo`, чтобы убедиться, что она работает:

```console
$ myvar=hello
$ echo $myvar
hello
```

>Обратите внимание, что во время присвоения переменной нет пробелов по обе стороны от знака равенства.

Но действительно ли это сработало? Наберите `bash` в терминале, чтобы открыть новую оболочку. Эта новая оболочка выглядит точно так же, как та, в которой вы только что были, но на самом деле она является *потомком* исходной оболочки (которую мы называем *родительской*). Теперь внутри этой новой дочерней оболочки попытайтесь заставить `echo` творить чудеса, как это было раньше. Ничего такого. Что происходит?

```console
$ bash
$ echo $myvar

$
```

Переменная, которую вы создаете так, как мы только что сделали, будет доступна только локально - в рамках непосредственного сеанса оболочки. Если вы запустите новую оболочку или закроете сеанс с помощью `exit`, переменная не будет работать с вами. Если ввести здесь `exit`, вы вернетесь в исходную родительскую оболочку, которая сейчас находится именно там, где мы хотим быть. Вы можете запустить `echo $myvar` еще раз, если хотите просто подтвердить, что переменная все еще действительна. Теперь введите `export myvar`, чтобы передать переменную любым дочерним оболочкам, которые вы можете впоследствии открыть. Попробуйте: введите `bash` для новой оболочки и затем `echo`:

```console
$ exit
$ export myvar
$ bash
$ echo $myvar
hello
```

Все это может показаться немного глупым, когда мы создаем оболочки без реальной цели. Но понимание того, как переменные оболочки распространяются в вашей системе, станет очень важным, когда вы начнете писать серьезные сценарии.


## Удаление переменных среды

Хотите узнать, как очистить все созданные вами эфемерные переменные? Один из способов - просто закрыть родительскую оболочку или перезагрузить компьютер. Но есть способы попроще. Как, например, `unset`. Ввод `unset` (без `$`) приведет к уничтожению переменной. `echo` теперь докажет это.

```console
$ unset myvar
$ echo $myvar

$
```

Если есть команда `unset`, то вы можете поспорить, что для нее должна быть команда `set`. Запуск `set` сам по себе будет отображать много вывода, но на самом деле он не так уж сильно отличается от того, что вам дал `env`. Посмотрите на первую строку вывода, которую вы получите при фильтрации по `PATH`:

```console
$ set | grep PATH
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
[...]
```

В чем разница между `set` и `env`? Для наших целей главное, чтобы `set` выводил все переменные и функции. Давайте проиллюстрируем это. Мы создадим новую переменную `mynewvar` и подтвердим ее наличие:

```console
$ mynewvar=goodbye
$ echo $mynewvar
goodbye
```

Теперь выполнение `env` при использовании `grep` для фильтрации строки `mynewvar` не будет отображать никаких выходных данных. Но запуск `set` таким же образом покажет нам нашу локальную переменную.

```console
$ env | grep mynewvar

$ set | grep mynewvar
mynewvar=goodbye
```


## Цитирование для экранирования специальных символов

Сейчас самое подходящее время, чтобы познакомить вас с проблемой специальных символов. Буквенно-цифровые символы (a-z и 0-9) обычно читаются Bash буквально. Если вы попытаетесь создать новый файл с именем `myfile`, вы просто наберете `touch`, а затем `myfile`, и Bash будет знать, что с ним делать. Но если вы хотите включить в свое имя файла специальный символ, вам нужно будет немного поработать. 

Чтобы проиллюстрировать это, мы введем `touch` и последуем за ним заголовком: `my big file`. Проблема в том, что между словами, которые интерпретирует Bash, есть два пробела. Хотя технически вы не стали бы называть пробел «символом», он подобен таковому в том смысле, что Bash не будет читать его буквально. Если вы укажете содержимое вашего текущего каталога, а не один файл с именем `my big file`, вы увидите три файла с именами, соответственно, `my`, `big` и `file`. Это потому, что Bash думал, что вы хотите создать несколько файлов, имена которых вы передавали в списке:

```console
$ touch my big file
$ ls
my big file
```

Пробелы будут интерпретироваться одинаково, если вы удалите (`rm`) все три файла одной командой:

```console
$ rm my big file
```

А теперь давайте попробуем правильно. Введите `touch` и три части имени файла, но на этот раз заключите имя в кавычки. На этот раз это сработало. Перечисление содержимого каталога покажет вам один файл с правильным именем.

```console
$ touch "my big file"
$ ls
'my big file'
```

Есть и другие способы добиться того же эффекта. Например, одинарные кавычки работают так же хорошо, как двойные кавычки. (Обратите внимание, что одинарные кавычки сохранят буквальное значение всех символов, а двойные кавычки сохранят все символы, кроме `$`, ` ` `, `\` и, в некоторых случаях, `!`.)

```console
$ rm 'my big file'
```

Добавление перед каждым специальным символом обратной косой черты «ускользнет» от особенностей символа и заставит Bash читать его буквально.

```console
$ touch my\ big\ file
```
