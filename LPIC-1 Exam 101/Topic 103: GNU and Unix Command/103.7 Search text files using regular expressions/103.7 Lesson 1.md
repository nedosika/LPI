# 103.7 Урок 1

| **Сертификат:** | LPIC-1                                      |
|:----------------|:--------------------------------------------|
| **Версия:**     | 5.0                                         |
| **Тема:**       | 103 GNU и Unix комманды                     |                           
| **Цель:**       | 103.6 Поиск текстовых файлов с помощью регулярных выражений |
| **Урок:**       | 1 из 2                                      |


# Введение

Алгоритмы поиска строк широко используются во многих задачах обработки данных, настолько, что у Unix-подобных операционных систем есть собственная повсеместная реализация: *регулярные выражения*, часто сокращаемые до *RE*. Регулярные выражения состоят из последовательностей символов, составляющих общий шаблон, используемый для поиска и иногда изменения соответствующей последовательности в более крупной строке символов. Регулярные выражения значительно расширяют возможности: 

* Написания правил парсинга для запросов на HTTP-серверах, в частности, в *nginx*. 
* Написания скриптов, преобразующих текстовые наборы данных в другой формат. 
* Посике интересующих вас вхождений в журнальных записях или документах. 
* Фильтрации разметки документов, сохраняя семантическое содержание. 

Самое простое регулярное выражение содержит хотя бы один *атом*. Атом, названный так потому, что он является основным элементом регулярного выражения, - это просто символ, который может иметь или не иметь особое значение. Большинство обычных символов однозначны, они сохраняют свое буквальное значение, в то время как другие имеют особое значение: 

`.` (точка)  
Атом соответствует любому символу. 

`^` (каретка)  
Атом совпадает с началом строки. 

`$` (знак доллара)  
Атом соответствует концу строки. 

Например, регулярное выражение `bc`, составленное из буквальных атомов `b` и `c`, можно найти в строке `abcd`, но не в строке `a1cd`. С другой стороны, регулярное выражение `.c` можно найти в обеих строках `abcd` и `a1cd` в виде точки `.` соответствует любому символу. 

Атомы со знаком каретки и доллара используются, когда интерес представляют только совпадения в начале или в конце строки. По этой причине их еще называют якорями. Например, `cd` можно найти в `abcd`, а `^ cd` - нет. Точно так же `ab` можно найти в `abcd`, а `ab$` - нет. Каретка `^` - это буквальный символ, кроме тех случаев, когда он стоит в начале, а `$` - буквальный символ, кроме тех случаев, когда он находится в конце регулярного выражения.


## Выражение в скобках

Есть еще один тип атома - *выражение в скобках*. Хотя это не один символ, квадратные скобки `[]` (включая их содержимое) считаются одним атомом. Выражение в квадратных скобках обычно представляет собой просто список буквальных символов, заключенных в `[]`, благодаря чему атом соответствует любому одиночному символу из списка. Например, выражение `[1b]` можно найти в обеих строках `abcd` и `a1cd`. Чтобы указать символы, которым не должен соответствовать атом, список должен начинаться с символа `^`, как в `[^1b]`. Также можно указать диапазоны символов в выражениях в квадратных скобках. Например, `[0-9]` соответствует цифрам от `0` до `9`, а `[a-z]` соответствует любой строчной букве. Диапазоны следует использовать с осторожностью, поскольку они могут не совпадать в разных регионах. 

Списки выражений в квадратных скобках также принимают классы, а не только отдельные символы и диапазоны. Традиционные классы символов: 

`[: alnum:]`  
Представляет буквенно-цифровой символ. 

`[:alpha:]`  
Представляет собой буквенный символ. 

`[:ascii:]`  
Представляет символ, который соответствует набору символов ASCII. 

`[:empty:]`  
Представляет пробел, то есть пробел или табуляцию. 

`[:cntrl:]`  
Представляет управляющий символ. 

`[:digit:]`  
Представляет собой цифру (от 0 до 9). 

`[:graph:]`  
Представляет любой печатный символ, кроме пробела. 

`[:lower:]`  
Представляет символ нижнего регистра. 

`[:print:]`  
Представляет любой печатный символ, включая пробел. 

`[:punct:]`  
Представляет любой печатаемый символ, не являющийся пробелом или буквенно-цифровым символом. 

`[:space:]`  
Представляет символы пробела: пробел, перевод страницы (`\f`), новая строка (`\n`), возврат каретки (`\r`), горизонтальная табуляция (`\t`) и вертикальная табуляция (`\v`). 

`[:upper:]`  
Представляет заглавную букву. 

`[:xdigit:]`  
Представляет шестнадцатеричные цифры (от 0 до F). 

Классы символов можно комбинировать с отдельными символами и диапазонами, но нельзя использовать в качестве конечной точки диапазона. Кроме того, классы символов могут использоваться только в выражениях в квадратных скобках, а не как независимый атом вне скобок.


## Квантификаторы

Досягаемость атома, будь то атом с одним символом или атом в скобках, можно настроить с помощью квантификатора *атома*. Квантификаторы атома определяют последовательности атомов, то есть совпадения происходят, когда в строке обнаруживается непрерывное повторение атома. Подстрока, соответствующая совпадению, называется *куском*. Тем не менее, квантификаторы и другие особенности регулярных выражений обрабатываются по-разному в зависимости от того, какой стандарт используется. 

Согласно определению POSIX, существует две формы регулярных выражений: «базовые» регулярные выражения и «расширенные» регулярные выражения. Большинство текстовых программ в любом стандартном дистрибутиве Linux поддерживают обе формы, поэтому важно знать их различия, чтобы избежать проблем совместимости и выбрать наиболее подходящую реализацию для предполагаемой задачи. 

Квантификатор `*` выполняет одну и ту же функцию как в базовом, так и в расширенном RE (атом встречается ноль или более раз) и является буквальным символом, если он появляется в начале регулярного выражения или если ему предшествует обратная косая черта `\`. Квантификатор со знаком `+` выберет части, содержащие один или несколько совпадений атомов в последовательности. С вопросительным знаком квантификатора? Совпадение будет происходить, если соответствующий атом появится один раз или если он не появится вообще. Если перед ними стоит обратная косая черта `\`, их особое значение не рассматривается. Базовые регулярные выражения также поддерживают `+` и `?` кванторы, но перед ними должна стоять обратная косая черта. В отличие от расширенных регулярных выражений, `+` и `?` сами по себе являются буквальными символами в основных регулярных выражениях.


## Границы

*Граница* - это квантор атома, который, как следует из названия, позволяет пользователю указать точные границы количества для атома. В расширенных регулярных выражениях граница может иметь три формы: 

`{i}`  
Атом должен появиться ровно `i` раз (`i` целое число). Например, `[[:blank:]]{2}` соответствует ровно двум пустым символам. 

`{i,}`  
Атом должен появиться не менее `i` раз (`i` целое число). Например, `[[:blank:]]{2,}` соответствует любой последовательности из двух или более пустых символов. 

`{i,j}`  
Атом должен появляться не менее `i` раз и не более `j` раз (`i` и `j` целые числа, `j` больше `i`). Например, `xyz{2,4}` соответствует строке `xy`, за которой следуют два-четыре символа `z`. 

В любом случае, если подстрока соответствует регулярному выражению и более длинная подстрока, начинающаяся в той же точке, также совпадает, более длинная подстрока будет рассматриваться. 

Базовые регулярные выражения также поддерживают границы, но перед разделителями должны стоять `\`: `\{` и `\}`. Сами по себе `{and}` интерпретируются как буквальные символы. `\{`, за которым следует символ, отличный от цифры, является буквальным символом, а не началом границы.


## Ветви и обратные ссылки

Базовые регулярные выражения также отличаются от расширенных регулярных выражений еще одним важным аспектом: расширенное регулярное выражение может быть разделено на *ветви*, каждая из которых является независимым регулярным выражением. Ветви разделены `|` и комбинированное регулярное выражение будет соответствовать всему, что соответствует любой из ветвей. Например, `he|him` найдет совпадение, если в проверяемой строке будет найдена подстрока `he` или `him`. Интерпретация основных регулярных выражений `|` как буквальный символ. Однако большинство программ, поддерживающих базовые регулярные выражения, допускают переходы с `\|`. 

Расширенное регулярное выражение, заключенное в `()`, может использоваться в *обратной ссылке*. Например, `([[:digit:]])\1` будет соответствовать любому регулярному выражению, которое повторяется хотя бы один раз, потому что `\1` в выражении - это обратная ссылка на фрагмент, сопоставленный с первым подвыражением в скобках. Если в регулярном выражении существует более одного подвыражения в скобках, на них можно ссылаться с помощью `\2`, `\3` и так далее. 

Для базовых RE подвыражения должны быть заключены в `\(` и `\)`, с `(` и `)` сами по себе обычные символы. Индикатор обратной ссылки используется как в расширенных регулярных выражениях.


## Поиск с помощью регулярных выражений

Непосредственное преимущество регулярных выражений заключается в улучшении поиска в файловых системах и текстовых документах. Параметр `-regex` команды `find` позволяет проверять каждый путь в иерархии каталогов на соответствие регулярному выражению. Например,

```console
$ find $HOME -regex '.*/\..*' -size +100M
```

выполняет поиск файлов размером более 100 мегабайт (100 единиц по 1048576 байтов), но только в тех путях внутри домашнего каталога пользователя, которые действительно содержат совпадение с `.*/\..*`, то есть `/.` окруженный любым другим количеством символов. Другими словами, будут перечислены только скрытые файлы или файлы внутри скрытых каталогов, независимо от положения `/.` в соответствующем пути. Для регулярных выражений без учета регистра следует использовать параметр `-iregex`:

```console
$ find /usr/share/fonts -regextype posix-extended -iregex '.*(dejavu|liberation).*sans.*(italic|oblique).*'
/usr/share/fonts/dejavu/DejaVuSansCondensed-BoldOblique.ttf
/usr/share/fonts/dejavu/DejaVuSansCondensed-Oblique.ttf
/usr/share/fonts/dejavu/DejaVuSans-BoldOblique.ttf
/usr/share/fonts/dejavu/DejaVuSans-Oblique.ttf
/usr/share/fonts/dejavu/DejaVuSansMono-BoldOblique.ttf
/usr/share/fonts/dejavu/DejaVuSansMono-Oblique.ttf
/usr/share/fonts/liberation/LiberationSans-BoldItalic.ttf
/usr/share/fonts/liberation/LiberationSans-Italic.ttf
```

В этом примере регулярное выражение содержит ветви (написанные в расширенном стиле) для перечисления только определенных файлов шрифтов в иерархии каталогов `/usr/share/fonts`. Расширенные регулярные выражения не поддерживаются по умолчанию, но `find` позволяет включить их с помощью `-regextype posix-extended или -regextype egrep`. Стандарт RE по умолчанию для `find` - это *findutils-default*, который фактически является клоном базового регулярного выражения. 

Часто бывает необходимо передать вывод программы команде `less`, если он не помещается на экране. `less` разделяет ввод на страницы, по одному экрану за раз, позволяя пользователю легко перемещаться по тексту вверх и вниз. Кроме того, `less` также позволяет пользователю выполнять поиск на основе регулярных выражений. Эта функция особенно важна, потому что для многих повседневных задач, таких как проверка записей журнала или просмотр справочных страниц, по умолчанию используется реже пагинатор. Например, при чтении справочной страницы нажатие клавиши <kbd>/</kbd> откроет запрос поиска. Это типичный сценарий, в котором полезны регулярные выражения, поскольку параметры команды перечислены сразу после поля страницы в общем макете страницы руководства. Однако один и тот же вариант может многократно появляться в тексте, что делает невозможным буквальный поиск. Независимо от этого, набрав `^[[:blank:]]*-o` - или проще: `^*-o` - в строке поиска, вы сразу же перейдете к параметру раздела `-o` (если он существует) после нажатия Enter, что позволит один, чтобы быстрее просмотреть описание опции.


# Упражнения для закрепления




# Упражнения на размышление




# Резюме




# Ответы на упражнения для закрепления




# Ответы на упражнения для размышления
