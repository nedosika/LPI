# 103.7 Урок 2

| **Сертификат:** | LPIC-1                                      |
|:----------------|:--------------------------------------------|
| **Версия:**     | 5.0                                         |
| **Тема:**       | 103 GNU и Unix комманды                     |                           
| **Цель:**       | 103.6 Поиск текстовых файлов с помощью регулярных выражений |
| **Урок:**       | 2 из 2                                      |


## Введение

Потоковая передача данных через цепочку конвейерных команд позволяет применять составные фильтры на основе регулярных выражений. Регулярные выражения - важный метод, используемый не только в системном администрировании, но также в интеллектуальном *сборе данных* и в смежных областях. Две команды особенно подходят для управления файлами и текстовыми данными с помощью регулярных выражений: `grep` и `sed`. `grep` - это средство поиска паттернов, а `sed` - редактор потоков. Они полезны сами по себе, но выделяются при совместной работе с другими процессами.


## Поисковик шаблонов: `grep`

Одно из наиболее распространенных применений `grep` - облегчение проверки длинных файлов с использованием регулярного выражения в качестве фильтра, применяемого к каждой строке. Его можно использовать для отображения только строк, начинающихся с определенного термина. Например, `grep` можно использовать для исследования файла конфигурации для модулей ядра, перечисляя только строки параметров:

```console
$ grep '^options' /etc/modprobe.d/alsa-base.conf
options snd-pcsp index=-2
options snd-usb-audio index=-2
options bt87x index=-2
options cx88_alsa index=-2
options snd-atiixp-modem index=-2
options snd-intel8x0m index=-2
options snd-via82xx-modem index=-2
```
`|` можно использовать для перенаправления вывода команды непосредственно на ввод `grep`. В следующем примере выражение в скобках используется для выбора строк из вывода `fdisk -l`, начиная с `Disk /dev/sda` или `Disk /dev/ sdb`:

```console
# fdisk -l | grep '^Disk /dev/sd[ab]'
Disk /dev/sda: 320.1 GB, 320072933376 bytes, 625142448 sectors
Disk /dev/sdb: 7998 MB, 7998537728 bytes, 15622144 sectors
```

Простой выбор строк с совпадениями может не подходить для конкретной задачи, требуя корректировки поведения `grep` с помощью его параметров. Например, опция `-c` или `--count` указывает `grep` показать, сколько строк имело совпадения:

```console
# fdisk -l | grep '^Disk /dev/sd[ab]' -c
2
```

Параметр можно разместить до или после регулярного выражения. Другие важные параметры `grep`: 

`-c` или `--count`  
Вместо того, чтобы отображать результаты поиска, отображайте только общее количество совпадений в любом заданном файле. 

`-i` или `--ignore-case`  
Включите поиск без учета регистра. 

`-f FILE` или `--file=FILE`  
Укажите файл, содержащий используемое регулярное выражение. 

`-n` или `--line-number`  
Покажите номер строки. 

`-v` или `--invert-match`  
Выделите все строки, кроме тех, которые содержат совпадения. 

`-H` или `--with-filename`  
Выведите также имя файла, содержащего строку. 

`-z` или `--null-data`  
Вместо того, чтобы использовать `grep` для обработки входных и выходных потоков данных как отдельных строк (с использованием новой строки по умолчанию), вместо этого принимайте входные или выходные данные как последовательность строк. При объединении вывода команды `find` с использованием ее параметра `-print0` с командой `grep` следует использовать параметр `-z` или `--null-data` для обработки потока таким же образом. 

Хотя опция `-H` активирована по умолчанию, когда в качестве входных данных задано несколько путей к файлам, опция `-H` не активирована для отдельных файлов. Это может быть критичным в особых ситуациях, например, когда `grep` вызывается непосредственно командой `find`, например:

```console
$ find /usr/share/doc -type f -exec grep -i '3d modeling' "{}" \; | cut -c -100
artistic aspects of 3D modeling. Thus this might be the application you are
This major approach of 3D modeling has not been supported
oce is a C++ 3D modeling library. It can be used to develop CAD/CAM softwares, for instance [FreeCad
```

В этом примере команда `find` перечисляет каждый файл в каталоге `/usr/share/doc`, а затем передает каждый из них в `grep`, который, в свою очередь, выполняет поиск без учета регистра для `3d modeling` внутри файла. Труба, которую нужно `cut`, нужна только для ограничения выходной длины до 100 столбцов. Обратите внимание, однако, что невозможно узнать, из какого файла взяты строки. Эта проблема решается добавлением `-H` к `grep`:

```$ find /usr/share/doc -type f -exec grep -i -H '3d modeling' "{}" \; | cut -c -100
/usr/share/doc/openscad/README.md:artistic aspects of 3D modeling. Thus this might be the applicatio
/usr/share/doc/opencsg/doc/publications.html:This major approach of 3D modeling has not been support
```

Теперь можно идентифицировать файлы, в которых было найдено каждое совпадение. Чтобы сделать список еще более информативным, к строкам с совпадениями можно добавить начальную и конечную строки:

```console
$ find /usr/share/doc -type f -exec grep -i -H -1 '3d modeling' "{}" \; | cut -c -100
/usr/share/doc/openscad/README.md-application Blender), OpenSCAD focuses on the CAD aspects rather t
/usr/share/doc/openscad/README.md:artistic aspects of 3D modeling. Thus this might be the applicatio
/usr/share/doc/openscad/README.md-looking for when you are planning to create 3D models of machine p
/usr/share/doc/opencsg/doc/publications.html-3D graphics library for Constructive Solid Geometry (CS
/usr/share/doc/opencsg/doc/publications.html:This major approach of 3D modeling has not been support
/usr/share/doc/opencsg/doc/publications.html-by real-time computer graphics until recently.
```

Параметр `-1` указывает `grep` включать одну строку до и одну строку после, когда он находит строку с совпадением. Эти дополнительные строки называются *контекстными строками* и обозначаются в выводе знаком минус после имени файла. Тот же результат может быть получен с помощью `-C 1` или `--context=1`, и могут быть указаны другие значения контекстной строки. 

Для `grep` есть две дополнительные программы: `egrep` и `fgrep`. Программа `egrep` эквивалентна команде `grep -E`, которая включает в себя дополнительные функции, отличные от основных регулярных выражений. Например, с `egrep` можно использовать расширенные функции регулярных выражений, такие как ветвление:

```console
$ find /usr/share/doc -type f -exec egrep -i -H -1 '3d (modeling|printing)' "{}" \; | cut -c -100
/usr/share/doc/openscad/README.md-application Blender), OpenSCAD focuses on the CAD aspects rather t
/usr/share/doc/openscad/README.md:artistic aspects of 3D modeling. Thus this might be the applicatio
/usr/share/doc/openscad/README.md-looking for when you are planning to create 3D models of machine p
/usr/share/doc/openscad/RELEASE_NOTES.md-* Support for using 3D-Mouse / Joystick / Gamepad input dev
/usr/share/doc/openscad/RELEASE_NOTES.md:* 3D Printing support: Purchase from a print service partne
/usr/share/doc/openscad/RELEASE_NOTES.md-* New export file formats: SVG, 3MF, AMF
/usr/share/doc/opencsg/doc/publications.html-3D graphics library for Constructive Solid Geometry (CS
/usr/share/doc/opencsg/doc/publications.html:This major approach of 3D modeling has not been support
/usr/share/doc/opencsg/doc/publications.html-by real-time computer graphics until recently.
```

В этом примере выражение будет соответствовать либо `3D modeling`, либо `3D printing` без учета регистра. Чтобы отобразить только те части текстового потока, которые соответствуют выражению, используемому `egrep`, используйте параметр `-o`. Программа `fgrep` эквивалентна `grep -F`, то есть не анализирует регулярные выражения. Это полезно при простом поиске, когда целью является поиск буквального выражения. Поэтому специальные символы, такие как знак доллара и точка, будут восприниматься буквально, а не по их значению в регулярном выражении.


## Потоковый редактор: sed

Цель программы `sed` - изменять текстовые данные неинтерактивным способом. Это означает, что все редактирование производится с помощью предопределенных инструкций, а не путем произвольного ввода текста непосредственно в текст, отображаемый на экране. Говоря современным языком, `sed` можно понимать как синтаксический анализатор шаблонов: учитывая текст в качестве входных данных, он помещает пользовательский контент в заранее определенные позиции или когда находит совпадение с регулярным выражением. 

Sed, как следует из названия, хорошо подходит для потоковой передачи текста через конвейеры. Его базовый синтаксис - `sed -f SCRIPT`, когда инструкции редактирования хранятся в файле `SCRIPT`, или `sed -e COMMANDS` для выполнения `COMMANDS` непосредственно из командной строки. Если не указаны ни `-f`, ни `-e`, `sed` использует первый параметр, не являющийся параметром, в качестве файла сценария. Также можно использовать файл в качестве входных данных, просто указав его путь в качестве аргумента `sed`. 

Инструкции `sed` состоят из одного символа, которому может предшествовать адрес или за которым следует один или несколько параметров, и применяются к каждой строке за раз. Адреса могут быть одним номером строки, регулярным выражением или диапазоном строк. Например, первая строка текстового потока может быть удалена с помощью `1d`, где `1` указывает строку, в которой будет применяться команда удаления `d`. Чтобы прояснить использование `sed`, возьмите вывод командного фактора `seq 12`, который возвращает простые множители для чисел от 1 до 12:

```console
$ factor `seq 12`
1:
2: 2
3: 3
4: 2 2
5: 5
6: 2 3
7: 7
8: 2 2 2
9: 3 3
10: 2 5
11: 11
12: 2 2 3
```

Удаление первой строки с помощью `sed` выполняется `1d`:

```console
$ factor `seq 12` | sed 1d
2: 2
3: 3
4: 2 2
5: 5
6: 2 3
7: 7
8: 2 2 2
9: 3 3
10: 2 5
11: 11
12: 2 2 3
```

Диапазон строк можно указать через запятую:

```console
$ factor `seq 12` | sed 1,7d
8: 2 2 2
9: 3 3
10: 2 5
11: 11
12: 2 2 3
```

В одном выполнении можно использовать несколько инструкций, разделенных точкой с запятой. В этом случае, однако, важно заключить их в круглые скобки, чтобы точка с запятой не интерпретировалась оболочкой:

```console
$ factor `seq 12` | sed "1,7d;11d"
8: 2 2 2
9: 3 3
10: 2 5
12: 2 2 3
```

В этом примере были выполнены две инструкции удаления, сначала в строках от 1 до 7, а затем в строке 11. Адрес также может быть регулярным выражением, поэтому инструкция повлияет только на строки с совпадением:

```console
$ factor `seq 12` | sed "1d;/:.*2.*/d"
3: 3
5: 5
7: 7
9: 3 3
11: 11
```

Регулярное выражение: `2.*` соответствует любому появлению числа 2 в любом месте после двоеточия, вызывая удаление строк, соответствующих числам с коэффициентом 2. В `sed` все, что находится между косой чертой (`/`), считается регулярным выражением, и по умолчанию поддерживается все базовое RE. Например, `sed -e "/^#/d" /etc/services` показывает содержимое файла `/etc/services` без строк, начинающихся с `#` (строки комментариев). 

Инструкция удаления `d` - лишь одна из многих инструкций редактирования, предоставляемых `sed`. Вместо удаления строки `sed` может заменить ее заданным текстом:

```console
$ factor `seq 12` | sed "1d;/:.*2.*/c REMOVED"
REMOVED
3: 3
REMOVED
5: 5
REMOVED
7: 7
REMOVED
9: 3 3
REMOVED
11: 11
REMOVED
```

Инструкция c `REMOVED` просто заменяет строку текстом `REMOVED`. В случае примера на каждую строку с подстрокой, соответствующей регулярному выражению `:.*2.*`, действует инструкция c `REMOVED`. Инструкция `a TEXT` копирует текст, обозначенный `TEXT`, на новую строку после строки с совпадением. Инструкция `r FILE` делает то же самое, но копирует содержимое файла, указанного параметром `FILE`. Инструкция `w` действует противоположно `r`, то есть строка будет добавлена к указанному файлу. 

Наиболее часто используемая инструкция `sed` - это `s/FIND/REPLACE/`, которая используется для замены совпадения с регулярным выражением `FIND` текстом, обозначенным `REPLACE`. Например, инструкция `s/hda/sda/` заменяет подстроку, соответствующую буквальному RE `hda`, на `sda`. Будет заменено только первое совпадение, найденное в строке, если флаг g не помещен после инструкции, как в `s/hda/sda/g`. 

Более реалистичный пример использования поможет проиллюстрировать возможности `sed`. Предположим, медицинская клиника хочет отправить своим клиентам текстовые сообщения с напоминанием о назначенных встречах на следующий день. Типичный сценарий реализации основан на профессиональной службе мгновенных сообщений, которая предоставляет API для доступа к системе, ответственной за доставку сообщений. Эти сообщения обычно исходят из той же системы, которая запускает приложение, контролирующее встречи клиентов, инициируемые определенным временем дня или каким-либо другим событием. В этой гипотетической ситуации приложение могло бы сгенерировать файл с именем `assignments.csv`, содержащий табличные данные со всеми встречами на следующий день, а затем использовать `sed` для визуализации текстовых сообщений из файла шаблона с именем `template.txt`. Файлы CSV - это стандартный способ экспорта данных из запросов к базе данных, поэтому примерные встречи могут быть представлены следующим образом:

```console
$ cat appointments.csv
"NAME","TIME","PHONE"
"Carol","11am","55557777"
"Dave","2pm","33334444"
```

Первая строка содержит метки для каждого столбца, которые будут использоваться для сопоставления тегов внутри файла образца шаблона:

```console
$ cat template.txt
Hey <NAME>, don't forget your appointment tomorrow at <TIME>.
```

Знаки `<` и `>` были помещены вокруг меток, чтобы помочь идентифицировать их как теги. Следующий сценарий Bash анализирует все назначенные в очередь встречи, используя `template.txt` в качестве шаблона сообщения:

```console
#! /bin/bash

TEMPLATE=`cat template.txt`
TAGS=(`sed -ne '1s/^"//;1s/","/\n/g;1s/"$//p' appointments.csv`)
mapfile -t -s 1 ROWS < appointments.csv
for (( r = 0; r < ${#ROWS[*]}; r++ ))
do
  MSG=$TEMPLATE
  VALS=(`sed -e 's/^"//;s/","/\n/g;s/"$//' <<<${ROWS[$r]}`)
  for (( c = 0; c < ${#TAGS[*]}; c++ ))
  do
    MSG=`sed -e "s/<${TAGS[$c]}>/${VALS[$c]}/g" <<<"$MSG"`
  done
  echo curl --data message=\"$MSG\" --data phone=\"${VALS[2]}\" https://mysmsprovider/api
done
```

Фактический производственный сценарий также будет обрабатывать аутентификацию, проверку ошибок и ведение журнала, но в этом примере есть базовые функции для начала. Первые инструкции, выполняемые sed, применяются только к первой строке - адресу 1 в 1s / ^ "//; 1s /", "/ \ n / g; 1s /" $ // p - для удаления начальных и конечных кавычки - 1s / ^ "// и 1s /" $ // - и заменить разделители полей символом новой строки: 1s / "," / \ n / g. Для загрузки имен столбцов требуется только первая строка, поэтому несовпадающие строки будут подавлены опцией -n, требующей установки флага p после последней команды sed для печати соответствующей строки. Затем теги сохраняются в переменной TAGS как массив Bash. Другая переменная массива Bash создается командой mapfile для хранения строк, содержащих встречи, в переменной массива ROWS. Цикл for используется для обработки каждой строки встречи в ROWS. Затем кавычки и разделители в встрече - встреча находится в переменной $ {ROWS [$ r]}, используемой как строка здесь - заменяются на sed, аналогично командам, используемым для загрузки тегов. Разделенные значения для встречи затем сохраняются в переменной массива VALS, где индексы массива 0, 1 и 2 соответствуют значениям для NAME, TIME и PHONE. Наконец, вложенный цикл for проходит по массиву TAGS и заменяет каждый тег, найденный в шаблоне, на его соответствующее значение в VALS. Переменная MSG содержит копию обработанного шаблона, обновленную командой подстановки s / <$ {TAGS [$ c]}> / $ {VALS [$ c]} / g при каждом прохождении цикла через TAGS. В результате появляется сообщение вроде: «Привет, Кэрол, не забудь о встрече завтра в 11 утра». Отрисованное сообщение затем может быть отправлено в качестве параметра через HTTP-запрос с помощью curl, как почтовое сообщение или любым другим подобным методом.
