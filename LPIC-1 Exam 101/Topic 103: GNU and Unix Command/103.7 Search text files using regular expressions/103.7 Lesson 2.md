# 103.7 Урок 2

| **Сертификат:** | LPIC-1                                      |
|:----------------|:--------------------------------------------|
| **Версия:**     | 5.0                                         |
| **Тема:**       | 103 GNU и Unix комманды                     |                           
| **Цель:**       | 103.6 Поиск текстовых файлов с помощью регулярных выражений |
| **Урок:**       | 2 из 2                                      |


## Введение

Потоковая передача данных через цепочку конвейерных команд позволяет применять составные фильтры на основе регулярных выражений. Регулярные выражения - важный метод, используемый не только в системном администрировании, но также в интеллектуальном *сборе данных* и в смежных областях. Две команды особенно подходят для управления файлами и текстовыми данными с помощью регулярных выражений: `grep` и `sed`. `grep` - это средство поиска паттернов, а `sed` - редактор потоков. Они полезны сами по себе, но выделяются при совместной работе с другими процессами.


## Поисковик шаблонов: `grep`

Одно из наиболее распространенных применений `grep` - облегчение проверки длинных файлов с использованием регулярного выражения в качестве фильтра, применяемого к каждой строке. Его можно использовать для отображения только строк, начинающихся с определенного термина. Например, `grep` можно использовать для исследования файла конфигурации для модулей ядра, перечисляя только строки параметров:

```console
$ grep '^options' /etc/modprobe.d/alsa-base.conf
options snd-pcsp index=-2
options snd-usb-audio index=-2
options bt87x index=-2
options cx88_alsa index=-2
options snd-atiixp-modem index=-2
options snd-intel8x0m index=-2
options snd-via82xx-modem index=-2
```
`|` можно использовать для перенаправления вывода команды непосредственно на ввод `grep`. В следующем примере выражение в скобках используется для выбора строк из вывода `fdisk -l`, начиная с `Disk /dev/sda` или `Disk /dev/ sdb`:

```console
# fdisk -l | grep '^Disk /dev/sd[ab]'
Disk /dev/sda: 320.1 GB, 320072933376 bytes, 625142448 sectors
Disk /dev/sdb: 7998 MB, 7998537728 bytes, 15622144 sectors
```

Простой выбор строк с совпадениями может не подходить для конкретной задачи, требуя корректировки поведения `grep` с помощью его параметров. Например, опция `-c` или `--count` указывает `grep` показать, сколько строк имело совпадения:

```console
# fdisk -l | grep '^Disk /dev/sd[ab]' -c
2
```

Параметр можно разместить до или после регулярного выражения. Другие важные параметры `grep`: 

`-c` или `--count`  
Вместо того, чтобы отображать результаты поиска, отображайте только общее количество совпадений в любом заданном файле. 

`-i` или `--ignore-case`  
Включите поиск без учета регистра. 

`-f FILE` или `--file=FILE`  
Укажите файл, содержащий используемое регулярное выражение. 

`-n` или `--line-number`  
Покажите номер строки. 

`-v` или `--invert-match`  
Выделите все строки, кроме тех, которые содержат совпадения. 

`-H` или `--with-filename`  
Выведите также имя файла, содержащего строку. 

`-z` или `--null-data`  
Вместо того, чтобы использовать `grep` для обработки входных и выходных потоков данных как отдельных строк (с использованием новой строки по умолчанию), вместо этого принимайте входные или выходные данные как последовательность строк. При объединении вывода команды `find` с использованием ее параметра `-print0` с командой `grep` следует использовать параметр `-z` или `--null-data` для обработки потока таким же образом. 

Хотя опция `-H` активирована по умолчанию, когда в качестве входных данных задано несколько путей к файлам, опция `-H` не активирована для отдельных файлов. Это может быть критичным в особых ситуациях, например, когда `grep` вызывается непосредственно командой `find`, например:

```console
$ find /usr/share/doc -type f -exec grep -i '3d modeling' "{}" \; | cut -c -100
artistic aspects of 3D modeling. Thus this might be the application you are
This major approach of 3D modeling has not been supported
oce is a C++ 3D modeling library. It can be used to develop CAD/CAM softwares, for instance [FreeCad
```

В этом примере команда `find` перечисляет каждый файл в каталоге `/usr/share/doc`, а затем передает каждый из них в `grep`, который, в свою очередь, выполняет поиск без учета регистра для `3d modeling` внутри файла. Труба, которую нужно `cut`, нужна только для ограничения выходной длины до 100 столбцов. Обратите внимание, однако, что невозможно узнать, из какого файла взяты строки. Эта проблема решается добавлением `-H` к `grep`:

```$ find /usr/share/doc -type f -exec grep -i -H '3d modeling' "{}" \; | cut -c -100
/usr/share/doc/openscad/README.md:artistic aspects of 3D modeling. Thus this might be the applicatio
/usr/share/doc/opencsg/doc/publications.html:This major approach of 3D modeling has not been support
```

Теперь можно идентифицировать файлы, в которых было найдено каждое совпадение. Чтобы сделать список еще более информативным, к строкам с совпадениями можно добавить начальную и конечную строки:

```console
$ find /usr/share/doc -type f -exec grep -i -H -1 '3d modeling' "{}" \; | cut -c -100
/usr/share/doc/openscad/README.md-application Blender), OpenSCAD focuses on the CAD aspects rather t
/usr/share/doc/openscad/README.md:artistic aspects of 3D modeling. Thus this might be the applicatio
/usr/share/doc/openscad/README.md-looking for when you are planning to create 3D models of machine p
/usr/share/doc/opencsg/doc/publications.html-3D graphics library for Constructive Solid Geometry (CS
/usr/share/doc/opencsg/doc/publications.html:This major approach of 3D modeling has not been support
/usr/share/doc/opencsg/doc/publications.html-by real-time computer graphics until recently.
```

Параметр `-1` указывает `grep` включать одну строку до и одну строку после, когда он находит строку с совпадением. Эти дополнительные строки называются *контекстными строками* и обозначаются в выводе знаком минус после имени файла. Тот же результат может быть получен с помощью `-C 1` или `--context=1`, и могут быть указаны другие значения контекстной строки. 

Для `grep` есть две дополнительные программы: `egrep` и `fgrep`. Программа `egrep` эквивалентна команде `grep -E`, которая включает в себя дополнительные функции, отличные от основных регулярных выражений. Например, с `egrep` можно использовать расширенные функции регулярных выражений, такие как ветвление:

```console
$ find /usr/share/doc -type f -exec egrep -i -H -1 '3d (modeling|printing)' "{}" \; | cut -c -100
/usr/share/doc/openscad/README.md-application Blender), OpenSCAD focuses on the CAD aspects rather t
/usr/share/doc/openscad/README.md:artistic aspects of 3D modeling. Thus this might be the applicatio
/usr/share/doc/openscad/README.md-looking for when you are planning to create 3D models of machine p
/usr/share/doc/openscad/RELEASE_NOTES.md-* Support for using 3D-Mouse / Joystick / Gamepad input dev
/usr/share/doc/openscad/RELEASE_NOTES.md:* 3D Printing support: Purchase from a print service partne
/usr/share/doc/openscad/RELEASE_NOTES.md-* New export file formats: SVG, 3MF, AMF
/usr/share/doc/opencsg/doc/publications.html-3D graphics library for Constructive Solid Geometry (CS
/usr/share/doc/opencsg/doc/publications.html:This major approach of 3D modeling has not been support
/usr/share/doc/opencsg/doc/publications.html-by real-time computer graphics until recently.
```

В этом примере выражение будет соответствовать либо `3D modeling`, либо `3D printing` без учета регистра. Чтобы отобразить только те части текстового потока, которые соответствуют выражению, используемому `egrep`, используйте параметр `-o`. Программа `fgrep` эквивалентна `grep -F`, то есть не анализирует регулярные выражения. Это полезно при простом поиске, когда целью является поиск буквального выражения. Поэтому специальные символы, такие как знак доллара и точка, будут восприниматься буквально, а не по их значению в регулярном выражении.


## Потоковый редактор: sed

Цель программы `sed` - изменять текстовые данные неинтерактивным способом. Это означает, что все редактирование производится с помощью предопределенных инструкций, а не путем произвольного ввода текста непосредственно в текст, отображаемый на экране. Говоря современным языком, `sed` можно понимать как синтаксический анализатор шаблонов: учитывая текст в качестве входных данных, он помещает пользовательский контент в заранее определенные позиции или когда находит совпадение с регулярным выражением. 

Sed, как следует из названия, хорошо подходит для потоковой передачи текста через конвейеры. Его базовый синтаксис - `sed -f SCRIPT`, когда инструкции редактирования хранятся в файле `SCRIPT`, или `sed -e COMMANDS` для выполнения `COMMANDS` непосредственно из командной строки. Если не указаны ни `-f`, ни `-e`, `sed` использует первый параметр, не являющийся параметром, в качестве файла сценария. Также можно использовать файл в качестве входных данных, просто указав его путь в качестве аргумента `sed`. 

Инструкции `sed` состоят из одного символа, которому может предшествовать адрес или за которым следует один или несколько параметров, и применяются к каждой строке за раз. Адреса могут быть одним номером строки, регулярным выражением или диапазоном строк. Например, первая строка текстового потока может быть удалена с помощью `1d`, где `1` указывает строку, в которой будет применяться команда удаления `d`. Чтобы прояснить использование `sed`, возьмите вывод командного фактора `seq 12`, который возвращает простые множители для чисел от 1 до 12:

```console
$ factor `seq 12`
1:
2: 2
3: 3
4: 2 2
5: 5
6: 2 3
7: 7
8: 2 2 2
9: 3 3
10: 2 5
11: 11
12: 2 2 3
```

Удаление первой строки с помощью `sed` выполняется `1d`:

```console
$ factor `seq 12` | sed 1d
2: 2
3: 3
4: 2 2
5: 5
6: 2 3
7: 7
8: 2 2 2
9: 3 3
10: 2 5
11: 11
12: 2 2 3
```

Диапазон строк можно указать через запятую:

```console
$ factor `seq 12` | sed 1,7d
8: 2 2 2
9: 3 3
10: 2 5
11: 11
12: 2 2 3
```

В одном выполнении можно использовать несколько инструкций, разделенных точкой с запятой. В этом случае, однако, важно заключить их в круглые скобки, чтобы точка с запятой не интерпретировалась оболочкой:

```console
$ factor `seq 12` | sed "1,7d;11d"
8: 2 2 2
9: 3 3
10: 2 5
12: 2 2 3
```

В этом примере были выполнены две инструкции удаления, сначала в строках от 1 до 7, а затем в строке 11. Адрес также может быть регулярным выражением, поэтому инструкция повлияет только на строки с совпадением:

```console
$ factor `seq 12` | sed "1d;/:.*2.*/d"
3: 3
5: 5
7: 7
9: 3 3
11: 11
```

Регулярное выражение: `2.*` соответствует любому появлению числа 2 в любом месте после двоеточия, вызывая удаление строк, соответствующих числам с коэффициентом 2. В `sed` все, что находится между косой чертой (`/`), считается регулярным выражением, и по умолчанию поддерживается все базовое RE. Например, `sed -e "/^#/d" /etc/services` показывает содержимое файла `/etc/services` без строк, начинающихся с `#` (строки комментариев). 

Инструкция удаления `d` - лишь одна из многих инструкций редактирования, предоставляемых `sed`. Вместо удаления строки `sed` может заменить ее заданным текстом:

```console
$ factor `seq 12` | sed "1d;/:.*2.*/c REMOVED"
REMOVED
3: 3
REMOVED
5: 5
REMOVED
7: 7
REMOVED
9: 3 3
REMOVED
11: 11
REMOVED
```

Инструкция c `REMOVED` просто заменяет строку текстом `REMOVED`. В случае примера на каждую строку с подстрокой, соответствующей регулярному выражению `:.*2.*`, действует инструкция c `REMOVED`. Инструкция `a TEXT` копирует текст, обозначенный `TEXT`, на новую строку после строки с совпадением. Инструкция `r FILE` делает то же самое, но копирует содержимое файла, указанного параметром `FILE`. Инструкция `w` действует противоположно `r`, то есть строка будет добавлена к указанному файлу. 

Наиболее часто используемая инструкция `sed` - это `s/FIND/REPLACE/`, которая используется для замены совпадения с регулярным выражением `FIND` текстом, обозначенным `REPLACE`. Например, инструкция `s/hda/sda/` заменяет подстроку, соответствующую буквальному RE `hda`, на `sda`. Будет заменено только первое совпадение, найденное в строке, если флаг g не помещен после инструкции, как в `s/hda/sda/g`. 

Более реалистичный пример использования поможет проиллюстрировать возможности `sed`. Предположим, медицинская клиника хочет отправить своим клиентам текстовые сообщения с напоминанием о назначенных встречах на следующий день. Типичный сценарий реализации основан на профессиональной службе мгновенных сообщений, которая предоставляет API для доступа к системе, ответственной за доставку сообщений. Эти сообщения обычно исходят из той же системы, которая запускает приложение, контролирующее встречи клиентов, инициируемые определенным временем дня или каким-либо другим событием. В этой гипотетической ситуации приложение могло бы сгенерировать файл с именем `assignments.csv`, содержащий табличные данные со всеми встречами на следующий день, а затем использовать `sed` для визуализации текстовых сообщений из файла шаблона с именем `template.txt`. Файлы CSV - это стандартный способ экспорта данных из запросов к базе данных, поэтому примерные встречи могут быть представлены следующим образом:

```console
$ cat appointments.csv
"NAME","TIME","PHONE"
"Carol","11am","55557777"
"Dave","2pm","33334444"
```

Первая строка содержит метки для каждого столбца, которые будут использоваться для сопоставления тегов внутри файла образца шаблона:

```console
$ cat template.txt
Hey <NAME>, don't forget your appointment tomorrow at <TIME>.
```

Знаки `<` и `>` были помещены вокруг меток, чтобы помочь идентифицировать их как теги. Следующий сценарий Bash анализирует все назначенные в очередь встречи, используя `template.txt` в качестве шаблона сообщения:

```console
#! /bin/bash

TEMPLATE=`cat template.txt`
TAGS=(`sed -ne '1s/^"//;1s/","/\n/g;1s/"$//p' appointments.csv`)
mapfile -t -s 1 ROWS < appointments.csv
for (( r = 0; r < ${#ROWS[*]}; r++ ))
do
  MSG=$TEMPLATE
  VALS=(`sed -e 's/^"//;s/","/\n/g;s/"$//' <<<${ROWS[$r]}`)
  for (( c = 0; c < ${#TAGS[*]}; c++ ))
  do
    MSG=`sed -e "s/<${TAGS[$c]}>/${VALS[$c]}/g" <<<"$MSG"`
  done
  echo curl --data message=\"$MSG\" --data phone=\"${VALS[2]}\" https://mysmsprovider/api
done
```

Фактический производственный сценарий также будет обрабатывать аутентификацию, проверку ошибок и ведение журнала, но в этом примере есть базовые функции для начала. Первые инструкции, выполняемые `sed`, применяются только к первой строке - адресу `1` в `1s/^"//;1s/","/\n/g;1s/"$//p` - для удаления начальных и конечных кавычки - `1s/^"//` и `1s/"$//` - и заменить разделители полей символом новой строки: `1s/","/\n/g`. Для загрузки имен столбцов требуется только первая строка, поэтому несовпадающие строки будут подавлены опцией `-n`, требующей установки флага `p` после последней команды `sed` для печати соответствующей строки. Затем теги сохраняются в переменной `TAGS` как массив Bash. Другая переменная массива Bash создается командой `mapfile` для хранения строк, содержащих встречи, в переменной массива `ROWS`. 

Цикл `for` используется для обработки каждой строки встречи в `ROWS`. Затем кавычки и разделители в встрече - встреча находится в переменной `${ROWS[$ r]}`, используемой как *строка здесь* - заменяются на `sed`, аналогично командам, используемым для загрузки тегов. Разделенные значения для встречи затем сохраняются в переменной массива `VALS`, где индексы массива 0, 1 и 2 соответствуют значениям для `NAME`, `TIME` и `PHONE`. 

Наконец, вложенный цикл `for` проходит по массиву `TAGS` и заменяет каждый тег, найденный в шаблоне, на его соответствующее значение в `VALS`. Переменная `MSG` содержит копию обработанного шаблона, обновленную командой подстановки `s/<${TAGS[$c]}>/${VALS[$c]}/g` при каждом прохождении цикла через `TAGS`. В результате появляется сообщение вроде: `"Hey Carol, don’t forget your appointment tomorrow at 11am."`(«Привет, Кэрол, не забудь о встрече завтра в 11 утра»). Отрисованное сообщение затем может быть отправлено в качестве параметра через HTTP-запрос с помощью `curl`, как почтовое сообщение или любым другим подобным методом.


## Объединение grep и sed

Команды `grep` и `sed` можно использовать вместе, когда требуются более сложные процедуры интеллектуального анализа текста. Как системный администратор, вы можете, например, захотеть проверить все попытки входа на сервер. Файл `/var/log/wtmp` записывает все входы и выходы из системы, а файл `/var/log/btmp` записывает неудачные попытки входа в систему. Они записаны в двоичном формате, который можно прочитать командами `last` и `lastb` соответственно. 

Вывод `lastb` показывает не только имя пользователя, использованное при неудачной попытке входа в систему, но и его IP-адрес:

```console
# lastb -d -a -n 10 --time-format notime
user     ssh:notty       (00:00)     81.161.63.251
nrostagn ssh:notty       (00:00)     vmd60532.contaboserver.net
pi       ssh:notty       (00:00)     132.red-88-20-39.staticip.rima-tde.net
pi       ssh:notty       (00:00)     132.red-88-20-39.staticip.rima-tde.net
pi       ssh:notty       (00:00)     46.6.11.56
pi       ssh:notty       (00:00)     46.6.11.56
nps      ssh:notty       (00:00)     vmd60532.contaboserver.net
narmadan ssh:notty       (00:00)     vmd60532.contaboserver.net
nominati ssh:notty       (00:00)     vmd60532.contaboserver.net
nominati ssh:notty       (00:00)     vmd60532.contaboserver.net
```

Параметр `-d` переводит IP-адрес в соответствующее имя хоста. Имя хоста может дать подсказку об интернет-провайдере или службе хостинга, использованных для выполнения этих неудачных попыток входа в систему. Опция `-a` помещает имя хоста в последний столбец, что облегчает фильтрацию, которую еще не применили. Опция `--time-format notime` подавляет время попытки входа в систему. Выполнение команды `lastb` может занять некоторое время, если было слишком много неудачных попыток входа в систему, поэтому вывод был ограничен десятью записями с параметром `-n 10`. 

Не все удаленные IP-адреса имеют связанное с ними имя хоста, поэтому обратный DNS не применяется к ним, и они могут быть отклонены. Хотя вы можете написать регулярное выражение для соответствия ожидаемому формату имени хоста в конце строки, вероятно, проще написать регулярное выражение, которое соответствовало бы либо букве алфавита, либо одной цифре в конце строки. В следующем примере показано, как команда `grep` берет список со стандартного ввода и удаляет строки без имен хостов:

```console
# lastb -d -a --time-format notime | grep -v '[0-9]$' | head -n 10
nvidia   ssh:notty       (00:00)     vmd60532.contaboserver.net
n_tonson ssh:notty       (00:00)     vmd60532.contaboserver.net
nrostagn ssh:notty       (00:00)     vmd60532.contaboserver.net
pi       ssh:notty       (00:00)     132.red-88-20-39.staticip.rima-tde.net
pi       ssh:notty       (00:00)     132.red-88-20-39.staticip.rima-tde.net
nps      ssh:notty       (00:00)     vmd60532.contaboserver.net
narmadan ssh:notty       (00:00)     vmd60532.contaboserver.net
nominati ssh:notty       (00:00)     vmd60532.contaboserver.net
nominati ssh:notty       (00:00)     vmd60532.contaboserver.net
nominati ssh:notty       (00:00)     vmd60532.contaboserver.net
```

Параметр `-v` команды `grep` показывает только те строки, которые не соответствуют заданному регулярному выражению. Регулярное выражение, совпадающее с любой строкой, заканчивающейся числом (например, `[0-9]$`), захватит только записи без имени хоста. Следовательно, `grep -v '[0-9]$'` покажет только строки, заканчивающиеся именем хоста. 

Вывод можно отфильтровать еще больше, сохранив только доменное имя и удалив другие части из каждой строки. Команда `sed` может сделать это с помощью команды подстановки, чтобы заменить всю строку обратной ссылкой на доменное имя в ней:

```console
# lastb -d -a --time-format notime | grep -v '[0-9]$' | sed -e 's/.* \(.*\)$/\1/' | head -n 10
vmd60532.contaboserver.net
vmd60532.contaboserver.net
vmd60532.contaboserver.net
132.red-88-20-39.staticip.rima-tde.net
132.red-88-20-39.staticip.rima-tde.net
vmd60532.contaboserver.net
vmd60532.contaboserver.net
vmd60532.contaboserver.net
vmd60532.contaboserver.net
vmd60532.contaboserver.net
```

Экранированная скобка в `. *\(.*\)$` указывает `sed` запомнить эту часть строки, то есть часть между последним символом пробела и концом строки. В примере эта часть обозначена как `\1` и используется для замены всей строки. 

Понятно, что большинство удаленных хостов пытаются войти в систему более одного раза, поэтому одно и то же доменное имя повторяется. Чтобы подавить повторяющиеся записи, сначала их нужно отсортировать (с помощью команды `sort`), а затем передать команде `uniq`:

```console
# lastb -d -a --time-format notime | grep -v '[0-9]$' | sed -e 's/.* \(.*\)$/\1/' | sort | uniq | head -n 10
116-25-254-113-on-nets.com
132.red-88-20-39.staticip.rima-tde.net
145-40-33-205.power-speed.at
tor.laquadrature.net
tor.momx.site
ua-83-226-233-154.bbcust.telenor.se
vmd38161.contaboserver.net
vmd60532.contaboserver.net
vmi488063.contaboserver.net
vmi515749.contaboserver.net
```

Это показывает, как можно комбинировать разные команды для получения желаемого результата. Список имен хостов затем можно использовать для записи правил блокировки брандмауэра или для принятия других мер по обеспечению безопасности сервера.


# Упражнения для закрепления

1. Команда `last` показывает список последних авторизованных пользователей, включая их исходные IP-адреса. Как можно было бы использовать команду `egrep` для фильтрации последнего вывода, показывая только вхождения IPv4-адреса, отбрасывая любую дополнительную информацию в соответствующей строке? 

2. Какую опцию следует указать `grep`, чтобы правильно отфильтровать вывод, сгенерированный командой `find`, выполненной с опцией `-print0`? 

3. Команда `uptime -s` показывает последнюю дату включения системы, как в `2019-08-05 20:13:22`. Что будет в результате команды `uptime -s | sed -e 's/(.*) (.*)/\1/'?` 

4. Какую опцию следует дать `grep`, чтобы она подсчитывала совпадающие строки, а не отображала их?


# Упражнения на размышление

1. Базовая структура HTML-файла начинается с элементов html, head и body, например:
```console
<html>
<head>
  <title>News Site</title>
</head>
<body>
  <h1>Headline</h1>
  <p>Information of interest.</p>
</body>
</html>
```
Опишите, как можно использовать адреса в `sed` для отображения только основного элемента и его содержимого.

2. Какое выражение sed удалит все теги из HTML-документа, сохранив только отображаемый текст? 

3. Файлы с расширением `.ovpn` очень популярны для настройки VPN-клиентов, поскольку они содержат не только настройки, но и содержимое ключей и сертификатов для клиента. Эти ключи и сертификаты изначально находятся в отдельных файлах, поэтому их нужно скопировать в файл `.ovpn`. Учитывая следующий отрывок из шаблона `.ovpn`:

```console
client
dev tun
remote 192.168.1.155 1194
<ca>
ca.crt
</ca>
<cert>
client.crt
</cert>
<key>
client.key
</key>
<tls-auth>
ta.key
</tls-auth>
```

Предполагая, что файлы `ca.crt`, `client.srt`, `client.key` и `ta.key` находятся в текущем каталоге, как бы `sed` изменил конфигурацию шаблона, чтобы заменить каждое имя файла его содержимым?


# Резюме

В этом уроке рассматриваются две наиболее важные команды Linux, связанные с регулярными выражениями: `grep` и `sed`. Сценарии и составные команды полагаются на `grep` и `sed` для выполнения широкого спектра задач по фильтрации и синтаксическому анализу текста. Урок состоит из следующих этапов: 

* Как использовать `grep` и его варианты, такие как `egrep` и `fgrep`. 
* Как использовать `sed` и его внутренние инструкции для работы с текстом. 
* Примеры приложений с регулярными выражениями с использованием `grep` и `sed`.


# Ответы на упражнения для закрепления

**1. Команда `last` показывает список последних авторизованных пользователей, включая их исходные IP-адреса. Как можно было бы использовать команду `egrep` для фильтрации последнего вывода, показывая только вхождения IPv4-адреса, отбрасывая любую дополнительную информацию в соответствующей строке?**  
```console
last -i | egrep -o '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}'
```

**2. Какую опцию следует указать `grep`, чтобы правильно отфильтровать вывод, сгенерированный командой `find`, выполненной с опцией `-print0`?**  
Опция `-z` или `--null-data`, как в `find . -print0 | grep -z expression`.

**3. Команда `uptime -s` показывает последнюю дату включения системы, как в `2019-08-05 20:13:22`. Что будет в результате команды `uptime -s | sed -e 's/(.*) (.*)/\1/'?`**  
Произойдет ошибка. По умолчанию скобки следует экранировать, чтобы использовать обратные ссылки в `sed`.

**4. Какую опцию следует дать `grep`, чтобы она подсчитывала совпадающие строки, а не отображала их?**  
Параметр `-c`.


# Ответы на упражнения для размышления

**1. Базовая структура HTML-файла начинается с элементов html, head и body, например:**
```console
<html>
<head>
  <title>News Site</title>
</head>
<body>
  <h1>Headline</h1>
  <p>Information of interest.</p>
</body>
</html>
```
**Опишите, как можно использовать адреса в `sed` для отображения только основного элемента и его содержимого.**  
Чтобы отображалось только `body`, адреса должны быть `/<body>/,/ <\/body>/`, как в `sed -n -e '/<body>/,/<\/body>/p'`. Параметр `-n` задан для `sed`, поэтому он по умолчанию не печатает строки, поэтому команда `p` в конце выражения `sed` позволяет печатать совпадающие строки.

**2. Какое выражение `sed` удалит все теги из HTML-документа, сохранив только отображаемый текст?**
Выражение `sed` `s/<[^>]*>//g` заменит любое содержимое, заключенное в `<>`, пустой строкой.

**3. Файлы с расширением `.ovpn` очень популярны для настройки VPN-клиентов, поскольку они содержат не только настройки, но и содержимое ключей и сертификатов для клиента. Эти ключи и сертификаты изначально находятся в отдельных файлах, поэтому их нужно скопировать в файл `.ovpn`. Учитывая следующий отрывок из шаблона `.ovpn`:**  

```console
client
dev tun
remote 192.168.1.155 1194
<ca>
ca.crt
</ca>
<cert>
client.crt
</cert>
<key>
client.key
</key>
<tls-auth>
ta.key
</tls-auth>
```

**Предполагая, что файлы `ca.crt`, `client.srt`, `client.key` и `ta.key` находятся в текущем каталоге, как бы `sed` изменил конфигурацию шаблона, чтобы заменить каждое имя файла его содержимым?**  
Команда
```console
sed -r -e 's/(^[^.]*)\.(crt|key)$/cat \1.\2/e' < client.template > client.ovpn
```
заменяет любую строку, оканчивающуюся на `.crt` или `.key`, содержимым файла, имя которого совпадает с этой строкой. Параметр `-r` указывает `sed` использовать расширенные регулярные выражения, в то время как e в конце выражения указывает `sed` заменить совпадения выводом команды `cat \1. \2`. Обратные ссылки `\1` и `\2` соответствуют имени файла и расширению, найденным в совпадении.

