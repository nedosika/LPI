# 101.2 Урок 1

| Сертификат:   | LPIC-1                                      |
|:--------------|:--------------------------------------------|
| Версия:       | 5.0                                         |
| Тема:         | 101 Архитектура системы                     |                           
| Цель:         | 101.2 Загрузка системы                      |
| Урок:         | 1 из 1                                      |


## Введение

Для управления машиной, основной компонент операционной системы - ядро, должно быть загружено программой, называемой загрузчиком, которая сама загружается с помощью предустановленной прошивки, такой как BIOS или UEFI. Загрузчик можно настроить для передачи параметров ядру, например, какой раздел содержит корневую файловую систему или в каком режиме должна выполняться операционная система. После загрузки ядро продолжает процесс загрузки, идентифицируя и настраивая оборудование. Наконец, ядро вызывает утилиту, отвечающую за запуск системных служб и управление ими.

>В некоторых дистрибутивах Linux для команд, выполняемых в этом уроке, могут потребоваться привилегии root.


## BIOS или UEFI

Процедуры, выполняемые машинами x86 для запуска загрузчика, различны, и используют они BIOS или UEFI. BIOS, сокращение от Basic Input/Output System, - это программа, хранящаяся в микросхеме энергонезависимой памяти, прикрепленной к материнской плате, и выполняется каждый раз при включении компьютера. Этот тип программы называется прошивкой, и ее место хранения отдельно от других запоминающих устройств, которые может иметь система. BIOS предполагает, что первые 440 байтов в первом запоминающем устройстве - следуя порядку, определенному в служебной программе настройки BIOS - являются первым этапом загрузчика(также называемого *начальным загрузчиком*). Первые 512 байтов запоминающего устройства называются MBR(*Master Boot Record*) запоминающих устройств, использующих стандартную схему разделов DOS, и, в дополнение к первому этапу загрузчика, содержат таблицу разделов. Если MBR не содержит правильных данных, система не сможет загрузиться, если не будет использован альтернативный метод. 

Говоря вцелом, предварительные шаги для загрузки системы, оснащенной BIOS, следующие: 
* Процесс POST(*power-on self-test*) выполняется для выявления простых отказов оборудования сразу после включения машины.
* BIOS активирует основные компоненты для загрузки системы, такие как видеовыход, клавиатура и носители. 
* BIOS загружает первый уровень загрузчика из MBR (первые 440 байтов первого устройства, как определено в утилите конфигурации BIOS). 
* Первый уровень загрузчика вызывает второй уровень загрузчика, отвечающий за представление параметров загрузки и загрузку ядра. 

UEFI, сокращение от *Unified Extensible Firmware Interface*, отличается от BIOS в некоторых ключевых моментах. Как и BIOS, UEFI также является прошивкой, но он может идентифицировать разделы и читать большинство файловых системы, обнаруженные на них. UEFI не полагается на MBR, принимая во внимание только настройки, хранящиеся в его энергонезависимой памяти(*NVRAM*), подключенной к материнской плате. Эти значения указывают на расположение программ, совместимых с UEFI, называемых приложениями EFI, которые будут выполняться автоматически или вызываться из меню загрузки. Приложения EFI могут быть загрузчиками, селекторами операционной системы, инструментами для диагностики и восстановления системы и т.д. Они должны находиться в обычном разделе устройства хранения и в совместимой файловой системе. Стандартные совместимые файловые системы - FAT12, FAT16 и FAT32 для блочных устройств и ISO-9660 для оптических носителей. Такой подход позволяет реализовать гораздо более сложные инструменты, чем те, которые возможны в BIOS. 

Раздел, содержащий приложения EFI, называется *системным разделом EFI* или просто ESP. Этот раздел не должен использоваться совместно с другими системными файловыми системами, такими как корневая файловая система или файловые системы пользовательских данных. Каталог EFI в разделе ESP содержит приложения, на которые указывают записи, сохраненные в NVRAM. 

В общем, шаги перед загрузкой операционной системы в системе с UEFI: 
* Процесс POST(*самотестирование при включении*) выполняется для выявления простых отказов оборудования сразу после включения машины. 
* UEFI активирует основные компоненты для загрузки системы, такие как видеовыход, клавиатура и носители. 
* Прошивка UEFI считывает настройки, хранящиеся в NVRAM, для выполнения предварительно определенного приложения EFI, хранящегося в файловой системе раздела ESP. Обычно предопределенное приложение EFI является загрузчиком. 
* Если предварительно определенное приложение EFI является загрузчиком, оно загрузит ядро для запуска операционной системы. 

Стандарт UEFI также поддерживает функцию *Secure Boot*, которая позволяет выполнять только подписанные приложения EFI, то есть приложения EFI, авторизованные производителем оборудования. Эта функция увеличивает защиту от вредоносного программного обеспечения, но может затруднить установку операционных систем, на которые не распространяется гарантия производителя.


## Загрузчик

Самый популярный загрузчик для Linux на архитектуре x86 - это GRUB(*Grand Unified Bootloader*). Как только он вызывается BIOS или UEFI, GRUB отображает список операционных систем, доступных для загрузки. Иногда список не появляется автоматически, но его можно вызвать, нажав <kbd>Shift</kbd>, когда BIOS вызывает GRUB. В системах UEFI вместо этого следует использовать клавишу <kbd>Esc</kbd>. 

В меню GRUB можно выбрать, какое из установленных ядер должно быть загружено, и передать ему новые параметры. Большинство параметров ядра следуют шаблону `option=value`. Некоторые из наиболее полезных параметров ядра: 

* `acpi`   
Включает/отключает поддержку ACPI. `acpi=off` отключит поддержку ACPI. 
* `init`  
Устанавливает альтернативный системный инициатор. Например, `init=/bin/bash` установит оболочку Bash в качестве инициатора. Это означает, что сеанс оболочки начнется сразу после процесса загрузки ядра. 
* `systemd.unit`  
Устанавливает цель `systemd` для активации. Например, `systemd.unit=graphical.target`. Systemd также принимает числовые уровни запуска, определенные для *SysV*. Например, чтобы активировать уровень выполнения 1, необходимо только включить цифру `1` или букву `S`(сокращение от «single») в качестве параметра ядра. 
* `mem`  
Устанавливает объем доступной оперативной памяти для системы. Этот параметр полезен для виртуальных машин, чтобы ограничить объем оперативной памяти, доступной каждому гостю. Использование `mem=512M` ограничивает объем оперативной памяти, доступной для конкретной гостевой системы, до 512 мегабайт. 
* `maxcpus`  
Ограничивает количество процессоров(или ядер процессора), видимых системе в симметричных многопроцессорных машинах. Это также полезно для виртуальных машин. Значение 0 отключает поддержку многопроцессорных машин и имеет тот же эффект, что и параметр ядра `nosmp`. Параметр `maxcpus=2` ограничивает количество процессоров, доступных операционной системе, до двух. 
* `quiet`  
Скрывает большинство загрузочных сообщений. 
* `vga`  
Выбирает режим видео. Параметр `vga=ask` покажет список доступных режимов на выбор. 
* `root`  
Устанавливает корневой раздел, отличный от предварительно настроенного в загрузчике. Например, `root=/dev/sda3`.
* `rootflags`  
Параметры монтирования для корневой файловой системы. 
* `ro`
Делает первоначальное монтирование корневой файловой системы доступным только для чтения. 
* `rw`  
Разрешает запись в корневую файловую систему во время первоначального монтирования. 

Изменение параметров ядра обычно не требуется, но может быть полезно для обнаружения и решения проблем, связанных с операционной системой. Параметры ядра должны быть добавлены в файл `/etc/default/grub` в строке `GRUB_CMDLINE_LINUX`, чтобы сделать их постоянными при перезагрузках. Новый файл конфигурации для загрузчика должен создаваться каждый раз при изменении `/etc/default/grub`, что выполняется командой `grub-mkconfig -o /boot/grub/grub.cfg`. После запуска операционной системы параметры ядра, используемые для загрузки текущего сеанса, доступны для чтения в файле `/proc/cmdline`.

>Настройка GRUB будет обсуждаться далее в следующем уроке.


## Система инициализации

Помимо ядра, операционная система зависит от других компонентов, которые предоставляют ожидаемые функции. Многие из этих компонентов загружаются в процессе инициализации системы, от простых сценариев оболочки до более сложных служебных программ. Сценарии часто используются для выполнения краткосрочных задач, которые будут выполняться и завершаться в процессе инициализации системы. Службы, также известные как демоны, могут быть активны все время, поскольку они могут нести ответственность за внутренние аспекты операционной системы. 

Разнообразие способов, которыми сценарии запуска и демоны с самыми разными характеристиками могут быть встроены в дистрибутив Linux, огромно, и этот факт исторически препятствовал разработке единого решения, отвечающего ожиданиям сопровождающих и пользователей всех дистрибутивов Linux. Однако любой инструмент, выбранный разработчиками дистрибутива для выполнения этой функции, по крайней мере сможет запускать, останавливать и перезапускать системные службы. Эти действия часто выполняются самой системой, например, после обновления программного обеспечения, но системному администратору почти всегда необходимо вручную перезапускать службу после внесения изменений в ее файл конфигурации. 

Системному администратору также удобно иметь возможность активировать определенный набор демонов в зависимости от обстоятельств. Например, должна быть возможность запускать минимальный набор служб для выполнения задач обслуживания системы.

>Строго говоря, операционная система - это просто ядро и его компоненты, которые управляют оборудованием и всеми процессами. Однако обычно термин «операционная система» используется более свободно для обозначения целой группы отдельных программ, составляющих программную среду, в которой пользователь может выполнять основные вычислительные задачи.

Инициализация операционной системы начинается, когда загрузчик загружает ядро в ОЗУ. Затем ядро возьмет на себя ответственность за CPU и начнет обнаруживать и настраивать фундаментальные аспекты операционной системы, такие как базовая конфигурация оборудования и адресация памяти. 

Затем ядро откроет `initramfs`(*начальная файловая система RAM*). Initramfs это архив, содержащий файловую систему, используемую в качестве временной корневой файловой системы во время процесса загрузки. Основная цель файла initramfs - предоставить необходимые модули, чтобы ядро могло получить доступ к «настоящей» корневой файловой системе операционной системы.

Как только будет доступна корневая файловая система, ядро смонтирует все файловые системы, настроенные в `/etc/fstab`, а затем выполнит первую программу - утилиту с именем `init`. Программа `init` отвечает за запуск всех сценариев инициализации и системных демонов. Существуют различные реализации таких системных инициаторов, помимо традиционного init, такие как *systemd* и *Upstart*. После загрузки программы init файл initramfs удаляется из ОЗУ. 

**Стандарт SysV**  
Менеджер служб, основанный на стандарте SysVinit, контролирует, какие демоны и ресурсы будут доступны, используя концепцию *уровней выполнения*. Уровни выполнения пронумерованы от 0 до 6 и разработаны разработчиками дистрибутива для выполнения определенных задач. Единственные определения уровней выполнения, общие для всех дистрибутивов, - это уровни выполнения 0, 1 и 6. 

**systemd**  
systemd - это современный менеджер систем и служб с уровнем совместимости для команд и уровней запуска SysV. systemd имеет параллельную структуру, использует сокеты и D-Bus для активации служб, выполнения демона по требованию, мониторинга процессов с помощью *cgroups*, поддержки моментальных снимков, восстановления системного сеанса, управления точкой монтирования и управления службами на основе зависимостей. В последние годы большинство основных дистрибутивов Linux постепенно приняли systemd в качестве системного менеджера по умолчанию. 

**Upstart**  
Как и systemd, Upstart заменяет init. Цель Upstart - ускорить процесс загрузки за счет распараллеливания процесса загрузки системных служб. Upstart использовался в дистрибутивах на основе Ubuntu в прошлых выпусках, но сегодня уступил место systemd.


## Проверка инициализации

Ошибки могут возникать в процессе загрузки, но они могут быть не настолько критичными, чтобы полностью остановить работу операционной системы. Несмотря на это, эти ошибки могут нарушить ожидаемое поведение системы. Все ошибки приводят к сообщениям, которые можно использовать для будущих исследований, поскольку они содержат ценную информацию о том, когда и как произошла ошибка. Даже если сообщения об ошибках не генерируются, информация, собранная в процессе загрузки, может быть полезна для настройки и конфигурации. 

Пространство памяти, в котором ядро хранит свои сообщения, включая сообщения загрузки, называется *kernel ring buffer*. Сообщения хранятся в кольцевом буфере ядра, даже если они не отображаются во время процесса инициализации, например, когда вместо этого отображается анимация. Однако кольцевой буфер ядра теряет все сообщения при выключении системы или при выполнении команды `dmesg --clear`. Без параметров команда `dmesg` отображает текущие сообщения в кольцевом буфере ядра:
```console
$ dmesg
[    5.262389] EXT4-fs (sda1): mounted filesystem with ordered data mode. Opts: (null)
[    5.449712] ip_tables: (C) 2000-2006 Netfilter Core Team
[    5.460286] systemd[1]: systemd 237 running in system mode.
[    5.480138] systemd[1]: Detected architecture x86-64.
[    5.481767] systemd[1]: Set hostname to <torre>.
[    5.636607] systemd[1]: Reached target User and Group Name Lookups.
[    5.636866] systemd[1]: Created slice System Slice.
[    5.637000] systemd[1]: Listening on Journal Audit Socket.
[    5.637085] systemd[1]: Listening on Journal Socket.
[    5.637827] systemd[1]: Mounting POSIX Message Queue File System...
[    5.638639] systemd[1]: Started Read required files in advance.
[    5.641661] systemd[1]: Starting Load Kernel Modules...
[    5.661672] EXT4-fs (sda1): re-mounted. Opts: errors=remount-ro
[    5.694322] lp: driver loaded but no devices found
[    5.702609] ppdev: user-space parallel port driver
[    5.705384] parport_pc 00:02: reported by Plug and Play ACPI
[    5.705468] parport0: PC-style at 0x378 (0x778), irq 7, dma 3 [PCSPP,TRISTATE,COMPAT,EPP,ECP,DMA]
[    5.800146] lp0: using parport0 (interrupt-driven).
[    5.897421] systemd-journald[352]: Received request to flush runtime journal from PID 1
```
Вывод `dmesg` может состоять из сотен строк, поэтому предыдущий листинг содержит только отрывок, показывающий, как ядро вызывает диспетчер служб systemd. Значения в начале строк - это количество секунд относительно начала загрузки ядра. 

В системах на основе systemd команда `journalctl` покажет сообщения инициализации с параметрами `-b`, `--boot`, `-k` или `--dmesg`. Команда `journalctl --list-boots` показывает список номеров загрузки относительно текущей загрузки, их идентификационный хэш и временные метки первого и последнего соответствующих сообщений:
```console
$ journalctl --list-boots
 -4 9e5b3eb4952845208b841ad4dbefa1a6 Thu 2019-10-03 13:39:23 -03—Thu 2019-10-03 13:40:30 -03
 -3 9e3d79955535430aa43baa17758f40fa Thu 2019-10-03 13:41:15 -03—Thu 2019-10-03 14:56:19 -03
 -2 17672d8851694e6c9bb102df7355452c Thu 2019-10-03 14:56:57 -03—Thu 2019-10-03 19:27:16 -03
 -1 55c0d9439bfb4e85a20a62776d0dbb4d Thu 2019-10-03 19:27:53 -03—Fri 2019-10-04 00:28:47 -03
  0 08fbbebd9f964a74b8a02bb27b200622 Fri 2019-10-04 00:31:01 -03—Fri 2019-10-04 10:17:01 -03
```
Журналы предыдущих инициализаций также хранятся в системах на основе systemd, поэтому сообщения из предыдущих сеансов операционной системы все еще могут быть проверены. Если указаны параметры `-b 0` или `--boot=0`, то будут показаны сообщения для текущей загрузки. Опции `-b -1` или `--boot=-1` покажут сообщения от предыдущей инициализации. Опции `-b -2` или `--boot = -2` покажут сообщения от инициализации до этого и так далее. В следующем отрывке показано, как ядро вызывает диспетчер служб systemd для последнего процесса инициализации:
```console
$ journalctl -b 0
oct 04 00:31:01 ubuntu-host kernel: EXT4-fs (sda1): mounted filesystem with ordered data mode. Opts: (null)
oct 04 00:31:01 ubuntu-host kernel: ip_tables: (C) 2000-2006 Netfilter Core Team
oct 04 00:31:01 ubuntu-host systemd[1]: systemd 237 running in system mode.
oct 04 00:31:01 ubuntu-host systemd[1]: Detected architecture x86-64.
oct 04 00:31:01 ubuntu-host systemd[1]: Set hostname to <torre>.
oct 04 00:31:01 ubuntu-host systemd[1]: Reached target User and Group Name Lookups.
oct 04 00:31:01 ubuntu-host systemd[1]: Created slice System Slice.
oct 04 00:31:01 ubuntu-host systemd[1]: Listening on Journal Audit Socket.
oct 04 00:31:01 ubuntu-host systemd[1]: Listening on Journal Socket.
oct 04 00:31:01 ubuntu-host systemd[1]: Mounting POSIX Message Queue File System...
oct 04 00:31:01 ubuntu-host systemd[1]: Started Read required files in advance.
oct 04 00:31:01 ubuntu-host systemd[1]: Starting Load Kernel Modules...
oct 04 00:31:01 ubuntu-host kernel: EXT4-fs (sda1): re-mounted. Opts: commit=300,barrier=0,errors=remount-ro
oct 04 00:31:01 ubuntu-host kernel: lp: driver loaded but no devices found
oct 04 00:31:01 ubuntu-host kernel: ppdev: user-space parallel port driver
oct 04 00:31:01 ubuntu-host kernel: parport_pc 00:02: reported by Plug and Play ACPI
oct 04 00:31:01 ubuntu-host kernel: parport0: PC-style at 0x378 (0x778), irq 7, dma 3 [PCSPP,TRISTATE,COMPAT,EPP,ECP,DMA]
oct 04 00:31:01 ubuntu-host kernel: lp0: using parport0 (interrupt-driven).
oct 04 00:31:01 ubuntu-host systemd-journald[352]: Journal started
oct 04 00:31:01 ubuntu-host systemd-journald[352]: Runtime journal (/run/log/journal/abb765408f3741ae9519ab3b96063a15) is 4.9M, max 39.4M, 34.5M free.
oct 04 00:31:01 ubuntu-host systemd-modules-load[335]: Inserted module 'lp'
oct 04 00:31:01 ubuntu-host systemd-modules-load[335]: Inserted module 'ppdev'
oct 04 00:31:01 ubuntu-host systemd-modules-load[335]: Inserted module 'parport_pc'
oct 04 00:31:01 ubuntu-host systemd[1]: Starting Flush Journal to Persistent Storage...
```
Инициализация и другие сообщения, выдаваемые операционной системой, хранятся в файлах в каталоге `/var/log/`. Если происходит критическая ошибка и операционная система не может продолжить процесс инициализации после загрузки ядра и initramfs, можно использовать альтернативный загрузочный носитель для запуска системы и доступа к соответствующей файловой системе. Затем файлы в `/var/log/` могут быть найдены на предмет возможных причин, вызывающих прерывание процесса загрузки. Параметры `-D` или `--directory` команды `journalctl` могут использоваться для чтения сообщений журнала в каталогах, отличных от `/var/log/ journal/`, который является местоположением по умолчанию для сообщений журнала systemd. Поскольку сообщения журнала systemd не хранятся в виде необработанного текста, для их чтения требуется команда `journalctl`.


## Упражнения для закрепления

1. Где находится двоичный файл начальной загрузки на машине с прошивкой BIOS? 


2. Прошивка UEFI поддерживает расширенные функции, предоставляемые внешними программами, называемые приложениями EFI. Однако эти приложения имеют свое особое местоположение. Где в системе будут расположены приложения EFI? 


3. Загрузчики позволяют передавать пользовательские параметры ядра перед его загрузкой. Предположим, что система не может загрузиться из-за неверного расположения корневой файловой системы. Как правильно указать корневую файловую систему, расположенную в `/dev/sda3`, в качестве параметра для ядра?


4. Процесс загрузки Linux-машины заканчивается следующим сообщением:
```console
ALERT! /dev/sda3 does not exist. Dropping to a shell!
```
Какова вероятная причина этой проблемы?


## Упражнения на размышление

1. Загрузчик представит список операционных систем на выбор, если на машине установлено несколько операционных систем. Однако недавно установленная операционная система может перезаписать MBR жесткого диска, стирая первую стадию загрузчика и делая другую операционную систему недоступной. Почему этого не произошло бы на машине с прошивкой UEFI? 

2. Каковы общие последствия установки собственного ядра без предоставления соответствующего образа initramfs? 

3. Журнал инициализации состоит из сотен строк, поэтому выходные данные команды `dmesg` часто передаются по конвейеру команде пейджера - например, command `less` - для облегчения чтения. Какая опция `dmesg` будет автоматически разбивать свой вывод на страницы, избавляя от необходимости явно использовать команду пейджера? 

4. Жесткий диск, содержащий всю файловую систему автономной машины, был удален и подключен к рабочей машине в качестве дополнительного диска. Предполагая, что его точка монтирования - `/mnt/hd`, как будет использоваться `journalctl` для проверки содержимого файлов журнала, расположенных в `/mnt/hd/var/log/journal/`?


## Резюме

В этом уроке рассматривается последовательность загрузки в стандартной системе Linux. Правильное знание того, как работает процесс загрузки системы Linux, помогает предотвратить ошибки, которые могут сделать систему недоступной. Урок проходит по следующим тематическим направлениям: 
* Чем отличаются методы загрузки BIOS и UEFI. 
* Типовые этапы инициализации системы. 
* Восстановление загрузочных сообщений. 

Были рассмотрены следующие команды и процедуры: 
* Общие параметры ядра. 
* Команды для чтения загрузочных сообщений: `dmesg` и `journalctl`.


## Ответы на упражнения для закрепления

**1. Где находится двоичный файл начальной загрузки на машине с прошивкой BIOS?**
В MBR первого запоминающего устройства, как определено в утилите конфигурирования BIOS.

**2. Прошивка UEFI поддерживает расширенные функции, предоставляемые внешними программами, называемые приложениями EFI. Однако эти приложения имеют свое особое местоположение. Где в системе будут расположены приложения EFI?**
Приложения EFI хранятся в системном разделе EFI (ESP), расположенном в любом доступном блоке хранения с совместимой файловой системой (обычно файловой системой FAT32).

**3. Загрузчики позволяют передавать пользовательские параметры ядра перед его загрузкой. Предположим, что система не может загрузиться из-за неверного расположения корневой файловой системы. Как правильно указать корневую файловую систему, расположенную в `/dev/sda3`, в качестве параметра для ядра?**
Приложения EFI хранятся в системном разделе EFI(ESP), расположенном в любом доступном блоке хранения с совместимой файловой системой(обычно файловой системой FAT32).

**4. Процесс загрузки Linux-машины заканчивается следующим сообщением:
```console
ALERT! /dev/sda3 does not exist. Dropping to a shell!
```
Какова вероятная причина этой проблемы?**
Ядру не удалось найти устройство `/dev/sda3`, указанное как корневая файловая система.


## Ответы на упражнения для размышления


**1. Загрузчик представит список операционных систем на выбор, если на машине установлено несколько операционных систем. Однако недавно установленная операционная система может перезаписать MBR жесткого диска, стирая первую стадию загрузчика и делая другую операционную систему недоступной. Почему этого не произошло бы на машине с прошивкой UEFI?**
Машины с UEFI не используют MBR жесткого диска для хранения первой стадии загрузчика.

**2. Каковы общие последствия установки собственного ядра без предоставления соответствующего образа initramfs?**
Корневая файловая система может быть недоступна, если ее тип был скомпилирован как внешний модуль ядра.

**3. Журнал инициализации состоит из сотен строк, поэтому выходные данные команды `dmesg` часто передаются по конвейеру команде пагинации - например, команда `less` - для облегчения чтения. Какая опция `dmesg` будет автоматически разбивать свой вывод на страницы, избавляя от необходимости явно использовать команду пагинатора?**
Команды `dmesg -H` или `dmesg --human` по умолчанию включают пагинацию.

**4. Жесткий диск, содержащий всю файловую систему автономной машины, был удален и подключен к рабочей машине в качестве дополнительного диска. Предполагая, что его точка монтирования - `/mnt/hd`, как будет использоваться `journalctl` для проверки содержимого файлов журнала, расположенных в `/mnt/hd/var/log/journal/`?**
С помощью команд `journalctl -D /mnt/hd/var/log/journal` или `journalctl --directory=/mnt/hd/var/log/journal`
