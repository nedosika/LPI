# 101.1 Урок 1

| Сертификат:   |LPIC-1                                                 |
|:--------------|:------------------------------------------------------|
| Версия:       | 5.0                                                   |
| Тема:         | 101 Системная архитектура                             |
| Цель:         | 101.1 Определение и настройка параметров оборудования |
| Урок:         | 1 из 1                                                |

# Введение

С первых лет развития вычислительной техники производители коммерческих и персональных компьютеров интегрировали в свои
машины различное оборудование, которое, в свою очередь, должно поддерживаться операционной системой. Если в отрасли не 
будут установлены стандарты для наборов команд и взаимодействия с устройствами - это может быть ошеломляющим с точки 
зрения разработчиков операционных систем. Подобно стандартизированному уровню абстракции, предоставляемому операционной 
системой приложению, эти стандарты упрощают написание и поддержку операционной системы, не привязанной к конкретной 
модели оборудования. Однако сложность интегрированного базового оборудования иногда требует настройки того, как 
ресурсы должны быть доступны операционной системе, чтобы ее можно было установить и она корректно работала.

Некоторые из этих настроек можно выполнить даже без установленной операционной системы. Большинство машин предлагают 
утилиту настройки, которую можно запускать при включении машины. До середины 2000-х утилита конфигурирования была 
реализована в BIOS (Basic Input / Output System), стандарте микропрограмм, содержащем базовые процедуры 
конфигурирования материнских плат x86. С конца первого десятилетия 2000-х годов машины на базе архитектуры x86 начали 
заменять BIOS новой реализацией под названием UEFI (Unified Extensible Firmware Interface), который имеет более 
продвинутые функции для идентификации, тестирования, настройки и обновления прошивки. Несмотря на это изменение,
нередко по-прежнему вызывается конфигурационная утилита BIOS, поскольку обе реализации служат одной и той же основной 
цели.

> Дополнительные сведения о сходствах и различиях между BIOS и UEFI будут рассмотрены в следующем уроке.


# Активация устройств

Утилита настройки системы открывается после нажатия определенной клавиши при включении компьютера. Выбор кнопки зависит от производителя, но обычно это Del или одна из функциональных клавиш, например F2 или F12. Используемая комбинация клавиш часто отображается на экране включения.

В программе настройки BIOS можно включать и отключать встроенные периферийные устройства, активировать базовую защиту от ошибок и изменять параметры оборудования, такие как IRQ (запрос прерывания) и DMA (прямой доступ к памяти). Изменение этих настроек редко требуется на современных машинах, но может потребоваться внести коррективы для решения конкретных проблем. Например, есть технологии RAM, которые совместимы с более высокими скоростями передачи данных, чем значения по умолчанию, поэтому рекомендуется изменить их на значения, рекомендуемые производителем. Некоторые процессоры предлагают функции, которые могут не потребоваться для конкретной установки и могут быть отключены. Отключенные функции снизят энергопотребление и могут повысить защиту системы, поскольку функции ЦП, содержащие известные ошибки, также могут быть отключены.

Если машина оборудована множеством устройств хранения, важно определить, какое из них имеет правильный загрузчик и должно быть первой записью в порядке загрузки устройства. Операционная система может не загрузиться, если неправильное устройство отображается первым в списке загрузки BIOS.


# Проверка устройств в Linux

После того, как устройства будут правильно идентифицированы, операционная система должна связать необходимые им программные компоненты. Когда новое устройство не работает должным образом, важно определить, где именно возникла проблема. Когда аппаратное обеспечение не обнаруживается операционной системой, наиболее вероятно, что этот компонент или порт, к которому он подключен, неисправен. Если аппаратная часть определена правильно, но по-прежнему не работает должным образом, возможно, проблема связана с операционной системой. Поэтому одним из первых шагов при решении проблем, связанных с оборудованием, является проверка того, правильно ли операционная система определяет устройство. Есть два основных способа идентифицировать аппаратные ресурсы в системе Linux: использовать специализированные команды или читать определенные файлы внутри специальных файловых систем.


# Комманды для проверки 

Две основные команды для идентификации подключенных устройств в системе Linux:

*lspci*
>Показывает все устройства, подключенные в данный момент к шине PCI (Peripheral Component Interconnect). Устройства PCI могут быть либо компонентом, прикрепленным к материнской плате, например контроллером диска, либо картой расширения, установленной в слот PCI, например внешней видеокартой.

*lsusb*
>Список устройств USB (универсальная последовательная шина), подключенных к ПК в данный момент. Хотя существуют USB-устройства практически для любых мыслимых целей, интерфейс USB в основном используется для подключения устройств ввода - клавиатуры, указывающих устройств - и съемных носителей.

Вывод команд *lspci* и *lsusb* состоит из списка всех устройств PCI и USB, идентифицированных операционной системой. Однако устройство может быть еще не полностью работоспособным, потому что для каждой части оборудования требуется программный компонент для управления соответствующим устройством. Этот программный компонент называется модулем ядра и может быть частью официального ядра Linux или добавлен отдельно из других источников.

Модули ядра Linux, относящиеся к аппаратным устройствам, также называются драйверами, как и в других операционных системах. Однако драйверы для Linux не всегда поставляются производителем устройства. Хотя некоторые производители предоставляют свои собственные бинарные драйверы для отдельной установки, многие драйверы написаны независимыми разработчиками. Исторически сложилось так, что части, которые работают в Windows, например, могут не иметь аналога модуля ядра для Linux. В настоящее время операционные системы на базе Linux имеют сильную аппаратную поддержку, и большинство устройств работают без особых усилий.

Команды, непосредственно связанные с оборудованием, часто требуют для выполнения прав root или будут отображать только ограниченную информацию при выполнении обычным пользователем, поэтому может потребоваться войти в систему как root или выполнить команду с помощью sudo.

Следующий вывод команды lspci, например, показывает несколько идентифицированных устройств:
```
$ lspci
01:00.0 VGA compatible controller: NVIDIA Corporation GM107 [GeForce GTX 750 Ti] (rev a2)
04:02.0 Network controller: Ralink corp. RT2561/RT61 802.11g PCI
04:04.0 Multimedia audio controller: VIA Technologies Inc. ICE1712 [Envy24] PCI Multi-Channel I/O Controller (rev 02)
04:0b.0 FireWire (IEEE 1394): LSI Corporation FW322/323 [TrueFire] 1394a Controller (rev 70)
```
Вывод таких команд может состоять из десятков строк, поэтому предыдущий и следующий примеры содержат только интересующие их разделы. Шестнадцатеричные числа в начале каждой строки - это уникальные адреса соответствующего устройства PCI. Команда lspci показывает более подробную информацию о конкретном устройстве, если его адрес указан с параметром -s вместе с параметром -v:
```
$ lspci -s 04:02.0 -v
04:02.0 Network controller: Ralink corp. RT2561/RT61 802.11g PCI
    Subsystem: Linksys WMP54G v4.1
    Flags: bus master, slow devsel, latency 32, IRQ 21
    Memory at e3100000 (32-bit, non-prefetchable) [size=32K]
    Capabilities: [40] Power Management version 2
    kernel driver in use: rt61pci
 ```
Теперь в выходных данных отображается гораздо больше деталей устройства по адресу 04: 02.0. Это сетевой контроллер, внутреннее имя которого - Ralink corp. RT2561/RT61 802.11g PCI. Подсистема связана с маркой и моделью устройства - Linksys WMP54G v4.1 - и может быть полезна для диагностических целей.

Модуль ядра можно определить в строке используемого драйвера ядра, которая показывает модуль rt61pci. Исходя из всей собранной информации, можно предположить, что:
1. Устройство было идентифицировано. 
2. Был загружен соответствующий модуль ядра. 
3. Устройство готово к работе.

Другой способ проверить, какой модуль ядра используется для указанного устройства, - это опция -k, доступная в более поздних версиях lspci:
```
$ lspci -s 01:00.0 -k
01:00.0 VGA compatible controller: NVIDIA Corporation GM107 [GeForce GTX 750 Ti] (rev a2)
   kernel driver in use: nvidia
   kernel modules: nouveau, nvidia_drm, nvidia
```
Для выбранного устройства, платы NVIDIA GPU, lspci сообщает, что используемый модуль называется nvidia, в строке используется драйвер ядра: nvidia и все соответствующие модули ядра перечислены в строке модулей ядра: nouveau, nvidia_drm, nvidia.

Команда lsusb похожа на lspci, но перечисляет исключительно информацию USB:
```
$ lsusb
Bus 001 Device 029: ID 1781:0c9f Multiple Vendors USBtiny
Bus 001 Device 028: ID 093a:2521 Pixart Imaging, Inc. Optical Mouse
Bus 001 Device 020: ID 1131:1001 Integrated System Solution Corp. KY-BT100 Bluetooth Adapter
Bus 001 Device 011: ID 04f2:0402 Chicony Electronics Co., Ltd Genius LuxeMate i200 Keyboard
Bus 001 Device 007: ID 0424:7800 Standard Microsystems Corp.
Bus 001 Device 003: ID 0424:2514 Standard Microsystems Corp. USB 2.0 Hub
Bus 001 Device 002: ID 0424:2514 Standard Microsystems Corp. USB 2.0 Hub
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
```
Команда lsusb показывает доступные каналы USB и подключенные к ним устройства. Как и в случае с lspci, опция -v отображает более подробный вывод. Конкретное устройство можно выбрать для проверки, указав его идентификатор в опции -d:
```
$ lsusb -v -d 1781:0c9f
Bus 001 Device 029: ID 1781:0c9f Multiple Vendors USBtiny
Device Descriptor:
  bLength                18
  bDescriptorType         1
  bcdUSB               1.01
  bDeviceClass          255 Vendor Specific Class
  bDeviceSubClass         0
  bDeviceProtocol         0
  bMaxPacketSize0         8
  idVendor           0x1781 Multiple Vendors
  idProduct          0x0c9f USBtiny
  bcdDevice            1.04
  iManufacturer           0
  iProduct                2 USBtiny
  iSerial                 0
  bNumConfigurations      1
```
С параметром -t команда lsusb показывает текущие сопоставления USB-устройств в виде иерархического дерева:
```
$ lsusb -t
/:  Bus 01.Port 1: Dev 1, Class=root_hub, Driver=dwc_otg/1p, 480M
    |__ Port 1: Dev 2, If 0, Class=Hub, Driver=hub/4p, 480M
        |__ Port 1: Dev 3, If 0, Class=Hub, Driver=hub/3p, 480M
            |__ Port 2: Dev 11, If 1, Class=Human Interface Device, Driver=usbhid, 1.5M
            |__ Port 2: Dev 11, If 0, Class=Human Interface Device, Driver=usbhid, 1.5M
            |__ Port 3: Dev 20, If 0, Class=Wireless, Driver=btusb, 12M
            |__ Port 3: Dev 20, If 1, Class=Wireless, Driver=btusb, 12M
            |__ Port 3: Dev 20, If 2, Class=Application Specific Interface, Driver=, 12M
            |__ Port 1: Dev 7, If 0, Class=Vendor Specific Class, Driver=lan78xx, 480M
        |__ Port 2: Dev 28, If 0, Class=Human Interface Device, Driver=usbhid, 1.5M
        |__ Port 3: Dev 29, If 0, Class=Vendor Specific Class, Driver=, 1.5M
```
Возможно, не со всеми устройствами связаны соответствующие модули. Связь с определенными устройствами может осуществляться приложением напрямую, без посредничества, обеспечиваемого модулем. Тем не менее, вывод lsusb -t содержит важную информацию. Когда соответствующий модуль существует, его имя появляется в конце строки для устройства, как в Driver = btusb. Устройство Class определяет общую категорию, например, Human Interface Device, Wireless, Vendor Specific Class, Mass Storage и другие. Чтобы проверить, какое устройство использует модуль btusb, представленный в предыдущем листинге, необходимо указать номера Bus и Dev в параметре -s команды lsusb:
```
$ lsusb -s 01:20
Bus 001 Device 020: ID 1131:1001 Integrated System Solution Corp. KY-BT100 Bluetooth Adapter
```
Обычно в стандартной системе Linux всегда есть большой набор загруженных модулей ядра. Предпочтительный способ взаимодействия с ними - использовать команды, предоставляемые пакетом kmod, который представляет собой набор инструментов для обработки общих задач с модулями ядра Linux, таких как вставка, удаление, список, проверка свойств, разрешение зависимостей и псевдонимов. Например, команда lsmod показывает все загруженные в данный момент модули:
```
$ lsmod
Module                  Size  Used by
kvm_intel             138528  0
kvm                   421021  1 kvm_intel
iTCO_wdt               13480  0
iTCO_vendor_support    13419  1 iTCO_wdt
snd_usb_audio         149112  2
snd_hda_codec_realtek  51465  1
snd_ice1712            75006  3
snd_hda_intel          44075  7
arc4                   12608  2
snd_cs8427             13978  1 snd_ice1712
snd_i2c                13828  2 snd_ice1712,snd_cs8427
snd_ice17xx_ak4xxx     13128  1 snd_ice1712
snd_ak4xxx_adda        18487  2 snd_ice1712,snd_ice17xx_ak4xxx
microcode              23527  0
snd_usbmidi_lib        24845  1 snd_usb_audio
gspca_pac7302          17481  0
gspca_main             36226  1 gspca_pac7302
videodev              132348  2 gspca_main,gspca_pac7302
rt61pci                32326  0
rt2x00pci              13083  1 rt61pci
media                  20840  1 videodev
rt2x00mmio             13322  1 rt61pci
hid_dr                 12776  0
snd_mpu401_uart        13992  1 snd_ice1712
rt2x00lib              67108  3 rt61pci,rt2x00pci,rt2x00mmio
snd_rawmidi            29394  2 snd_usbmidi_lib,snd_mpu401_uart
```
Вывод команды lsmod разделен на три столбца:
Module
>Название модуля. 
Size 
>Объем оперативной памяти, занятой модулем, в байтах. 
Used by 
>Зависимости от модулей.

Некоторым модулям для правильной работы требуются другие модули, как в случае с модулями для аудиоустройств:
```
$ lsmod | fgrep -i snd_hda_intel
snd_hda_intel          42658  5
snd_hda_codec         155748  3 snd_hda_codec_hdmi,snd_hda_codec_via,snd_hda_intel
snd_pcm                81999  3 snd_hda_codec_hdmi,snd_hda_codec,snd_hda_intel
snd_page_alloc         13852  2 snd_pcm,snd_hda_intel
snd                    59132  19 snd_hwdep,snd_timer,snd_hda_codec_hdmi,snd_hda_codec_via,snd_pcm,snd_seq,snd_hda_codec,snd_hda_intel,snd_seq_device
```
В третьем столбце Used by показаны модули, которым для правильной работы требуется модуль из первого столбца. Многие модули звуковой архитектуры Linux с префиксом snd взаимозависимы. При поиске проблем во время диагностики системы может быть полезно выгрузить определенные модули, загруженные в данный момент. Команда modprobe может использоваться как для загрузки, так и для выгрузки модулей ядра: для выгрузки модуля и связанных с ним модулей, если они не используются запущенным процессом, следует использовать команду modprobe -r. Например, чтобы выгрузить модуль snd-hda-intel (модуль для аудиоустройства HDA Intel) и другие модули, относящиеся к звуковой системе:
```
# modprobe -r snd-hda-intel
```
В дополнение к загрузке и выгрузке модулей ядра во время работы системы, можно изменять параметры модуля во время загрузки ядра, не так сильно отличается от передачи параметров командам. Каждый модуль принимает определенные параметры, но в большинстве случаев рекомендуются значения по умолчанию, а дополнительные параметры не требуются. Однако в некоторых случаях необходимо использовать параметры, чтобы изменить поведение модуля, чтобы он работал должным образом. 

Используя имя модуля в качестве единственного аргумента, команда modinfo показывает описание, файл, автора, лицензию, идентификацию, зависимости и доступные параметры для данного модуля. Настроенные параметры для модуля можно сделать постоянными, включив их в файл /etc/modprobe.conf или в отдельные файлы с расширением .conf в каталоге /etc/modprobe.d/. Опция -p заставит команду modinfo отображать все доступные параметры и игнорировать другую информацию:
```
# modinfo -p nouveau
vram_pushbuf:Create DMA push buffers in VRAM (int)
tv_norm:Default TV norm.
                Supported: PAL, PAL-M, PAL-N, PAL-Nc, NTSC-M, NTSC-J,
                        hd480i, hd480p, hd576i, hd576p, hd720p, hd1080i.
                Default: PAL
                NOTE Ignored for cards with external TV encoders. (charp)
nofbaccel:Disable fbcon acceleration (int)
fbcon_bpp:fbcon bits-per-pixel (default: auto) (int)
mst:Enable DisplayPort multi-stream (default: enabled) (int)
tv_disable:Disable TV-out detection (int)
ignorelid:Ignore ACPI lid status (int)
duallink:Allow dual-link TMDS (default: enabled) (int)
hdmimhz:Force a maximum HDMI pixel clock (in MHz) (int)
config:option string to pass to driver core (charp)
debug:debug string to pass to driver core (charp)
noaccel:disable kernel/abi16 acceleration (int)
modeset:enable driver (default: auto, 0 = disabled, 1 = enabled, 2 = headless) (int)
atomic:Expose atomic ioctl (default: disabled) (int)
runpm:disable (0), force enable (1), optimus only default (-1) (int)
```
В выходных данных примера показаны все параметры, доступные для module nouveau, модуля ядра, предоставленного Nouveau Project в качестве альтернативы проприетарным драйверам для карт NVIDIA GPU. Например, параметр modeset позволяет контролировать, будут ли разрешение и глубина отображения устанавливаться в пространстве ядра, а не в пространстве пользователя. Добавление параметров nouveau modeset = 0 в файл /etc/modprobe.d/nouveau.conf отключит функцию ядра modeset.

Если модуль вызывает проблемы, файл /etc/modprobe.d/blacklist.conf можно использовать для блокировки загрузки модуля. Например, чтобы предотвратить автоматическую загрузку модуля nouveau, необходимо добавить строку blacklist nouveau в файл /etc/modprobe.d/blacklist.conf. Это действие требуется, если установлен проприетарный модуль nvidia и модуль nouveau по умолчанию следует отключить.
>Вы можете изменить файл /etc/modprobe.d/blacklist.conf, который уже существует в >системе по умолчанию. Однако предпочтительным методом является создание отдельного >файла конфигурации, /etc/modprobe.d/ <module_name> .conf, который будет содержать >настройки, специфичные только для данного модуля ядра.
