# 101.1 Урок 1

| Сертификат:   |LPIC-1                                                 |
|:--------------|:------------------------------------------------------|
| Версия:       | 5.0                                                   |
| Тема:         | 101 Системная архитектура                             |
| Цель:         | 101.1 Определение и настройка параметров оборудования |
| Урок:         | 1 из 1                                                |

# Введение

С первых лет развития вычислительной техники производители коммерческих и персональных компьютеров интегрировали в свои
машины различное оборудование, которое, в свою очередь, должно поддерживаться операционной системой. Если в отрасли не 
будут установлены стандарты для наборов команд и взаимодействия с устройствами - это может быть ошеломляющим с точки 
зрения разработчиков операционных систем. Подобно стандартизированному уровню абстракции, предоставляемому операционной 
системой приложению, эти стандарты упрощают написание и поддержку операционной системы, не привязанной к конкретной 
модели оборудования. Однако сложность интегрированного базового оборудования иногда требует настройки того, как 
ресурсы должны быть доступны операционной системе, чтобы ее можно было установить и она корректно работала.

Некоторые из этих настроек можно выполнить даже без установленной операционной системы. Большинство машин предлагают 
утилиту настройки, которую можно запускать при включении машины. До середины 2000-х утилита конфигурирования была 
реализована в BIOS (Basic Input / Output System), стандарте микропрограмм, содержащем базовые процедуры 
конфигурирования материнских плат x86. С конца первого десятилетия 2000-х годов машины на базе архитектуры x86 начали 
заменять BIOS новой реализацией под названием UEFI (Unified Extensible Firmware Interface), который имеет более 
продвинутые функции для идентификации, тестирования, настройки и обновления прошивки. Несмотря на это изменение,
нередко по-прежнему вызывается конфигурационная утилита BIOS, поскольку обе реализации служат одной и той же основной 
цели.

> Дополнительные сведения о сходствах и различиях между BIOS и UEFI будут рассмотрены в следующем уроке.


# Активация устройств

Утилита настройки системы открывается после нажатия определенной клавиши при включении компьютера. Выбор кнопки зависит от производителя, но обычно это Del или одна из функциональных клавиш, например F2 или F12. Используемая комбинация клавиш часто отображается на экране включения.

В программе настройки BIOS можно включать и отключать встроенные периферийные устройства, активировать базовую защиту от ошибок и изменять параметры оборудования, такие как IRQ (запрос прерывания) и DMA (прямой доступ к памяти). Изменение этих настроек редко требуется на современных машинах, но может потребоваться внести коррективы для решения конкретных проблем. Например, есть технологии RAM, которые совместимы с более высокими скоростями передачи данных, чем значения по умолчанию, поэтому рекомендуется изменить их на значения, рекомендуемые производителем. Некоторые процессоры предлагают функции, которые могут не потребоваться для конкретной установки и могут быть отключены. Отключенные функции снизят энергопотребление и могут повысить защиту системы, поскольку функции ЦП, содержащие известные ошибки, также могут быть отключены.

Если машина оборудована множеством устройств хранения, важно определить, какое из них имеет правильный загрузчик и должно быть первой записью в порядке загрузки устройства. Операционная система может не загрузиться, если неправильное устройство отображается первым в списке загрузки BIOS.


# Проверка устройств в Linux

После того, как устройства будут правильно идентифицированы, операционная система должна связать необходимые им программные компоненты. Когда новое устройство не работает должным образом, важно определить, где именно возникла проблема. Когда аппаратное обеспечение не обнаруживается операционной системой, наиболее вероятно, что этот компонент или порт, к которому он подключен, неисправен. Если аппаратная часть определена правильно, но по-прежнему не работает должным образом, возможно, проблема связана с операционной системой. Поэтому одним из первых шагов при решении проблем, связанных с оборудованием, является проверка того, правильно ли операционная система определяет устройство. Есть два основных способа идентифицировать аппаратные ресурсы в системе Linux: использовать специализированные команды или читать определенные файлы внутри специальных файловых систем.


# Комманды для проверки 

Две основные команды для идентификации подключенных устройств в системе Linux:

*lspci*
>Показывает все устройства, подключенные в данный момент к шине PCI (Peripheral Component Interconnect). Устройства PCI могут быть либо компонентом, прикрепленным к материнской плате, например контроллером диска, либо картой расширения, установленной в слот PCI, например внешней видеокартой.

*lsusb*
>Список устройств USB (универсальная последовательная шина), подключенных к ПК в данный момент. Хотя существуют USB-устройства практически для любых мыслимых целей, интерфейс USB в основном используется для подключения устройств ввода - клавиатуры, указывающих устройств - и съемных носителей.

Вывод команд *lspci* и *lsusb* состоит из списка всех устройств PCI и USB, идентифицированных операционной системой. Однако устройство может быть еще не полностью работоспособным, потому что для каждой части оборудования требуется программный компонент для управления соответствующим устройством. Этот программный компонент называется модулем ядра и может быть частью официального ядра Linux или добавлен отдельно из других источников.

Модули ядра Linux, относящиеся к аппаратным устройствам, также называются драйверами, как и в других операционных системах. Однако драйверы для Linux не всегда поставляются производителем устройства. Хотя некоторые производители предоставляют свои собственные бинарные драйверы для отдельной установки, многие драйверы написаны независимыми разработчиками. Исторически сложилось так, что части, которые работают в Windows, например, могут не иметь аналога модуля ядра для Linux. В настоящее время операционные системы на базе Linux имеют сильную аппаратную поддержку, и большинство устройств работают без особых усилий.

Команды, непосредственно связанные с оборудованием, часто требуют для выполнения прав root или будут отображать только ограниченную информацию при выполнении обычным пользователем, поэтому может потребоваться войти в систему как root или выполнить команду с помощью sudo.

Следующий вывод команды lspci, например, показывает несколько идентифицированных устройств:
```
$ lspci
01:00.0 VGA compatible controller: NVIDIA Corporation GM107 [GeForce GTX 750 Ti] (rev a2)
04:02.0 Network controller: Ralink corp. RT2561/RT61 802.11g PCI
04:04.0 Multimedia audio controller: VIA Technologies Inc. ICE1712 [Envy24] PCI Multi-Channel I/O Controller (rev 02)
04:0b.0 FireWire (IEEE 1394): LSI Corporation FW322/323 [TrueFire] 1394a Controller (rev 70)
```
Вывод таких команд может состоять из десятков строк, поэтому предыдущий и следующий примеры содержат только интересующие их разделы. Шестнадцатеричные числа в начале каждой строки - это уникальные адреса соответствующего устройства PCI. Команда lspci показывает более подробную информацию о конкретном устройстве, если его адрес указан с параметром -s вместе с параметром -v:
```
$ lspci -s 04:02.0 -v
04:02.0 Network controller: Ralink corp. RT2561/RT61 802.11g PCI
    Subsystem: Linksys WMP54G v4.1
    Flags: bus master, slow devsel, latency 32, IRQ 21
    Memory at e3100000 (32-bit, non-prefetchable) [size=32K]
    Capabilities: [40] Power Management version 2
    kernel driver in use: rt61pci
 ```
Теперь в выходных данных отображается гораздо больше деталей устройства по адресу 04: 02.0. Это сетевой контроллер, внутреннее имя которого - Ralink corp. RT2561/RT61 802.11g PCI. Подсистема связана с маркой и моделью устройства - Linksys WMP54G v4.1 - и может быть полезна для диагностических целей.

Модуль ядра можно определить в строке используемого драйвера ядра, которая показывает модуль rt61pci. Исходя из всей собранной информации, можно предположить, что:
1. Устройство было идентифицировано. 
2. Был загружен соответствующий модуль ядра. 
3. Устройство готово к работе.

Другой способ проверить, какой модуль ядра используется для указанного устройства, - это опция -k, доступная в более поздних версиях lspci:
```
$ lspci -s 01:00.0 -k
01:00.0 VGA compatible controller: NVIDIA Corporation GM107 [GeForce GTX 750 Ti] (rev a2)
   kernel driver in use: nvidia
   kernel modules: nouveau, nvidia_drm, nvidia
```
Для выбранного устройства, платы NVIDIA GPU, lspci сообщает, что используемый модуль называется nvidia, в строке используется драйвер ядра: nvidia и все соответствующие модули ядра перечислены в строке модулей ядра: nouveau, nvidia_drm, nvidia.

Команда lsusb похожа на lspci, но перечисляет исключительно информацию USB:
```
$ lsusb
Bus 001 Device 029: ID 1781:0c9f Multiple Vendors USBtiny
Bus 001 Device 028: ID 093a:2521 Pixart Imaging, Inc. Optical Mouse
Bus 001 Device 020: ID 1131:1001 Integrated System Solution Corp. KY-BT100 Bluetooth Adapter
Bus 001 Device 011: ID 04f2:0402 Chicony Electronics Co., Ltd Genius LuxeMate i200 Keyboard
Bus 001 Device 007: ID 0424:7800 Standard Microsystems Corp.
Bus 001 Device 003: ID 0424:2514 Standard Microsystems Corp. USB 2.0 Hub
Bus 001 Device 002: ID 0424:2514 Standard Microsystems Corp. USB 2.0 Hub
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
```
Команда lsusb показывает доступные каналы USB и подключенные к ним устройства. Как и в случае с lspci, опция -v отображает более подробный вывод. Конкретное устройство можно выбрать для проверки, указав его идентификатор в опции -d:
```
$ lsusb -v -d 1781:0c9f
Bus 001 Device 029: ID 1781:0c9f Multiple Vendors USBtiny
Device Descriptor:
  bLength                18
  bDescriptorType         1
  bcdUSB               1.01
  bDeviceClass          255 Vendor Specific Class
  bDeviceSubClass         0
  bDeviceProtocol         0
  bMaxPacketSize0         8
  idVendor           0x1781 Multiple Vendors
  idProduct          0x0c9f USBtiny
  bcdDevice            1.04
  iManufacturer           0
  iProduct                2 USBtiny
  iSerial                 0
  bNumConfigurations      1
```
С параметром -t команда lsusb показывает текущие сопоставления USB-устройств в виде иерархического дерева:
```
$ lsusb -t
/:  Bus 01.Port 1: Dev 1, Class=root_hub, Driver=dwc_otg/1p, 480M
    |__ Port 1: Dev 2, If 0, Class=Hub, Driver=hub/4p, 480M
        |__ Port 1: Dev 3, If 0, Class=Hub, Driver=hub/3p, 480M
            |__ Port 2: Dev 11, If 1, Class=Human Interface Device, Driver=usbhid, 1.5M
            |__ Port 2: Dev 11, If 0, Class=Human Interface Device, Driver=usbhid, 1.5M
            |__ Port 3: Dev 20, If 0, Class=Wireless, Driver=btusb, 12M
            |__ Port 3: Dev 20, If 1, Class=Wireless, Driver=btusb, 12M
            |__ Port 3: Dev 20, If 2, Class=Application Specific Interface, Driver=, 12M
            |__ Port 1: Dev 7, If 0, Class=Vendor Specific Class, Driver=lan78xx, 480M
        |__ Port 2: Dev 28, If 0, Class=Human Interface Device, Driver=usbhid, 1.5M
        |__ Port 3: Dev 29, If 0, Class=Vendor Specific Class, Driver=, 1.5M
```
