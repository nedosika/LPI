# 102.3 Урок 1

| **Сертификат:** | LPIC-1                                    |
|:----------------|:------------------------------------------|
| **Версия:**     | 5.0                                       |
| **Тема:**       | 102 Установка Linux и управление пакетами |
| **Цель:**       | 102.3 Управление общими библиотеками      |
| **Урок:**       | 1 из 1                                    |


## Введение

В этом уроке мы обсудим *общие библиотеки*, также известные как *общие объекты*: части скомпилированного многократно используемого кода, такие как функции или классы, которые периодически используются различными программами. 

Для начала мы объясним, что такое общие библиотеки, как их идентифицировать и где они находятся. Далее мы рассмотрим, как настроить места их хранения. Наконец, мы покажем, как искать общие библиотеки, от которых зависит конкретная программа.


## Концепция общих библиотек

Подобно своим физическим аналогам, программные библиотеки представляют собой наборы кода, которые предназначены для использования множеством различных программ; так же, как в физических библиотеках хранятся книги и другие ресурсы, которыми могут пользоваться разные люди. 

Чтобы создать исполняемый файл из исходного кода программы, необходимо выполнить два важных шага. Во-первых, *компилятор* превращает исходный код в машинный код, который хранится в так называемых *объектных файлах*. Во-вторых, *компоновщик* объединяет объектные файлы и связывает их с библиотеками, чтобы сгенерировать окончательный исполняемый файл. Это связывание может быть *статическим* или *динамическим*. В зависимости от того, какой метод мы выберем, мы будем говорить о статических библиотеках или, в случае динамической компоновки, об общих библиотеках. Поясним их различия. 

* Статические библиотеки  
Статическая библиотека объединяется с программой во время компоновки. Копия кода библиотеки встраивается в программу и становится ее частью. Таким образом, программа не зависит от библиотеки во время выполнения, потому что программа уже содержит код библиотеки. Отсутствие зависимостей можно рассматривать как преимущество, поскольку вам не нужно беспокоиться о том, чтобы используемые библиотеки всегда были доступны. С другой стороны, статически связанные программы тяжелее. 

* Общие(или динамические) библиотеки  
В случае общих библиотек компоновщик просто заботится о том, чтобы программа правильно ссылалась на библиотеки. Однако компоновщик не копирует код библиотеки в файл программы. Хотя во время выполнения общая библиотека должна быть доступна для удовлетворения зависимостей программы. Это экономичный подход к управлению системными ресурсами, поскольку он помогает уменьшить размер программных файлов, и в память загружается только одна копия библиотеки, даже если она используется несколькими программами.


## Соглашения об именах файлов общих объектов

Имя общей библиотеки, также известное как *soname*, следует шаблону, который состоит из трех элементов: 
* Имя библиотеки (обычно с префиксом `lib`) 
* `so` (что означает «общий объект») 
* Номер версии библиотеки 

Вот пример: `libpthread.so.0` 

Имена статических библиотек, напротив, заканчиваются на `.a`, например `libpthread.a`.

>Поскольку файлы, содержащие общие библиотеки, должны быть доступны при выполнении программы, большинство систем Linux содержат общие библиотеки. Поскольку статические библиотеки требуются только в выделенном файле при компоновке программы, они могут отсутствовать в системе конечного пользователя.

`glibc` (библиотека GNU C) - хороший пример общей библиотеки. В системе Debian GNU/Linux 9.9 ее файл называется `libc.so.6`. Такие довольно общие имена файлов обычно представляют собой символические ссылки, указывающие на фактический файл, содержащий библиотеку, имя которой содержит точный номер версии. В случае `glibc` эта символическая ссылка выглядит так:
```console
$ ls -l /lib/x86_64-linux-gnu/libc.so.6
lrwxrwxrwx 1 root root 12 feb  6 22:17 /lib/x86_64-linux-gnu/libc.so.6 -> libc-2.24.so
```
Этот шаблон ссылки на файлы общей библиотеки, названный конкретной версией, с помощью более общих имен файлов, является обычной практикой. 

Другие примеры общих библиотек включают `libreadline` (которая позволяет пользователям редактировать командные строки по мере их ввода и включает поддержку режимов редактирования Emacs и vi), `libcrypt` (которая содержит функции, связанные с шифрованием, хешированием и кодированием) или `libcurl` ( которая представляет собой многопротокольную библиотеку передачи файлов). Общие расположения общих библиотек в системе Linux: 

* `/lib/`
* `lib32`
* `/lib64
* `usr/lib/` 
* `/usr/local/lib`

>Концепция общих библиотек не является эксклюзивной для Linux. В Windows, например, они называются DLL, что означает динамически подключаемые библиотеки.


## Конфигурация путей к общей библиотеке

Ссылки, содержащиеся в динамически связанных программах, разрешаются динамическим компоновщиком (`ld.so` или `ld-linux.so`) при запуске программы. Динамический компоновщик ищет библиотеки в нескольких каталогах. Эти каталоги указаны по *пути к библиотеке*. Путь к библиотеке настраивается в каталоге `/etc`, а именно в файле `/etc/ld.so.conf` и, что более распространено в настоящее время, в файлах, находящихся в каталоге `/etc/ld.so.conf.d`. Обычно шаблон включает только одну строку `include` для файлов `*.conf` в последнем:
```console
$ cat /etc/ld.so.conf
include /etc/ld.so.conf.d/*.conf
```
Каталог `/etc/ld.so.conf.d` содержит файлы `*.conf`:
```console
$ ls /etc/ld.so.conf.d/
libc.conf  x86_64-linux-gnu.conf
```
Эти `*.conf` файлы должны включать абсолютные пути к каталогам общих библиотек:
```console
$ cat /etc/ld.so.conf.d/x86_64-linux-gnu.conf
# Multiarch support
/lib/x86_64-linux-gnu
/usr/lib/x86_64-linux-gnu
```
Команда `ldconfig` позаботится о чтении этих файлов конфигурации, создании вышеупомянутого набора символических ссылок, которые помогают найти отдельные библиотеки, и, наконец, об обновлении файла кеша `/etc/ld.so.cache`. Таким образом, `ldconfig` необходимо запускать каждый раз, когда файлы конфигурации добавляются или обновляются. 

Полезные параметры для `ldconfig`: 

`-v`, `--verbose`  
Отображает номера версий библиотеки, имя каждого каталога и созданные ссылки:
```console
$ sudo ldconfig -v
/usr/local/lib:
/lib/x86_64-linux-gnu:
    libnss_myhostname.so.2 -> libnss_myhostname.so.2
	libfuse.so.2 -> libfuse.so.2.9.7
	libidn.so.11 -> libidn.so.11.6.16
	libnss_mdns4.so.2 -> libnss_mdns4.so.2
	libparted.so.2 -> libparted.so.2.0.1
	(...)
 ```
Таким образом, мы можем увидеть, например, как `libfuse.so.2` связан с фактическим файлом общих объектов `libfuse.so.2.9.7`.

`-p`, `--print-cache`  
Выводит списки каталогов и библиотек-кандидатов, хранящиеся в текущем кеше:
```console
$ sudo ldconfig -p
1094 libs found in the cache `/etc/ld.so.cache'
    libzvbi.so.0 (libc6,x86-64) => /usr/lib/x86_64-linux-gnu/libzvbi.so.0
	libzvbi-chains.so.0 (libc6,x86-64) => /usr/lib/x86_64-linux-gnu/libzvbi-chains.so.0
	libzmq.so.5 (libc6,x86-64) => /usr/lib/x86_64-linux-gnu/libzmq.so.5
	libzeitgeist-2.0.so.0 (libc6,x86-64) => /usr/lib/x86_64-linux-gnu/libzeitgeist-2.0.so.0
	(...)
```
Обратите внимание, как кеш использует полное имя ссылки:
```console
$ sudo ldconfig -p |grep libfuse
	  libfuse.so.2 (libc6,x86-64) => /lib/x86_64-linux-gnu/libfuse.so.2
```
Если мы добавим длинный список `/lib/x86_64-linux-gnu/libfuse.so.2`, мы найдем ссылку на фактический файл общих объектов `libfuse.so.2.9.7`, который хранится в том же каталоге:
```console
$ ls -l /lib/x86_64-linux-gnu/libfuse.so.2
lrwxrwxrwx 1 root root 16 Aug 21  2018 /lib/x86_64-linux-gnu/libfuse.so.2 -> libfuse.so.2.9.7
```
>Поскольку для этого требуется доступ на запись в `/etc/ld.so.cache` (принадлежащий пользователю root), вы должны либо быть пользователем root, либо использовать `sudo` для вызова `ldconfig`. Для получения дополнительной информации о переключателях `ldconfig` обратитесь к соответствующей странице руководства.

В дополнение к файлам конфигурации, описанным выше, переменная среды `LD_LIBRARY_PATH` может использоваться для временного добавления новых путей к разделяемым библиотекам. Он состоит из набора каталогов, разделенных двоеточиями (`:`), в которых осуществляется поиск библиотек. Чтобы добавить, например, `/usr/local/mylib` к пути библиотеки в текущем сеансе оболочки, вы можете набрать:
```console
$ LD_LIBRARY_PATH=/usr/local/mylib
```
Теперь вы можете проверить его значение:
```console
$ echo $LD_LIBRARY_PATH
/usr/local/mylib
```
Чтобы добавить `/usr/local/mylib` к пути библиотеки в текущем сеансе оболочки и экспортировать его во все дочерние процессы, порожденные этой оболочкой, вы должны ввести:
```console
$ unset LD_LIBRARY_PATH
```
Чтобы изменения были постоянными, вы можете написать строку
```console
export LD_LIBRARY_PATH=/usr/local/mylib
```
в одном из сценариев инициализации Bash, например `/etc/bash.bashrc` или `~/.bashrc`.

>`LD_LIBRARY_PATH` для общих библиотек то же самое, что `PATH` для исполняемых файлов. Дополнительные сведения о переменных среды и конфигурации оболочки смотри в соответствующих уроках.


## Поиск зависимостей конкретного исполняемого файла
