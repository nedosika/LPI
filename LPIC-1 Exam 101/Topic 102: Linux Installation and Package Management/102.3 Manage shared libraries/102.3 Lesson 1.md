# 102.3 Урок 1

| **Сертификат:** | LPIC-1                                    |
|:----------------|:------------------------------------------|
| **Версия:**     | 5.0                                       |
| **Тема:**       | 102 Установка Linux и управление пакетами |
| **Цель:**       | 102.3 Управление общими библиотеками      |
| **Урок:**       | 1 из 1                                    |


## Введение

В этом уроке мы обсудим *общие библиотеки*, также известные как *общие объекты*: части скомпилированного многократно используемого кода, такие как функции или классы, которые периодически используются различными программами. 

Для начала мы объясним, что такое общие библиотеки, как их идентифицировать и где они находятся. Далее мы рассмотрим, как настроить места их хранения. Наконец, мы покажем, как искать общие библиотеки, от которых зависит конкретная программа.


## Концепция общих библиотек

Подобно своим физическим аналогам, программные библиотеки представляют собой наборы кода, которые предназначены для использования множеством различных программ; так же, как в физических библиотеках хранятся книги и другие ресурсы, которыми могут пользоваться разные люди. 

Чтобы создать исполняемый файл из исходного кода программы, необходимо выполнить два важных шага. Во-первых, *компилятор* превращает исходный код в машинный код, который хранится в так называемых *объектных файлах*. Во-вторых, *компоновщик* объединяет объектные файлы и связывает их с библиотеками, чтобы сгенерировать окончательный исполняемый файл. Это связывание может быть *статическим* или *динамическим*. В зависимости от того, какой метод мы выберем, мы будем говорить о статических библиотеках или, в случае динамической компоновки, об общих библиотеках. Поясним их различия. 

* Статические библиотеки  
Статическая библиотека объединяется с программой во время компоновки. Копия кода библиотеки встраивается в программу и становится ее частью. Таким образом, программа не зависит от библиотеки во время выполнения, потому что программа уже содержит код библиотеки. Отсутствие зависимостей можно рассматривать как преимущество, поскольку вам не нужно беспокоиться о том, чтобы используемые библиотеки всегда были доступны. С другой стороны, статически связанные программы тяжелее. 

* Общие(или динамические) библиотеки  
В случае общих библиотек компоновщик просто заботится о том, чтобы программа правильно ссылалась на библиотеки. Однако компоновщик не копирует код библиотеки в файл программы. Хотя во время выполнения общая библиотека должна быть доступна для удовлетворения зависимостей программы. Это экономичный подход к управлению системными ресурсами, поскольку он помогает уменьшить размер программных файлов, и в память загружается только одна копия библиотеки, даже если она используется несколькими программами.


## Соглашения об именах файлов общих объектов

Имя общей библиотеки, также известное как *soname*, следует шаблону, который состоит из трех элементов: 
* Имя библиотеки (обычно с префиксом `lib`) 
* `so` (что означает «общий объект») 
* Номер версии библиотеки 

Вот пример: `libpthread.so.0` 

Имена статических библиотек, напротив, заканчиваются на `.a`, например `libpthread.a`.

>Поскольку файлы, содержащие общие библиотеки, должны быть доступны при выполнении программы, большинство систем Linux содержат общие библиотеки. Поскольку статические библиотеки требуются только в выделенном файле при компоновке программы, они могут отсутствовать в системе конечного пользователя.

`glibc` (библиотека GNU C) - хороший пример общей библиотеки. В системе Debian GNU/Linux 9.9 ее файл называется `libc.so.6`. Такие довольно общие имена файлов обычно представляют собой символические ссылки, указывающие на фактический файл, содержащий библиотеку, имя которой содержит точный номер версии. В случае `glibc` эта символическая ссылка выглядит так:
```console
$ ls -l /lib/x86_64-linux-gnu/libc.so.6
lrwxrwxrwx 1 root root 12 feb  6 22:17 /lib/x86_64-linux-gnu/libc.so.6 -> libc-2.24.so
```
Этот шаблон ссылки на файлы общей библиотеки, названный конкретной версией, с помощью более общих имен файлов, является обычной практикой. 

Другие примеры общих библиотек включают `libreadline` (которая позволяет пользователям редактировать командные строки по мере их ввода и включает поддержку режимов редактирования Emacs и vi), `libcrypt` (которая содержит функции, связанные с шифрованием, хешированием и кодированием) или `libcurl` ( которая представляет собой многопротокольную библиотеку передачи файлов). Общие расположения общих библиотек в системе Linux: 

* `/lib/`
* `lib32`
* `/lib64
* `usr/lib/` 
* `/usr/local/lib`

>Концепция общих библиотек не является эксклюзивной для Linux. В Windows, например, они называются DLL, что означает динамически подключаемые библиотеки.


## Конфигурация путей к общей библиотеке

Ссылки, содержащиеся в динамически связанных программах, разрешаются динамическим компоновщиком (`ld.so` или `ld-linux.so`) при запуске программы. Динамический компоновщик ищет библиотеки в нескольких каталогах. Эти каталоги указаны по *пути к библиотеке*. Путь к библиотеке настраивается в каталоге `/etc`, а именно в файле `/etc/ld.so.conf` и, что более распространено в настоящее время, в файлах, находящихся в каталоге `/etc/ld.so.conf.d`. Обычно шаблон включает только одну строку `include` для файлов `*.conf` в последнем:
```console
$ cat /etc/ld.so.conf
include /etc/ld.so.conf.d/*.conf
```
Каталог `/etc/ld.so.conf.d` содержит файлы `*.conf`:
```console
$ ls /etc/ld.so.conf.d/
libc.conf  x86_64-linux-gnu.conf
```
Эти `*.conf` файлы должны включать абсолютные пути к каталогам общих библиотек:
```console
$ cat /etc/ld.so.conf.d/x86_64-linux-gnu.conf
# Multiarch support
/lib/x86_64-linux-gnu
/usr/lib/x86_64-linux-gnu
```
Команда `ldconfig` позаботится о чтении этих файлов конфигурации, создании вышеупомянутого набора символических ссылок, которые помогают найти отдельные библиотеки, и, наконец, об обновлении файла кеша `/etc/ld.so.cache`. Таким образом, `ldconfig` необходимо запускать каждый раз, когда файлы конфигурации добавляются или обновляются. 

Полезные параметры для `ldconfig`: 

`-v`, `--verbose`  
Отображает номера версий библиотеки, имя каждого каталога и созданные ссылки:
```console
$ sudo ldconfig -v
/usr/local/lib:
/lib/x86_64-linux-gnu:
    libnss_myhostname.so.2 -> libnss_myhostname.so.2
	libfuse.so.2 -> libfuse.so.2.9.7
	libidn.so.11 -> libidn.so.11.6.16
	libnss_mdns4.so.2 -> libnss_mdns4.so.2
	libparted.so.2 -> libparted.so.2.0.1
	(...)
 ```
Таким образом, мы можем увидеть, например, как `libfuse.so.2` связан с фактическим файлом общих объектов `libfuse.so.2.9.7`.

`-p`, `--print-cache`  
Выводит списки каталогов и библиотек-кандидатов, хранящиеся в текущем кеше:
```console
$ sudo ldconfig -p
1094 libs found in the cache `/etc/ld.so.cache'
    libzvbi.so.0 (libc6,x86-64) => /usr/lib/x86_64-linux-gnu/libzvbi.so.0
	libzvbi-chains.so.0 (libc6,x86-64) => /usr/lib/x86_64-linux-gnu/libzvbi-chains.so.0
	libzmq.so.5 (libc6,x86-64) => /usr/lib/x86_64-linux-gnu/libzmq.so.5
	libzeitgeist-2.0.so.0 (libc6,x86-64) => /usr/lib/x86_64-linux-gnu/libzeitgeist-2.0.so.0
	(...)
```
Обратите внимание, как кеш использует полное имя ссылки:
```console
$ sudo ldconfig -p |grep libfuse
	  libfuse.so.2 (libc6,x86-64) => /lib/x86_64-linux-gnu/libfuse.so.2
```
Если мы добавим длинный список `/lib/x86_64-linux-gnu/libfuse.so.2`, мы найдем ссылку на фактический файл общих объектов `libfuse.so.2.9.7`, который хранится в том же каталоге:
```console
$ ls -l /lib/x86_64-linux-gnu/libfuse.so.2
lrwxrwxrwx 1 root root 16 Aug 21  2018 /lib/x86_64-linux-gnu/libfuse.so.2 -> libfuse.so.2.9.7
```
>Поскольку для этого требуется доступ на запись в `/etc/ld.so.cache` (принадлежащий пользователю root), вы должны либо быть пользователем root, либо использовать `sudo` для вызова `ldconfig`. Для получения дополнительной информации о переключателях `ldconfig` обратитесь к соответствующей странице руководства.

В дополнение к файлам конфигурации, описанным выше, переменная среды `LD_LIBRARY_PATH` может использоваться для временного добавления новых путей к разделяемым библиотекам. Он состоит из набора каталогов, разделенных двоеточиями (`:`), в которых осуществляется поиск библиотек. Чтобы добавить, например, `/usr/local/mylib` к пути библиотеки в текущем сеансе оболочки, вы можете набрать:
```console
$ LD_LIBRARY_PATH=/usr/local/mylib
```
Теперь вы можете проверить его значение:
```console
$ echo $LD_LIBRARY_PATH
/usr/local/mylib
```
Чтобы добавить `/usr/local/mylib` к пути библиотеки в текущем сеансе оболочки и экспортировать его во все дочерние процессы, порожденные этой оболочкой, вы должны ввести:
```console
$ unset LD_LIBRARY_PATH
```
Чтобы изменения были постоянными, вы можете написать строку
```console
export LD_LIBRARY_PATH=/usr/local/mylib
```
в одном из сценариев инициализации Bash, например `/etc/bash.bashrc` или `~/.bashrc`.

>`LD_LIBRARY_PATH` для общих библиотек то же самое, что `PATH` для исполняемых файлов. Дополнительные сведения о переменных среды и конфигурации оболочки смотри в соответствующих уроках.


## Поиск зависимостей конкретного исполняемого файла

Чтобы найти общие библиотеки, необходимые для конкретной программы, используйте команду `ldd`, за которой следует абсолютный путь к программе. Вывод показывает путь к файлу общей библиотеки, а также шестнадцатеричный адрес памяти, по которому он загружен:
```console
$ ldd /usr/bin/git
    linux-vdso.so.1 =>  (0x00007ffcbb310000)
	libpcre.so.3 => /lib/x86_64-linux-gnu/libpcre.so.3 (0x00007f18241eb000)
	libz.so.1 => /lib/x86_64-linux-gnu/libz.so.1 (0x00007f1823fd1000)
	libresolv.so.2 => /lib/x86_64-linux-gnu/libresolv.so.2 (0x00007f1823db6000)
	libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f1823b99000)
	librt.so.1 => /lib/x86_64-linux-gnu/librt.so.1 (0x00007f1823991000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f18235c7000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f182445b000)
```
Точно так же мы используем `ldd` для поиска зависимостей общего объекта:
```console
$ ldd /lib/x86_64-linux-gnu/libc.so.6
	/lib64/ld-linux-x86-64.so.2 (0x00007fbfed578000)
	linux-vdso.so.1 (0x00007fffb7bf5000)
```
С параметром `-u` (или `--unused`) `ldd` выводит неиспользуемые прямые зависимости (если они существуют):
```console
$ ldd -u /usr/bin/git
Unused direct dependencies:
	/lib/x86_64-linux-gnu/libz.so.1
	/lib/x86_64-linux-gnu/libpthread.so.0
	/lib/x86_64-linux-gnu/librt.so.1
```
Причина неиспользуемых зависимостей связана с параметрами, используемыми компоновщиком при построении двоичного файла. Хотя программе не нужна неиспользуемая библиотека, она все же связана и помечена как `NEEDED` в информации об объектном файле. Вы можете исследовать это с помощью таких команд, как `readelf` или `objdump`, которые вы скоро будете использовать в исследовательском упражнении.


## Упражнения для закрепления

1. Разделите следующие имена общих библиотек на части:
| **Полное имя файла**   | **Название библиотеки** | ***so* суффикс** | **Номер версии** |
|:-----------------------|:------------------------|:-----------------|:-----------------|
| `linux-vdso.so.1`      |                         |                  |                  |  
| `libprocps.so.6`       |                         |                  |                  |
| `libdl.so.2`           |                         |                  |                  |  
| `libc.so.6`            |                         |                  |                  |
| `libsystemd.so.0`      |                         |                  |                  |  
| `ld-linux-x86-64.so.2` |                         |                  |                  |

2. Вы разработали часть программного обеспечения и хотите добавить в свою систему новый каталог общей библиотеки (`/opt/lib/mylib`). Вы указываете его абсолютный путь в файле `mylib.conf`. 
* В какой каталог вы должны поместить этот файл? 
* Какую команду следует запустить, чтобы изменения полностью вступили в силу?

3. Какую команду вы бы использовали для вывода списка общих библиотек, необходимых для `kill`?


## Упражнения на размышление

1. `objdump` - это утилита командной строки, которая отображает информацию из объектных файлов. Проверьте, установлен ли он в вашей системе с помощью файла `objdump`. Если это не так, установите его. 
* Используйте `objdump` с параметром `-p` (или `--private-headers`) и `grep` для вывода зависимостей `glibc`: 
* Используйте `objdump` с параметром `-p` (или `--private-headers`) и `grep`, чтобы вывести soname `glibc`: 
* Используйте `objdump` с параметром `-p` (или `--private-headers`) и `grep` для вывода зависимостей Bash:


## Резюме

Из этого урока вы узнали: 
* Что такое общая (или динамическая) библиотека. 
* Различия между общими и статическими библиотеками. 
* Имена общих библиотек (*sonames*). 
* Предпочтительное расположение общих библиотек в системе Linux, например `/lib` или `/usr/lib`. 
* Назначение динамического компоновщика `ld.so` (или `ld-linux.so`). 
* Как настроить пути к общим библиотекам с помощью файлов в `/etc/`, таких как `ld.so.conf` или файлов в каталоге `ld.so.conf.d`. 
* Как настроить пути к общей библиотеке с помощью переменной среды `LD_LIBRARY_PATH`. 
* Как найти зависимости исполняемых файлов и общих библиотек. 

Команды, используемые в этом уроке: 

`ls`  
Список содержимого каталога. 

`cat`  
Объедините файлы и распечатайте их на стандартный вывод. 

`sudo`  
Попросите суперпользователя выполнить команду с правами администратора. 

`ldconfig`  
Настройте привязки динамического компоновщика во время выполнения. 

`echo`  
Отображение значения переменной окружения. 

`export`  
Экспорт значения переменной окружения в дочерние оболочки. 

`unset`  
Удалить переменную окружения. 

`ldd`  
Распечатать зависимости общих объектов программы. 

`Readelf`  
Отображение информации о файлах ELF (ELF означает исполняемый и связываемый формат). 

`objdump`  
Распечатать информацию из объектных файлов.


## Ответы на упражнения для закрепления

1. Разделите следующие имена общих библиотек на части:
| **Полное имя файла**   | **Название библиотеки** | ***so* суффикс** | **Номер версии** |
|:-----------------------|:------------------------|:-----------------|:-----------------|
| `linux-vdso.so.1`      | `linux-vdso`            | `so`             | `1`              |  
| `libprocps.so.6`       | `libprocps`             | `so`             | `6`              |
| `libdl.so.2`           | `libdl`                 | `so`             | `2`              |  
| `libc.so.6`            | `libc`                  | `so`             | `6`              |
| `libsystemd.so.0`      | `libsystemd`            | `so`             | `0`              |  
| `ld-linux-x86-64.so.2` | `ld-linux-x86-64`       | `so`             | `2`              |

2. Вы разработали часть программного обеспечения и хотите добавить в свою систему новый каталог общей библиотеки (`/opt/lib/mylib`). Вы указываете его абсолютный путь в файле `mylib.conf`. 
* В какой каталог вы должны поместить этот файл?  
`/etc/ld.so.conf.d`
* Какую команду следует запустить, чтобы изменения полностью вступили в силу?  
`ldconfig`

3. Какую команду вы бы использовали для вывода списка общих библиотек, необходимых для `kill`?  
`ldd /bin/kill`


## Ответы на упражнения для размышления

1. `objdump` - это утилита командной строки, которая отображает информацию из объектных файлов. Проверьте, установлен ли он в вашей системе с помощью файла `objdump`. Если это не так, установите его. 
* Используйте `objdump` с параметром `-p` (или `--private-headers`) и `grep` для вывода зависимостей `glibc`:  
`objdump -p /lib/x86_64-linux-gnu/libc.so.6 | grep NEEDED`
* Используйте `objdump` с параметром `-p` (или `--private-headers`) и `grep`, чтобы вывести soname `glibc`:  
`objdump -p /lib/x86_64-linux-gnu/libc.so.6 | grep SONAME`
* Используйте `objdump` с параметром `-p` (или `--private-headers`) и `grep` для вывода зависимостей Bash:  
`objdump -p /bin/bash | grep NEEDED`
